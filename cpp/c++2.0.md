<img src="E:\MarkDown\picture\image-20220530215417521.png" alt="image-20220530215417521" style="zoom:50%;" />

## C++ 11 有哪些特性



# 语言新特性

## ==可变模板参数==

2.15-21.Variadic Templates

>  ​	可变参数模板，为一个可接受可变数目参数的模板函数或模板类。可变数目的参数被成为参数包，用省略号来指出一个模板参数或函数参数表示一个包。对于可变参数模板，**编译器会递归展开来推断包中参数的数目**。根据你参数的不同，编译器会实例化出不同的版本
>
> <img src="E:\MarkDown\picture\image-20221112135451385.png" alt="image-20221112135451385" style="zoom: 67%;" />
> <img src="E:\MarkDown\picture\image-20221112135504576.png" alt="image-20221112135504576" style="zoom:67%;" />
>
> 存在意义：
> 	initializer_list可以用来定义一个可接受可变数目实参的函数，但**所有实参必须具有相同类型（或可以转换为同一个公共类型）**，而可变参数模板可以处理任意的实参数目和类型

**1.可变参数函数通常是递归的**

```cpp
// 第一步调用处理包中的第一个实参，然后用剩余实参调用自身。为了终止递归，还需要定义一个非可变参数的函数

// 必须要有一个函数用于结束递归，且这个非可变参数版本的声明必须在作用域中
// 对于最后一个调用，可变参数版本和非可变参数版本提供同样好的匹配。但非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本
void func() { /*... */}

template<typename T, typename... Types>  // 此处为第一处固定形式
void func(const T &firstArg, const Types &... args) {  // 此处为第二处固定形式，写为Types ... args即可
    // 可以接受任意个数的参数，且参数的类型也是任意的，可以将输入参数分为一个和一包
    // 先处理第一个参数firstArg,再递归调用func函数处理余下的一包
    
    // 如果想知道args这包里有多少个参数时，可以使用sizeof...运算符，其返回一个常量表达式
    cout << sizeof...(args);
    
    func(args...);  // 此处为第三处固定形式
}
```

**2.包扩展**

> 对于一个参数包，除了获取大小外，还可以进行**扩展**，即将其分解为构成的元素，对每个元素应用模式，获得扩展后的列表
>
> 用处：
> 可以通过`print(os,func(rest)...)`等类似形式，将一个函数应用到所有实参中

<img src="E:\MarkDown\picture\image-20221112141838121.png" alt="image-20221112141838121" style="zoom:67%;" />
<img src="E:\MarkDown\picture\image-20221112141958422.png" alt="image-20221112141958422" style="zoom:67%;" />

**3.转发参数包**

>可以组合使用可变参数模板与forward机制编写函数，实现将实参不变地传递给其他函数

emplace_back成员用其实参在容器管理的内存空间中直接构造一个元素

```c++
class StrVec {
public:
    // 为了保持实参中的信息，需要将函数参数定义为右值引用
    // Args&&...使用了模板参数包扩展，模式为&&
    template <class... Args> void emplace_back(Args&&...);
}

template <class... Args>
inline
void StrVec::emplace_back(Args&&... args) {
    chk_n_alloc();  // 定义的一个重新分配内存空间的函数
    // 扩展包，通过forward返回该显式实参类型的右值引用来保持实参的原始类型
    alloc.construct(first_free++, std::forward<Args>(args)...);
}
```

<img src="E:\MarkDown\picture\image-20221112153726880.png" alt="image-20221112153726880" style="zoom:67%;" />

**示例：递归函数调用**

![image-20220619171354690](E:\MarkDown\picture\image-20220619171354690.png)

这里1、2、3均为重载，但这里调用了1，因为2和3传入的第一个参数都要求是size_t类型，不符合。调用1后，再次hash_val的时候增加了个size_t的参数，这时候就会优先调用2这种更特化的版本。最后到终止条件的时候，调用了3和4

**示例1: 定义`printX()`函数输出任意数目任意类型的变量**

![image-20220530220559008](E:\MarkDown\picture\image-20220530220559008.png)

```cpp
// 重载版本1,用于结束递归
void printX() {
}

// 重载版本2,先输出第一个参数,再递归调用自己处理余下的参数
template<typename T, typename... Types>
void printX(const T &firstArg, const Types &... args) {
    cout << firstArg << endl;
    printX(args...);
}

// 重载版本3，和版本二的区别在于，这个是直接接受一堆，版本二是接受一个和多个
// 正常来说两个版本是ambigious的，但这里可以共存
// 重载版本2的函数比重载版本3的更特化;当多个重载版本均满足输入参数时,编译器会优先调用更特化的版本
template<typename... Types>
void printX(const Types &... args) {
}

int main(){
	printX(7.5, "hello", 42);
	return 0;
}
```







**示例2: 重写`printf()`函数**

```cpp
// 注意，printf的重载要写在自己的命名空间中，否则会报错 error: call of overloaded 'printf(const char*&)' is ambiguous
#include<iostream>
namespace my{

void printf(const char *s) {
    while (*s) {
        if (*s == '%' && *(++s) != '%')
            throw std::runtime_error("invalid format string: missing arguments");
        std::cout << *s++;
    }
}

template<typename T, typename... Args>
void printf(const char *s, T value, Args... args) {
    while (*s) {
        if (*s == '%' && *(++s) != '%') {
            std::cout << value;  // 直接输出。这里要看有没有对 << 进行重载
            printf(++s, args...); // call even when *s = 0 to detect extra arguments  这里++s的目的是避开%d的那个d
            // 为了模拟c，即%d等这些符号和参数个数是对应的。所以读完最后剩一个的时候跳转到第一个void printf(const char *s)中。若还检测出%，则说明是多余的，丢出异常
            return;
        }
        std::cout << *s++;
    }
    throw std::logic_error("extra arguments provided to printf");
}
}

int main(){
	int* pi = new int;
	my::printf("%d %s %p %f\n", 15, "This is Ace.", pi, 3.141592653);
	return 0;
}
```





**示例3: 重写`max()`函数接收任意参数**

若`max()`函数的所有参数的**类型相同**的话,直接使用`initializer_list`传递参数即可.

```cpp
std::max({10.0, 20.0, 4.5, 8.1});
```

若`initializer_list`中的参数类型不同则会报错

```cpp
std::max({10, 20, 4.5, 8.1});		// ERROR: no matching function for call to 'max(<brace-enclosed initializer list>)'
```

使用variadic template重写`max`函数使之接受任意参数:

```cpp
int maximum(int n) {
    return n;
}

template<typename... Args>
int maximum(int n, Args... args) {
    return std::max(n, maximum(args...));
}

int main(){
	cout << maximum(10, 20, 4.5, 8.1);  // 输出20
	return 0;
}
```





**示例4: 重载`tuple`的`<<`运算符,以异于一般的方式处理头尾元素**

![image-20220624181841536](E:\MarkDown\picture\image-20220624181841536.png)

```cpp
// 程序目的是打印出[7.5, hello, 0000011, 42]这种前后有[]的形式
// output operator for tuples
template<typename... Args>
ostream &operator<<(ostream &os, const tuple<Args...> &t) {
    os << "[";
    PRINT_TUPLE<0, sizeof...(Args), Args...>::print(os, t);
    return os << "]";
}

// helper: print element with index IDX of the tuple with MAX elements
template<int IDX, int MAX, typename... Args>
struct PRINT_TUPLE {
    static void print(ostream &os, const tuple<Args...> &t) {
        os << get<IDX>(t) << (IDX + 1 == MAX ? "" : ",");  // 如果不是最后一个元素，再打印一个 , ，若是最后一个元素，则不打印
        PRINT_TUPLE<IDX + 1, MAX, Args...>::print(os, t);
    }
};

// 最后一个空函数结束递归
// partial specialization to end the recursion
template<int MAX, typename... Args>
struct PRINT_TUPLE<MAX, MAX, Args...> {
    static void print(std::ostream &os, const tuple<Args...> &t) {
    }
};
```



**示例5: 递归继承(recursive inheritance)实现`tuple`容器**

![image-20220619172524474](E:\MarkDown\picture\image-20220619172524474.png)

```cpp
#include<iostream>
using namespace std;

namespace a{
// 定义 tuple类
template<typename... Values>
class tuple;

// 特化模板参数: 空参，z
template<>
class tuple<> {};

// 特化模板参数
template<typename Head, typename... Tail>
class tuple<Head, Tail...> : private tuple<Tail...>  // recursive inheritance方便完成递归继承
// tuple类继承自tuple类,父类比子类少了一个模板参数
{
    typedef tuple<Tail...> inherited;	// 父类类型  
protected:
    Head m_head;						// 保存第一个元素的值
public:
    tuple() {}
    tuple(Head v, Tail... vtail)		// 构造函数: 将第一个元素赋值给m_head,使用其他元素构建父类tuple
		: m_head(v), inherited(vtail...) {}

    Head head() {return m_head;}		// 返回第一个元素值
    // auto head()->decltype(m_head)  {return m_head;}//多此一举，m_head的类型就是Head
    inherited &tail() { return *this; }	// 返回剩余元素组成的tuple(将当前元素强制转换为父类类型)   
};
}

int main(){
	a::tuple<int, float, string> t(41, 6.3, "nico");
	cout << t.head() << endl;
	cout << t.tail().head() << endl;
	cout << t.tail().tail().head() << endl;
	return 0;
}
```



**示例6: 递归复合(recursive composition)实现`tuple`容器**
![image-20220626110159731](E:\MarkDown\picture\image-20220626110159731.png)

```cpp
template<typename... Values>
class tup;

template<>
class tup<> {};

template<typename Head, typename... Tail>
class tup<Head, Tail...> {
    typedef tup<Tail...> composited;
protected:
    composited m_tail;
    Head m_head;
public:
    tup() {}
    tup(Head v, Tail... vtail) : m_tail(vtail...), m_head(v) {}
    
    Head head() { return m_head; }
    composited &tail() { return m_tail; }
};
```











## 3.Spaces in Template Expression、nullptr and std-nullptr_t、Automatic Type Deduction with auto

### Spaces in Template Expression

在C++11之前,多层模板参数在嵌套时,最后的两个`>`之间要加一个空格,以避免和`>>`运算符混淆;C++11之后就不需要这样做了

```cpp
vector<list<int> >;		// 左右版本均能通过编译
vector<list<int>>;		// C++11之后能通过编译
```

### nullptr and std--nullptr_t

C++11之后允许将变量`nullptr`赋值给未指向任何对象的指针(C++11之前使用`0`或`NULL`).这个新特性可以避免将空指针转为整数`0`带来的错误.

```cpp
// 函数f的两个重载版本
void f(int);
void f(void*);

// 调用函数
f(0);		// 调用 f(int)
f(NULL);	// 若NULL被定义为0,则会调用 f(int),产生错误
f(nullptr);	// 调用 f(void*)
```

`nullptr`可以被自动转换为任意指针类型,但不会被转换为整型数.`nullptr`的类型为`std::nullptr_t`,定义在头文件`cstddef`中.

```cpp
#if defined(_ cplusplus) & cplusplus >= 201103L
#ifndef_ GXX NULLPTR T
#define_ GXX NULLPTR T
	typedef decltype(nullptr) nullptr_t;
```

### Automatic Type Deduction with auto

使用auto类型说明符自动推断类型

C++11之后允许使用`auto`定义变量而不需要显式指定其类型,其类型由编译器自动推断得到。auto让编译器通过初始值来推算变量的类型，因此auto定义的变量必须有初始值

```cpp
auto i= 42; 		// i has type int
double f();
auto d= f(); 		// d has type double

auto p = new auto(obj);  // p指向一个和obj类型相同的对象
```

`auto`尤其适用于变量类型名特别长或难以写出的情况,如容器迭代器和lambda函数。

```cpp
vector<string> v;
auto pos = v.begin();		// pos 的类型为 vector<string>::iterator
auto l= [](intx)-> bool {	// l 的类型为一个接收int参数返回bool变量的lambda函数
	// ...
};
```

## 列表初始化

4.Unifrom Initialization

> 即列表初始化，唯一的差别就在于uniform initialization一般没有= 

在C++11之前,变量的初始化方式多种多样,有可能是有括号`()`,花括号`{}`和赋值运算符`=`.因此C++11引入了一种uniform initialization机制，上述用到的初始化方式都可以用一个花括号代替.

```cpp
int values[]{1, 2, 3};
vector<int> v{2, 3, 5, 7, 11, 13, 17};
vector<string> cities{"Berlin", "New York", "London", "Braunschweig" "Cairo", "Cologne"};
complex<double> c{4.0, 3.0}; 	// 等价于 c(4.0, 3.0)
```

uniform initialization是值初始化,未定义的基础数据类型的变量值设为`0`(或`nullptr`).

```cpp
int i;		// i has undefined value
int j{};	// j is initialized by 0
int* p;		// P has undefined value
int* q{};	// q is initialized by nullptr
```

uniform initialization还具有**防止窄化**的功能，当自动类型转换可能使变量降低精度时报错

```cpp
int x1(5.3);		// OK, but OUCH: xl becomes 5
int x2 = 5.3;		// OK, but OUCH: x2 becomes 5
int x3{5.0};		// ERROR: narrowing
int x4 = {5.3};		// ERROR: narrowing
char c1{7};			// OK: even though 7 is an int, this is not narrowing
char c2{99999};		// ERROR: narrowing (if 9999 doesn 'fut into a char)
std::vector<int> v1{1, 2, 4, 5};		// OK
std::vector<int> v2{1, 2.3, 4, 5.6};	// ERROR: narrowing
```

***

## 初始化列表

5.6.Initializer_list

​	初始化列表强制进行所谓的**值初始化**，这意味着即使是基本数据类型的局部变量，通常具有未定义的初始值，也会被初始化为0(如果是指针，则为nullptr)

​	并且要注意，Initializer_list的对象是通过指针指向array的元素，而不是包含他们。因此做copy的话会产生一个指向相同底层元素的对象，是浅拷贝，使用的时候需要多加注意

***

uniform initialization底层依赖于模板类`initializer_list<T>` ，该类封装了一个`array<T,n>`（对c++的数组进行扩展，就可以用到一些容器的操作，如迭代器等）.调用函数（如ctor）时该`array`内的元素可被编译器分解逐一传递给函数.

但若函数参数是`initializer_list<T>`，调用者却不能给予数个T参数然后以为他们会被自动转为一个initializer_list< T >传入。传入的数据不会被拆解，而是整个的传过去

```cpp
void print(std::initializer_list<int> vals) {
    // 对于使用，可以直接当作一个容器
    for (auto p = vals.begin(); p != vals.end(); ++p) { //a list of values
        std::cout << *p << endl;
    }
}
// 逐个输出列表中的元素
print({12, 3, 5, 7, 11, 13, 17}); 		// pass a list of values to print()
```

若函数同时有**接收多个参数**的重载版本和**接收initializer list**的重载版本,则优先调用**接收initializer list**的重载版本，作为一整块被传入

若是没有写initializer list的重载版本，则下面的例子中，P q{77, 5};和P s = {77, 5};会被编译器拆解为两个，调用 P(int a, int b)

```cpp
class P {
public:
    // 有两个重载版本的构造函数,uniform initialization时优先调用接收initializer list的重载版本
    P(int a, int b) {
        cout << "P(int, int), a=" << a << ", b=" << b << endl;
    }

    P(initializer_list<int> initlist) {
        cout << "P(initializer list<int>), values= ";
        for (auto i : initlist)
            cout << i << ' ';
        cout << endl;
    }
};

P p(77, 5);		// P(int, int), a=77, b=5，小括号，调用第一种情况
P q{77, 5};		// P(initializer list<int>), values= 77 5
P r{77, 5, 42}; // P(initializer list<int>), values= 77 5 42
P s = {77, 5};	// P(initializer list<int>), values= 77 5
```

***

STL中的大部分容器和算法相关函数均有接收initializer list的重载版本,以`vector`、`min`和`max`为例:

```cpp
#include <initializer_list>

vector(initializer_list<value_type> __l, 
       const allocator_type &__a = allocator_type()) 
    : _Base(a) 
    { _M_range_initalize(__l.begin(), __l.end(), random_access_iterator_tag()); }

vector &operator=(initalizer_list <value_type> __l) {
    this->assign(__l.begin(), __l.end());
    return *this;
}

void insert(iterator __position, initializer_list<value_type> __l) {
    this->insert(__position, __l.begin(), __l.end());
}

void assign(initializer_list<value_type> __l) { 
    this->assign(__l.begin(), __l.end()); 
}
```

```cpp
vector<int> v1{2, 5, 7, 13, 69, 83, 50};
vector<int> v2({2, 5, 7513, 69, 83, 50});
vector<int> v3;
v3 = {2, 5, 7, 13, 69, 83, 50};
v3.insert(v3.begin() + 2, {0, 1, 2, 3, 4});

for (auto i : v3)
    cout << i << ' ';
cout << endl; // 2 5 0 1 2 3 4 7 13 69 83 50

// 大于两个元素的比较：max({})
cout << max({string("Ace"), string("Stacy"), string("Sabrina"), string("Bark1ey")}); //Stacy
cout << min({string("Ace"), string("Stacy"), string("Sabrina"), string("Sarkley")}); //Ace
cout << max({54, 16, 48, 5}); //54
cout << min({54, 16, 48, 5});//5
```



## 8.基于范围的for语句

Range-based for statement



```cpp
for (decl : coll) {  // 只要coll是容器就行
	statement
}
for (decl& : coll) {  // 改变
	statement
}
for (const decl& : coll) {  // 不改变
	statement
}
```

本质：
![image-20220701094852671](E:\MarkDown\picture\image-20220701094852671.png) 

使用：
<img src="E:\MarkDown\picture\image-20220701094706022.png" alt="image-20220701094706022" style="zoom:60%;" />

当容器里的数据类型和decl的数据类型不匹配的时候，编译器会尝试去做类型转换，但如果像下面这样不允许转换，则会出现编译错误

```cpp
class C {
public:
    explicit C(const string& s);
};

vector<string> vs;
for(const C& elem : vs) {  // 从vector<string>里取出一个个字符串。但因为elem的类型是C,C又通过explicit禁止了隐式转换，因此报错：no conversion from string to C defined
	cout << elem << endl;
}
```



## 10.Alias Template（没怎么懂

> 模板别名，别名声明在模板上的用法
>
> 注意，在Alias Template上**不允许进行特化或偏特化**

```cpp
//别名声明，使用using关键字
using SI = Sales_item;  // 把SI作为等号右侧类型的别名
using F = int(int*, int);  // F为函数类型

template<typename T>
using Vec = std::vector<T, MyAlloc<T>>;		// 使用alias template语法定义含有自定义分配器的vector

Vec<int> container;		// 使用Vec类型
```

上述功能使用**宏定义**或**`typedef`**都不能实现

* 要想使用宏定义实现该功能,从语义上来说,应该这样实现:

```cpp
#define Vec<T> template<typename T> std::vector<T, MyAlloc<T>>;		// 理想情况下应该这样写,但不能通过编译
Vec<int> container;  // 展开就是std::vector<int, MyAlloc<int>> container;
```

但是`define`不支持以小括号定义参数,要想符合语法,需要这样写

```cpp
#define Vec(T) std::vector<T, MyAlloc<T>>		// 能通过编译,但是使用小括号失去了泛型的语义
Vec(int) container;
```

这样可以通过编译,但是`Vec(int)`这种指定泛型的方式与原生指定泛型的方式不一致.

* `typedef`不接受参数,因此也不能实现上述功能

若使用typedef可以写成这样，相比Alias Template更复杂了

```cpp
template<typename T>
struct MyAllocList {
    typedef std::list<T, MyAlloc<T>> type;
}
 
MyAllocList<Widget>::type lw;
```

***

![image-20220630193025340](E:\MarkDown\picture\image-20220630193025340.png)

问题：这里传入list后，cntr为list，但Container作为list的类型是未知的，没法拿来用

![image-20220630193143299](E:\MarkDown\picture\image-20220630193143299.png)

改进后，传入的必须是个对象，所以传入list()，typename+()表示一个临时对象。然后通过函数模板做实参的推导，因此可以得到Container和T的类型。但Container< T > c；会报错，认为Container不是一个模板

![image-20220630194205349](E:\MarkDown\picture\image-20220630194205349.png)

先取出Container的迭代器，再通过traits得到value_type，即每个元素的类型，然后typedef取个别名为Valtype。但若没有迭代器呢？**模板模板参数**出场

***

## 11.Template template parameter

**模板模板参数**也需要通过alias template指定其它模板参数的初值:

```cpp
template<typename T, template<class> class Container>  // 第二参数是类模板，如template<class NameType> class Person{};
class XCls {
private:
    Container<T> c;
public:
    // ...
};


// 错误写法:
XCls<string, list> mylst2;		// 错误:虽然list的第二模板参数即分配器有默认值,但是其作模板模板参数时不能自动推导，编译器这里无法推导出元素类型后给分配器让其完成空间分配的工作

// 正确写法: 使用alias template指定第二模板参数
template<typename T>
using LST = list<T, allocator<T>>;
XCls<string, LST> mylst2;		// 正确:模板LST只需要一个模板参数
```







## 12.using

 总结一下using 的用法
![image-20220629195458870](E:\MarkDown\picture\image-20220629195458870.png)



## ==lambdas==

> lambda表达式作为可调用对象，存储在栈区
>
> 如果是一个函数对象类的实例的话，存储位置可以是在堆区，可以被动态分配和释放

​	匿名函数可以免去函数的声明和定义。这样匿名函数仅**在调用函数的时候才会创建函数对象**，而调**用结束后立即释放**，所以匿名函数比非匿名函数`更节省空间`

> 补充：
>	如果一个类将`()`运算符重载为成员函数，这个类就称为**函数对象类**，这个类的对象就是**函数对象**。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名。
> 
> ​	使用STL时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。而且，定义函数对象类的地方和使用函数对象的地方可能相隔较远，看到函数对象，想要查看其 operator() 成员函数到底是做什么的也会比较麻烦。
>​	对于只使用一次的函数对象类，能否直接在使用它的地方定义呢？Lambda 表达式能够解决这个问题。**使用 Lambda 表达式可以减少程序中函数对象类的数量**，使得程序更加优雅。

lambda函数既可以用作变量，也可以立即执行:

```cpp
// 用作变量，或者说将其作为了一个函数指针
auto l = [] {
    std::cout << "hello lambda" << std::endl;
};
// 执行
l();

// 直接执行
[] {
    std::cout << "hello lambda" << std::endl;
}();  // 区别！！这里加了小括号
```

> [外部变量访问方式说明符] (参数表) -> 返回值类型 {
> 	语句块
> }
>
> * 外部变量访问方式说明符
>   可以是`=`或`&`，表示语句块中用到的、定义在语句块`外面`的变量在`{}`中是否允许被改变。`=`表示不允许，即使用值传递变量，`&`表示允许，即使用引用传递变量。当然，在`{}`中也可以不使用定义在外面的变量。
>
> * -> 返回值类型可以省略。

```cpp
[=] (int x, int y) -> bool {return x%10 < y%10; }
```

可以和STL标准库中的函数配合使用





```cpp
int main(){
	int id = 0;
	// 这里id以值捕获，通过 mutable 关键字使得值捕获的id也是可变的
	auto f = [id]() mutable {
		std::cout << "id:" << id << std::endl;
		++id;
	};
	id = 42;
	f();							// id:0
	f();							// id:1
	f();							// id:2
	std::cout << id << std::endl;	// 42
	return 0;
}
```

​	可以发现，这里尽管改变了id，但lambda函数读入的还是一开始定义的id=0。lambda函数使用时相当于仿函数(functor), [...]中传入的对象相当于为仿函数的成员变量.

```cpp
class Functor {
    private:
    int id; // copy of outside id
    public:
    void operator()() {
        std::cout << "id: " << id << std::endl;
        ++id; // OK
    }
};
Functor f;
```

***

与STL结合时，相比于仿函数，lambda函数通常更优雅：

```cpp
int a[4] = {11, 2, 33, 4};
sort(a, a+4, [=](int x, int y) -> bool { return x%10 < y%10; } );
for_each(a, a+4, [=](int x) { cout << x << " ";} );

// lambda函数充当predict谓词
vector<int> vi{5, 28, 50, 83, 70, 590, 245, 59, 24};
int x = 30, y = 100;
remove_if(vi.begin(), vi.end(),[x, y](int n) { return x < n && n < y; });
```

```cpp
// 仿函数充当predict谓词
class LambdaFunctor {
public:
    LambdaFunctor(int a, int b) : m_a(a), m_b(b) {}

    bool operator()(int n) const {
        return m_a < n && n < m_b;
    }

private:
    int m_a;
    int m_b;
};

remove_if(vi.begin(), vi.end(),
          	LambdaFunctor(x, y));
```





# move语义

> 对应primer13.6部分

## 23.==右值引用和move==

Rvalue references and Move Semantics

### 右值

[知乎上的一篇详解，右值引用、move、引用折叠、万能引用、完美转发(std::forward)](https://www.zhihu.com/question/363686723/answer/2590214399)

什么是右值

​	**可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）**。右值不能出现在赋值运算符`=`的左边

> c++11中，表达式按值类别分，必然属于以下三者之一：左值(left value,lvalue)，**将亡值**(expiring value,xvalue)，**纯右值**(pure rvalue,pralue)。其中，左值和将亡值合称泛左值(generalized  lvalue,glvalue)，纯右值和将亡值合称**右值**(right value,rvalue)。见下图
> ![image-20221112184158619](E:\MarkDown\picture\image-20221112184158619.png)
>
> 纯右值指非引用返回的临时变量、运算表达式产生的临时变量、字面常量和lambda表达式等
>将亡值为与右值引用相关的表达式，通常为要被移动的对象、如返回右值引用的函数返回值(T&&)、std::move的返回值等
> 
> 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象
>可以将一个const的左值引用或者一个右值引用绑定到这类表达式上
> 
> ```cpp
>int &r = i * 2;  // 不可将左值引用绑定在右值上
> int &&r = i;  // 不可将右值引用绑定在左值上
> const int &r = i * 2;  // 可以将const的引用绑定在右值上。常量引用的指向及指向的值都不可以修改。编译器优化代码，int temp = i * 2; const int& r = temp;相当于我们操作的ref为一个别名
> int &&r = i * 2;  // 可以将右值引用绑定在右值上
> ```

右值的特性

> 因为只能绑定到右值，因此右值引用具有：
> 所引用的对象将要被销毁；且该对象没有其他用户
> 这两个特性意味着，使用右值引用的代码可以自由地接管所引用的对象的资源

和左值的区别

> 一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值
>
> 左值引用不能绑定到 要求转换的表达式、字面常量或是返回右值的表达式，右值引用有着完全相反的绑定特性

### **右值引用**

**(c++11)**

> 为了支持移动操作，新标准引入了右值引用，即必须绑定到右值的引用，通过&&来获得右值引用

右值引用的意义

> 其目的是为了支持move操作，并且只能绑定到一个将要销毁的对象，因此可以自由地将一个右值引用的资源move到另一个对象中
>
> 右值引用主要用于**内置类**，其可以帮助解决**不必要的拷贝**，如将对象放到容器中，会制造一些临时对象，这里临时对象的制造很多时候是没必要的
>

右值引用的使用

> 因为变量是左值，因此不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行
>
> ```cpp
> int &&a = 1;  // 可以
> int &&b = a;  // 错误，变量是左值。即使这个变量是右值引用类型也不行
> 
> int foo() { return 5; }  // 右值
> int x = foo();
> // int *p = &foo();	// lvalue required as unary '&' operand 左值要求为一元'&'操作数。这里报错，因为地址运算符 & 需要一个变量来获取地址，这里是对函数返回的东西取地址，这里函数返回的是一个临时变量，无法获取地址
> int &&x = foo();  // 将右值引用绑定到右值foo上
> // foo() = 7;  // lvalue required as left operand of assignment 左值需要作为赋值的左操作数。 这里报错，因为foo为右值，不能出现在赋值运算符=的左边
> ```

### Move语义

**为什么需要移动操作**

>  * 在有些情况下，如重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。比如可以加速容器操作，对容器的效率有大幅度的改善。特别是对于容器增长
>* IO类或unique_ptr这样的类，都包含不能被共享的资源（如指针或IO缓冲），因此这些类型的对象不能拷贝，但可以移动。（补充：标准库容器、string和shared_ptr类既支持移动也支持拷贝）
> 

**move的作用**

​	move显式地将一个左值转换为对应的右值引用类型，进而可以调用移动构造函数等操作

定义和使用

>  定义在utility头文件中，且通常不为move提供using声明，一般直接调用std::move
>
>  要注意，调用move就意味着，除了对r赋予一个新值或销毁外，不能再使用它。这里r叫做移后源对象。
>
>  ```cpp
>  int &&r2 = std::move(r);  // 可以获得绑定到左值上的右值引用
>  // 注意，std::move的std不能省略
>  ```
>
>  <img src="E:\MarkDown\picture\image-20221004151650369.png" alt="image-20221004151650369" style="zoom:50%;" />



 （对于c++用户自定义类型，引入了一些微妙的关于改变和可转让性，造成了这个定义的不正确性。因此和int等变量不同，一些操作可以作为左值

![image-20220627151533377](E:\MarkDown\picture\image-20220627151533377.png)

例如对于string，单独写了处理右值的构造函数。当然这里的目的是用move代替copy来提高容器效率

<img src="E:\MarkDown\picture\image-20220627153416952.png" alt="image-20220627153416952" style="zoom: 50%;" />

专门处理右值的函数使用value_type&&声明参数：

```cpp
iterator insert(const_iterator __position, const value_type& __x);
iterator insert(const_iterator __position, value_type&& __x);
```



### 引用折叠

如果我们间接创建一个引用的引用，则这些引用形成了折叠：

1. **右值引用的右值引用**折叠为**右值引用**：类型X&&  &&折叠成X&&
2. 其他所有类型折叠为**左值引用**：X&  &、X&  &&和X&&  &都折叠成类型X&




### std::forward

​	调用中间函数会改变变量的可变性和左值右值等性质，导致参数的非完美转交(unperfect forwarding)，下面程序中的中间转交函数`forward()`破坏了参数本身是一个右值的性质:

```cpp
// 函数process的两个重载版本,分别处理参数是左值和右值的情况
void process(int &i) {
    cout << "process(int&):" << i << endl;
}
void process(int &&i) {
    cout << "process(int&&):" << i << endl;
}

// 中间转交函数forward接收一个右值,但函数内将其作为左值传递给函数process了
void forward(int &&i) {
    cout << "forward(int&&):" << i << ", ";
    process(i);
}
```

```cpp
int a = 0;
process(a);				// process(int&):0   	(变量作左值)
process(1);				// process(int&&):1		(临时变量作右值)
process(std::move(a)); 	// process(int&&):0		(使用std::move将左值改为右值)


forward(2); 			// forward(int&&):2, process(int&):2  通过cout的输出可以发现，临时变量作右值传给forward函数,forward函数体内将变量作为左值传给process函数。因为在传递过程中它变成了一个named object
forward(std::move(a)); 	// forward(int&&):0, process(int&):0	(临时变量作右值传给forward函数,forward函数体内将变量作为左值传给process函数)

// 错误
forward(a);         	// ERROR: cannot bind rvalue reference of type 'int&&' to lvalue of type 'int'，不能接收左值
const int &b = 1;
process(b);         	// ERROR: binding reference of type 'int&' to 'const int' discards qualifiers 将'int&'类型绑定到'const int'的引用将丢弃限定符 
process(move(b));       // ERROR: binding reference of type 'int&&' to 'std::remove_reference<const int&>::type' {aka 'const int'} discards qualifiers
```

使用`std::forward<T>()`函数可以完美转交变量,不改变其可变性和左值右值等性质

```cpp
// 函数process的两个重载版本,分别处理参数是左值和右值的情况
void process(int &i) {
    cout << "process(int&):" << i << endl;
}
void process(int &&i) {
    cout << "process(int&&):" << i << endl;
}

// 中间转交函数forward使用std::forward()转交变量
void forward(int &&i) {
    cout << "forward(int&&):" << i << ", ";
    process(std::forward<int>(i));
}

forward(2);           	// forward(int&&):2, process(int&&):2	(临时变量作右值传给forward函数,forward函数体内使用std::forward函数包装变量,保留其作为右值的性质)
forward(std::move(a));  // forward(int&&):0, process(int&&):0	(临时变量作右值传给forward函数,forward函数体内使用std::forward函数包装变量,保留其作为右值的性质)
```

**实现原理**

```cpp
// typename std::remove_reference<T>::type 是去掉引用后的参数类型
template <typename T>
T&& forward(typename std::remove_reference<T>::type& param) {  // 接收左值
    return static_cast<T&&>(param);  // 强制类型转换，转换的目标类型符合引用折叠规则，因此左值参数最终转换后仍为左值，右值参数最终转成右值。
}

template <typename T>
T&& forward(typename std::remove_reference<T>::type&& param) {  // 接收右值
    return static_cast<T&&>(param);
}
```

std::forward模板函数对传入的参数进行强制类型转换，转换的目标类型符合引用折叠规则，因此左值参数最终转换后仍为左值，右值参数最终转成右值。

当我们**入参传入左值时，他就是个左值引用**；当我们**入参传入右值时，他就是个右值引用**。通过这个规则，我们可以进而推断出 **T** 的类型,以 **string** 为模板为例:

* 当模板类型 `_Tp` 为 `string&` 时，即 string 的左值引用时，`std::forward` 可以化简为如下形式：

  ```cpp
  string& forward(string& __t)
  { return static_cast<string&>(__t); }
  ```

  显然，返回值是`string&`

* 当模板类型 `_Tp` 为 `string&&` 时，即 string 的右值引用时，`std::forward` 可以化简为如下形式：

  ```cpp
  string&& forward(string&& __t)
  { return static_cast<string&&>(__t); }
  ```

  



* 假设入参是一个 **const string 左值**： 此时 **T&&** 等同于 **const string&**，得到 **T 为 const string &**，即const 左值引用。
* 假设入参是**右值**，如 **move（string）**： 此时 **T&&** 等同于 **string&&**， 于是得到 T 为 **string&&**，即右值引用。返回值 T&& 进行引用折叠后为 string&& && -> string&&，仍为右值

### std::move的实现

16.2.6

```cpp
template<typename T>
typename remove_reference<T>::type&& move (T&& t) {
    return static_cast<typename remove_reference<T>::type&&>(t);
}
```

这里返回值是`typename remove_reference<T>::type&&`，即T&&。对于任意类型的输入，都会去掉引用然后强制转换为 (去引用后的T)&& 类型，即右值类型。

**补充1：typename**

对于类模板中的static成员，需要在类外定义（16.1.2

```cpp
template <typename T>
size_t Foo<T>::ctr = 0;
```

因此在我们使用作用域运算符(::)时，可能是在访问static成员```aoto ct = Foo<int>::ctr```或类型成员。对于模板代码，例如假定T是一个模板类型参数，当编译器遇到类似T: :mem这样的代码时，它不会知道mem是一个类型成员还是一个static数据成员，直至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。(` typename T::Y m_y;   // treat Y as a type`)因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用**关键字typename**来实现这一点：

```cpp
template <typename T>
typename T::value_type top(const T& c)
{
	if (!c. empty())
		return c.back() ;
	else
		return typename T::value_type() ;
}
```

typename显式告诉编译器，::前的是一个类型



**补充2：remove_reference**

​	`remove_reference<T>`为标准库的类型转换模板，定义在`#include<type_traits>`中，可以通过其type成员获得元素的类型。若用引用类型实例化，即T是一个引用，则type表示被引用的类型。主要用于迭代器，因为解引用迭代器得到的是元素的引用，我们需要用这个来得到元素的类型：`remove_reference<decltype(*beg)>::type`

(decltype见c++2.0)



**补充3：模板实参推断**

对于模板实参推断，正常来说：

* 对于形参为T&，只能传递一个左值，实参可以是const或普通左值
* 对于函数参数类型为const T&，可以传递任意类型，如一个对象、临时对象或是一个字面值常量
* 对于形参为右值引用(T&&)，可以传递一个右值。若这个右值引用指向模板类型参数，像这里的T&&，则可以传递一个**左值**，这里T会被编译器推断为实参的左值引用类型 **T&**，如int&



**补充4：实例化**

> 生成特定类或函数的过程成为实例化

move的函数参数是右值引用，通过引用折叠，可以与任何类型匹配：

* 传递一个右值，如std::move(string("aa"))，推断出T为string， remove_reference< T>::type也为string，remove_reference< T>::type&&为string&&，因此static_cast类型转换什么都不做
* 传递一个左值，std::move(s)，T推断为string&，此时函数参数t实例化为T& &&，折叠引用为T&。move函数的返回值通过remove_reference< T>::type去除引用，使得remove_reference< T>::type&&为string&&，再将t强制转换为string&&的形式返回。最后实例化为`string&& move(string &t)`



## 25.写一个 Move-aware class

> 移动构造函数：
> 	与拷贝构造函数不同， 移动构造函数不分配任何新内存：它接管给定的MyString中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。若没有将指针置为nullptr，则销毁移后源对象就会释放我们刚刚移动的内存
>
> noexcept
> 	noexcept是承诺一个函数不抛出异常的一种方法。在函数的参数列表后指定noexcept，**我们必须在移动构造函数和移动赋值运算符的类头文件的声明中和定义中(如果定义在类外的话)都指定noexcept**。由于移动操作窃取资源，它通常不分配任何资源，因此移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。（详细解释见primer474）
>
> 用处
> 如vector向量，当向量增长时，move构造函数将被调用。

编写一个支持move语义的类`MyString`以演示**移动构造函数**和**移动赋值函数**的写法.

拷贝构造函数：![image-20220629154515193](E:\MarkDown\picture\image-20220629154515193.png)移动构造函数：![image-20220629154417831](E:\MarkDown\picture\image-20220629154417831.png)

```cpp
#include <cstring>

class MyString {
public:
    // 做测试用的一些参数
    static size_t DCtor;    // 累计默认构造函数调用次数
    static size_t Ctor;     // 累计构造函数调用次数
    static size_t CCtor;    // 累计拷贝构造函数调用次数
    static size_t CAsgn;    // 累计拷贝赋值函数调用次数
    static size_t MCtor;    // 累计移动构造函数调用次数
    static size_t MAsgn;    // 累计移动赋值函数调用次数
    static size_t Dtor;     // 累计析构函数调用次数
private:
    char *_data;
    size_t _len;

    void _init_data(const char *s) {
        _data = new char[_len + 1];
        memcpy(_data, s, _len);
        _data[_len] = '\0';
    }

public:
    // 默认构造函数
    MyString() : _data(nullptr), _len(0) { ++DCtor; }

	// 构造函数
    MyString(const char *p) : _len(strlen(p)) {
        ++Ctor;
        _init_data(p);
    }

    // 拷贝构造函数
    MyString(const MyString &str) : _len(str._len) {
        ++CCtor;  // 做测试用的
        _init_data(str._data);  // 这里调用了_init_data，先创建空间再赋值，做了copy操作
    }
    
    // 移动构造函数
    MyString(MyString &&str) noexcept : _data(str._data), _len(str._len) {
        ++MCtor;
        str._len = 0;
        // 移动构造函数必须确保移后源对象处于这样一个状态：销毁它是无害的。一旦资源完成移动，源对象必须不再指向被移动的资源
        str._data = nullptr; 	// 将传入对象的_data指针设为nullptr而不是直接删除，防止析构函数多次delete同一根指针
    }
    
    // 拷贝赋值函数
    MyString &operator=(const MyString &str) {
        ++CAsgn;
        if (this != &str) {
            if (_data) delete _data;

            _len = str._len;
            _init_data(str._data); //COPY!
        }
        return *this;

    }

    

	// 移动赋值运算符
    MyString &operator=(MyString &&str) noexcept {
        ++MAsgn;
        // 移动赋值运算符需要右侧运算对象的一个右值，而此右值可能是move调用的返回结果，可能会左侧和右侧对象指向相同的对象，因此需要检查自赋值
        if (this != &str) {
            if (_data) delete _data;
            _len = str._len;
            _data = str._data; //MOVE!
            str._len = 0;
            // 将传入对象的_data指针设为nullptr,防止析构函数多次delete同一根指针
            // 确保移后源对象进入一个有效的、可析构的状态。但用户不能对其值进行任何假设
            str._data = nullptr;
        }
        return *this;
    }
/*
	// 另一个移动赋值运算符的例子
	Str &Str::operator=(Str &&rhs) noexcept {
		// 检测自赋值
		if (this != &rhs) {
			free();  // 释放已有元素
			elements = rhs.elements;  // 从rhs接管资源
			.....
			// 将rhs置于可析构状态
			rhs.elements = rhs.first = ... = nullptr;
		}
		return *this;
	}
*/

    //dtor
    virtual ~MyString() {
        ++Dtor;
        if (_data)
            delete _data;
    }
};

size_t MyString::DCtor = 0;
size_t MyString::Ctor = 0;
size_t MyString::CCtor = 0;
size_t MyString::CAsgn = 0;
size_t MyString::MCtor = 0;
size_t MyString::MAsgn = 0;
size_t MyString::Dtor = 0;
```

值得注意的有两点:

1. 移动构造函数和移动赋值函数通常不涉及内存操作,不会抛出异常,因此应加以`noexcept`修饰.
2. 在移动构造函数和移动赋值函数中,移动了原对象的数据后,要把原对象的数据指针置空,防止析构函数多次`delete`同一指针.

## 26.Move-aware class 对容器的效能测试

move语义可以减少深拷贝,可以加速容器操作,编写下述测试函数进行测试:

```cpp
template<typename M, typename NM>
void test_moveable(M c1, NM c2, long &value) {
    char buf[10];

    // 测试保存moveable对象的容器
    typedef typename iterator_traits<typename M::iterator>::value_type V1type;
    clock_t timeStart = clock();
    for (long i = 0; i < value; ++i) {
        snprintf(buf, 10, "%d", rand()); 	// 向容器内放入随机字符串
        auto ite = c1.end();				// 定位尾端
        c1.insert(ite, V1type(buf)); 		// 安插於尾端 (對RB-tree和HT這只是hint)
    }
    cout << "construction, milli-seconds: " << (clock() - timeStart) << endl;
    cout << "size()= " << c1.size() << endl;

	output_static_data(*(c1.begin()));
    // 测试容器的std::move()语义
    M c11(c1);
    M c12(std::move(c1));
    c11.swap(c12);

    // 对保存non-movable对象的容器进行上述测试
    // ...
}

template<typename T>
void output_static_data(const T &myStr) {
    cout << typeid(myStr).name() << "-- " << endl;
    cout << "CCtor=" << T::CCtor
         << " MCtor=" << T::MCtor
         << "Asgn=" << T::CAsgn
         << "MAsgn=" << T::MAsgn
         << "Dtor=" << T::Dtor
         << "Ctor=" << T::Ctor
         << "DCtor=" << T::DCtor
         << endl;
}
```

```cpp
long value = 3000000L;
test_moveable(vector<MyString>(), vector<MyStringNonMovable>(), value);
test_moveable(list<MyString>(), list<MyStringNonMovable>(), value);
test_moveable(deque<MyString>(), deque<MyStringNonMovable>(), value);
test_moveable(multiset<MyString>(), multiset<MyStringNonMovable>(), value);
test_moveable(unordered_multiset<MyString>(), unordered_multiset<MyStringNonMovable>(), value);
```

测试结果:

* 在插入元素部分,只有`vector`容器的速度受元素是否movable影响大,这是因为只有容器`vector`在增长过程中会发生复制.
* 对于所有容器,其移动构造函数都远快于其拷贝构造函数,容器`vector`的移动复制函数仅仅发生了指针的交换,未发生元素的复制.

# 一些关键字

## =default, =delete

### =default

> 使用`=default`使得编译器显式的给**类**加上默认的即合成版本的构造函数、析构函数、拷贝构造函数、拷贝赋值函数、移动构造函数等
>
> 注意，在类内用=default修饰成员的声明时，合成的函数将 `隐式地声明为内联` 的。若不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，如下例中的拷贝赋值运算符

```cpp
class Salse_date {
public:
    Salse_date() = default;
	Salse_date(const Salse_date&) = default;
	Salse_date& operator=(const Salse_date&);
	~Salse_date() = default;
};
Salse_date& Salse_date::operator=(const Salse_date&) = default;
```

**=default与手动添加空的构造函数的区别：**

​	在C++11之前,我们都是手动给类添加空的构造函数等函数,但是这样手动添加的函数与编译器生成的默认构造函数是不同的,一个影响就是使类**不再是POD类型，减少了编译器对其优化的可能性**。

编译器对POD类型的优化：

1. 内存布局优化：比如将成员字段按照排列方式进行排列，以减少填充字节的数量。
2. 复制和移动优化：对于POD类型的对象，编译器可以使用更高效的复制和移动操作。因为POD类型没有特殊的构造函数和构造函数的构造函数，因此可以直接进行字节拷贝，而无需调用构造函数和解析结构函数。
3. 优化对齐访问：编译器可以利用POD类型的特性，从而进行更高效的对齐访问。对齐访问可以减少内存访问的开销，并利用硬件的统一访问特性，提高访问效率。
4. 寄存器优化：对于POD类型的局部变量，编译器可以选择将其存储在寄存器中，而不是内存中。这样可以提高变量的访问速度。
5. 内联优化：对于POD类型的成员函数，编译器可以选择进行内联优化。内联优化可以将函数的代码插入到调用处，减少调用的费用，提高程序的执行效率。
6. 优化复制操作：对于POD类型的复制操作，编译器可以进行一些优化，如使用复制构造函数或移动语义来避免不必要的数据复制，提高复制操作的效率。

> POD类型：是Plain Old Data的缩写，**普通的旧数据类型**(比如 int、float、指针、union 、POD类型的数组、POD类型的structs等等都是 POD 类型)
>
> POD类型是聚合类型的子集
>
> 对于类或结构体，需要满足平凡的(trivial)和标准布局的(standard layout)两个条件：
> 平凡的：
> **拥有平凡的默认构造函数和析构函数**、**拥有平凡的拷贝构造函数和移动构造函数**、**拥有平凡的拷贝赋值运算符和移动赋值运算符**、**不能包含虚函数和虚基类**
> 标准布局的：
> **普通成员（即非静态数据）拥有相同的访问级别**、**只要有父类，普通成员只能在其中一个类中，不可分散**
> 但可以有自己的有参构造函数

```cpp
// std::is_pod可以判断是否为pod
// 也可以只判断平凡和标准布局：https://www.jianshu.com/p/191f713587cf
class A {
public:
    A() {}			// 手动添加的空参构造函数
    A(int mem) : member(mem) {}
private:
    int member;
};

class B {
public:
    B() = default;	// 使用编译器生成的空参构造函数
    B(int mem) : member(mem) {}
private:
    int member;
};

int main() {
    cout << std::is_pod<A>::value << endl;		// false
    cout << std::is_pod<B>::value << endl;		// true
    return 0;
}
```



### =delete

> ​	对某些类来说，拷贝构造函数和拷贝赋值运算符这些操作没有合理的意义，如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲，因此需要采用某种机制阻止拷贝或赋值。若只是不定义，编译器会生成合成的版本，因此我们需要=delete来阻止拷贝/移动。
>
> ​	`=delete`(或简写为`=0`)表示定义为删除的函数，即虽然我们声明了它们，但不能以任何方式使用它们，使得该类不具有对应的构造、析构、拷贝构造、拷贝赋值、析构等功能。
>
> > 与=default区别：
> >
> > * =delete必须出现在函数第一次声明的时候。一个默认的成员只影响为这个成员而生成的代码，因此=default直到编译器生成代码时才需要。而另一方面，编译器需要知道一个函数是删除的，以便禁止试图使用它的操作。
> > * 对于=default，只能对编译器可以合成的默认构造函数或拷贝控制成员使用；而对于=delete，可以对任何函数指定（除了析构函数，会导致无法销毁此类型的对象。对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针），除了禁止拷贝控制成员外，还可以用于引导函数匹配过程。

​	在C++11之前的做法通常是将这些函数声明为`private`函数,这样外界就不能调用这些函数了。但是这种做法对友元的支持不好。

```cpp
// struct默认是public
struct NoCopy {
    NoCopy() = default; 						
    NoCopy(const NoCopy &) = delete; 			// 删除了拷贝构造函数，阻止拷贝
    NoCopy &operator=(const NoCopy &) = delete; // no assignment，没有分配？删除了这个重载。阻止赋值
    ~NoCopy() = default; 						
// other members
};
```

```cpp
struct NoDtor {
    NoDtor() = default;
    ~NoDtor() = delete; // 
};

NoDtor nd; 					// 报错，析构函数被删除，无法创建对象
NoDtor *p = new NoDtor(); 	// 不报错
delete p; 					// 但在删除的时候会报错
```

```cpp
class PrivateCopy {
private:
    // C++11之前的做法，拷贝赋值函数仅能被内部和友元调用。友元和成员函数可以拷贝对象。
    // 为了阻止友元和成员函数进行拷贝，可以声明为private，但并不定义它们。
    // 声明但不定义一个成员函数是合法的，唯一一个例外在528页。试图访问一个未定义的成员将导致一个链接时错误。通过声明但不定义private的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。
    PrivateCopy(const PrivateCopy &);
    PrivateCopy &operator=(const PrivateCopy &);
	// other members
public:
    // 析构函数是public的，用户可以定义对象，但不能拷贝
    PrivateCopy() = default; 	// use the synthesized default constructor
    ~PrivateCopy(); 			// users can define objects of this type but not copy them
};
```

**合成的拷贝控制成员可能是删除的**

> 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的合成拷贝控制成员将被定义为删除的

​	如果一个类未定义构造函数，编译器会为其合成一个默认构造函数(参见7.1.4节，第235页)。对某些类来说，编译器将这些合成的成员定义为删除的函数:

* 如果类的某个成员的析构函数是删除的或不可访问的(例如，是private 的)，则类的合成析构函数被定义为删除的。
* 如果类的某个成员的拷贝构造函数是删除的或不可访问的,则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。否则将会创建出无法销毁的对象
* 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。因为此运算符试图赋值所有成员，而将一个新值赋予一个const对象是不可能的；而将新值赋予一个引用成员，改变的是引用指向对象的值，左侧运算对象仍然指向与赋值前一样的对象，而不是与右侧运算对象指向相同的对象，这并不是我们期望的。
* 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器(就是没有定义类内初始值)，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数,则该类的默认构造函数被定义为删除的。

## explicit

* 应用于包含一个以上参数的构造函数。只有当**明确**调用构造函数的时候才会调用它，**不会发生隐式类型转换**

* 只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复

> effective c++
>
> <img src="E:\MarkDown\picture\image-20220918215518070.png" alt="image-20220918215518070" style="zoom:67%;" />
>
> 被声明为`explicit`的构造函数通常比其 non-explicit 兄弟更受欢迎，因为它们禁止编译器执行非预期 (往往也不被期望) 的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为`explicit`. 我鼓励你遵循相同的政策.

**c++2.0之前，explicit for ctors taking one argument**

> 对于Complex(int re, int im=0):real(re), imag(im) {}这个构造函数，是none explicit one argument constructor。

如下图所示，进行c1 + 5操作时，编译器调用了构造函数让5隐式的进行了转换，将5视为了5 + 0 * i
<img src="E:\MarkDown\picture\image-20220701092547889.png" alt="image-20220701092547889" style="zoom:67%;" />

explicit明确，只有明确的调用构造函数时才会进行转换 ，因此不会发生自动转换，c1 + 5时会报错
<img src="E:\MarkDown\picture\image-20220701092759223.png" alt="image-20220701092759223" style="zoom:67%;" />

**c++2.0之后，explicit for ctors taking ==more than== one argument**

```cpp
class P {
public:
    P(int a, int b) {
        cout << "P(int a, int b) \n";
    }
    
    //P(initializer_list<int>) {
        //cout << "P(initializer_list<int>) \n";
    //}
    
    explicit P(int a, int b, int c) {
        cout << "explicit P(int a, int b, int c) \n";
    }
};

P p = {1, 2, 3};  // 这里列表初始化，又因为是非聚合类型，因此通过编译器选择了一个较为匹配的函数，即隐式的调用了P(int a, int b, int c)，但因加上了explicit，因此报错converting to 'P' from initializer list would use explicit constructor
```

### explicit构造函数只能用于直接初始化

<img src="E:\MarkDown\picture\image-20220725110333414.png" alt="image-20220725110333414" style="zoom:47%;" />

==对于列表初始化==

​	==类没有用户声明的构造函数等条件满足，类是聚合类型，因此为拷贝初始化，使用了=，因此会发生隐式转换，无法使用explicit构造函数。换句话说，无论构造函数是否explicit都会被考虑，但是如果重载决议为一个explicit函数，则此调用错误==
​	==在类有自己定义的构造函数时，通过编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数，为直接初始化，无论构造函数是否explicit，都有可能被调用==

相应知识补充：

* 直接初始化（不使用等号）时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数

* 拷贝初始化（使用等号初始化一个变量）通常使用拷贝构造函数完成。拷贝构造函数不仅在我们用等号=定义变量时调用，在下列情况下也会调用：

  (1) 根据另一个同类型的对象显式或隐式初始化一个对象；

  (2) 将一个对象作为实参传递给一个非引用类型的形参；

  (3) 从一个返回类型为非引用类型的函数返回一个对象；

  (4) **用花括号列表初始化一个数组中的元素或一个聚合类中的成员；**

  (5) 标准库容器初始化，或者调用insert或push成员时，容器会对其元素进行拷贝初始化。

* 聚合类：
  聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员，如Data val = {0, "string"};但要注意，初始值的顺序必须要与数据成员类内声明的顺序一致；若初始值列表中元素个数少于类的成员数量，靠后的成员被值初始化

1. 类型是一个普通数组，如int[5]，char[]，double[]等
2. 类型是一个类，且满足以下条件：
   * 所有成员都是public的（没有私有或保护的非静态数据成员
   * 没有定义任何构造函数
   * 没有基类，也没有虚函数
   * 没有类内初始值（非静态数据成员没有{}或=初始化器

对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值；对于非聚合类型，需要先自定义一个对应的构造函数，此时列表初始化将调用相应的构造函数。

## ==decltype==

​	decltype为类型说明符，作用是选择并返回操作数的数据类型，在此过程中，**编译器分析表达式并得到它的类型，却不实际计算表达式的值**

> 对于decltype(e)
>
> 1. 若表达式e指向一个局部变量、命名空间作用域变量、静态成员变量或函数参数，那么返回类型即为该变量（或参数）的“声明类型”；
>2. 若e是一个左值（lvalue，即“可寻址值”），则decltype(e)将返回T&，其中T为e的类型；
> 3. 若e是一个x值（xvalue），则返回值为T&&；
> 4. 若e是一个纯右值（prvalue），则返回值为T。

```cpp
decltype(f()) sum = x;  // sum的类型为f()的返回类型

const int ci = 0, &cj = ci, *p = &ci;
decltype(ci) x = 0;  // x的类型为const int，这里和auto不同，保留了顶层const
decltype(cj) y = x;  // y为const int&，即const int &y = x
int i;
// 若decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型
// 这里表达式的内容是解引用操作，解引用会得到指针所指的对象。如果表达式的结果可以作为一条赋值语句的左值，则decltype将得到引用类型
decltype(*p) c = i;  // c为int&

// 对于decltype所用的表达式，如果变量名加了一对括号，编译器会将其当作一个表达式，此时decltype的结果将会是引用
// 切记，decltype((variable))的结果永远是引用
decltype((i)) d = i;  // d是int&
```



`decltype`实现了`typeof`语法,可以推断出表达式的类型

```cpp
map<string, float> coll;

// value_type是STL容器中数据的数据类型，这里elem的类型为map容器中的一个元组
map<string, float>::value_type elem;	// C++11以前的写法
decltype(coll)::value_type elem;		// 使用decltype,就不用在程序中写死变量coll的类型了
```

`decltype`语法常用于**声明返回值类型**、**元编程**和**代指lambda函数的类型**上

***

下面程序使用`decltype`声明函数`add`的返回值类型:

```cpp
template <typename T1, typename T2>
decltype(x+y) add(Tl x, T2 y);			// error: 'x' and 'y' was not declared in this scope
```

从语法上来说,上述程序是错误的,因为变量`x`和`y`在函数外访问不到,因此需要使用C++11声明返回值类型的新语法:

```cpp
// 尾置返回类型（c++11，对于返回类型比较复杂的函数最有效）
// 在本应出现返回类型的地方放置一个auto
auto f(int) -> int(*)(int*, int);

template <typename T1, typename T2>
auto add(Tl x, T2 y) -> decltype(x+y);	
```

***

`decltype`语法进一步增强了模板语法的灵活性:

```cpp
template <typename T>
void test_decltype(T obj) {

    map<string, float>::value_type elem1; 	
	
    typedef typename decltype(obj)::iterator iType;
	typedef typename T::iterator iType;

    decltype(obj) anotherObj(obj);
}
```

***

`decltype`语法也可用于代指lambda函数的类型:

????????????????????????没看懂？？？？？？？？？？？？？？？

```cpp
// 定义lambda函数,lambda函数作为变量的变量类型较复杂,因此使用auto进行推断
auto cmp = [](const Person &p1, const Person &p2) {
    return p1.lastname() < p2.lastname() ||
           (p1.lastname() == p2.lastname() && p1.firstname() < p2.firstname());
};

// 使用decltype语法推断lambda函数cmp的类型
std::set<Person, decltype(cmp)> coll(cmp);
```



## **noexcept**

> 放在函数后，紧跟在参数列表、const、引用限定符后面，放在尾置返回类型、final、override或虚函数的=0之前

​	noexcept修饰函数，**表示这个函数不会抛出异常**。如果还是抛出了异常，程序会被终止，调用std::terminate()，std::terminate()的默认实现是调用std::abort()

优势：既然开发者确保此函数不会抛出异常，那么编译器也就没有必要为处理这个可能发生的异常添加一些事先预备好的目标代码，这在一定程度上减少了函数编译后生成的目标代码。

注意，c++11为所有类的**析构函数**都加上了**隐式的noexcept**声明

```cpp
void func()noexcept(express){}

void foo() noexcept;  // 相当于void foo() noexcept(true);
// express指定函数不抛出异常的条件，符合条件的话不会丢出异常
void foo() noexcept(true);

// x.swap(y)不丢异常，即noexcept(x.swap(y))为true的话，则函数不丢异常
void swap(Type& x, Type& y) noexcept(noexcept(x.swap(y))) {
    x.swap(y);
}
```

> 当为一个类设计移动系列函数时，如果可以，应该为其加上noexcept，以便此类在使用标准库容器时可以用移动操作来代替拷贝。
>
> 以vector为例，很多标准库容器需要特定时机的扩容操作：把元素从旧内存拷贝到新开辟的内存，再析构旧内存中的元素。
>
> 针对这种情况明显可以用移动操作来优化。
>
> 标准库的做法是：如果容器中类的移动操作函数带有noexcept声明，则使用移动操作来代替拷贝；如果没有noexcept声明，则用拷贝来完成扩容。

对于move语义：
	**必须通过noexcept通知c++（特别是std::vector），你的移动构造和析构不会抛出异常。**然后当数组增长时（如vector空间不够了，会搬到一个两倍大的空间）**，移动构造就会被调用**。如果构造函数不是noexcept，则std::vector不能使用它。

```cpp
class MyString {
private:
    char *_data;
    size_t _len;

public:
    // 移动构造函数
    // 您需要通知c++(特别是std::vector)您的move构造函数和析构函数不会抛出异常。然后，当向量增长时，move构造函数将被调用。
    MyString(MyString &&str) noexcept : _data(str._data), _len(str._len) {
        ++MCtor;
        str._len = 0;
        str._data = nullptr; 	// 将传入对象的_data指针设为nullptr而不是直接删除，防止析构函数多次delete同一根指针
    }
    
	// 移动赋值函数
    MyString &operator=(MyString &&str) noexcept {
        ++MAsgn;
        if (this != &str) {
            if (_data) delete _data;
            _len = str._len;
            _data = str._data; //MOVE!
            str._len = 0;
            str._data = nullptr; // 将传入对象的_data指针设为nullptr,防止析构函数多次delete同一根指针
        }
        return *this;
    }
};
```

## override和final

> c++11中的这两个特性能让程序在继承类和覆写虚函数时更安全、更清晰
>
> 这两者应放在`const`，`volatile`等其他关键字以及尾置返回类型后边，但是应该在纯虚标记，也就是"`=0`"的前边

**override**

​	C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个override关键字。
​	override意为覆盖、改写，应用在虚函数上，要求函数的签名(包括函数名，参数类型，参数个数和顺序，以及它所在类和命名空间。注意，const也是函数签名的一部分)必须完全相同。
​	通常是作为一个保险，常用于本意是要 override ，但写错了，导致意外创建了一个新虚函数，导致派生类的函数并没有覆盖掉基类中的版本。这时如果加上 override ，编译器就会报错来提醒我们。即**如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错**。

> ​	在C++11之前，关于子类覆写父类虚函数后，子类的虚函数还要不要加`virtual`关键字，还是个值得争论的问题。
> ​	c++11后，通常在**最顶层的虚函数上加上`virtual`关键字**，其余的子类覆写后**就不再加`virtual`了**，但是要**统一加上`override`**。

```cpp
struct Base {
    virtual void vfunc(float) { }
};
struct Derived1 : Base {
    virtual void vfunc(int) { }  // 这里写成了int，改变了函数签名
    // accidentally create a new virtual function, when one intended to override a base class function.
    // 当试图覆盖基类函数时，alias意外地创建了一个新的虚函数 
    // 这是一个常见的问题，特别是当用户修改基类时。 
};

// 通过override关键字来告诉编译器意图，这样的话要是写错了就会报错并提示
struct Derived2 : Base {
    virtual void vfunc(int) override { }
    // Error 'virtual void Derived2::vfunc(int)' marked override, but does not override
    
    virtual void vfunc(float) override { }
};
```

**final**

​	这个关键字用于修饰类或者虚函数，来阻止**类的继承**和**虚函数的重载**。用在类名后，表示这个类是继承体系下的最后一个，若还有继承，则报错；用在虚函数后，表示这个虚函数不会被重载

> 在C++11的final出现前，即使父类的虚函数是`private`的情况下，我们仍然无法阻止它的子类覆写这个方法。

```cpp
struct Base1 final { };
struct Derived1 : Base1 { };
// Error: cannot derive from 'final' base 'Base1' in derived type 'Derived1'

// 用在虚函数后，则这个虚函数不会被覆盖
struct Base2 {
    virtual void f() final;
};
struct Derived2 : Base2 {
    void f();
    // Error: overriding final function 'virtual void Base2::f()'
};
```





# 容器新特性

27.容器—结构与分类_旧与新的比较 — 关于实现手法

28.容器 array



29.容器 Hashtable



30.Hash function





31.Tuple

primer17.1

tuple是C++11新标准里的类型。它是一个类似pair类型的模板。pair类型是每个成员变量各自可以是任意类型，但是只能有俩个成员，而tuple与pair不同的是它可以有任意数量的成员。但是每个确定的tuple类型的成员数目是固定的。

tuple的实现：



![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU5saW5LQw==,size_20,color_FFFFFF,t_70,g_se,x_16.png)



# 补充

[`std::ref`](https://murphypei.github.io/blog/2019/04/cpp-std-ref)用于取某个变量的引用，常用于std::bind和std::thread等函数中显示的取引用来进行传参





## c++17

boost库中的string_algo库（已于C++17纳入了标准库，并改名为string_view

any类型

















