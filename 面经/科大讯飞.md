C++中，一种能够生成新数据类型的语言指 A封装B继承C拓展性D重载   B 



三个部分，第一部分是单选题，主要涉及数据结构、计算机网络、Linux操作、SQL这几个部分的题目。
第二部分是编程题，有三道，ACM模式，难度不是特别大，只要刷过力扣应该就能做出差不多，哪怕不能AC，ACM模式也可以拿分。我AC了两道，最后一道在前面花太多时间了，时间不够了，用七分钟写了个过了5%样例的代码提交了。



两小时

1.选择题：19道计算机基础题（数据库、操作系统、算法等），6道语言题（选择C++或者Java方向），选择题每题两分。

2.编程题，3道，都比较基础。



一道统计字符串中非0数字个数，第二道将字符串按照给定要求进行划分，第三道做数字字符串问号替换，找到能将所有问号替换完的第k小数字串。



科大讯飞 C++

看到了第六页

## C++

### 

> reference：https://blog.csdn.net/melody_1016/article/details/85125212
>
> https://www.cnblogs.com/chaoguo1234/archive/2013/05/05/3061785.html
>
> https://blog.csdn.net/qq_34168988/article/details/123763637

查看[汇编代码](https://godbolt.org/)可以发现，没有调用构造函数

![image-20230904215046901](E:\MarkDown\picture\image-20230904215046901.png)

### 堆和栈的地址

> 在Windows上不应该对栈和堆的相对位置做任何假设：比如栈的增长方向，就和x86 x64架构有关；堆栈的内存分布也是不确定的，可能堆比栈大，也可能反之
>
> 在linux下栈的地址是比堆要高的

windows下，堆的地址比栈的大：

![windows下](E:\MarkDown\picture\image-20230824204448286.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
int instack (void* ptr) {
	int test = 2;
	if (ptr < &test) {
		cout << "heap" << endl;
		return true;
	}
	cout << "stack" << endl;
	return false;
}

int main () {
	int i = 0;
	int* pStack = &i;
	int* pHeap = new int;
	cout << "pStack:" << pStack  << endl << "pHeap:" << pHeap << endl;
	return 0;
}
```



![image-20230824205602184](E:\MarkDown\picture\image-20230824205602184.png)





### string 是存在堆上还是栈上

> reference:https://zhuanlan.zhihu.com/p/186239148
>
> 源码：https://zhuanlan.zhihu.com/p/267896855
>
> 更详细的分析：https://zhuanlan.zhihu.com/p/510507837

**windows和Linux下存在区别**

* 在windows下，string创建在栈区，只有通过new string("aa")才会创建在堆区，且一开始会分配24个字节；

* 在linux下，**小型字符串优化**：string如果<=15，会分配到栈区，如果>15，会分配到堆区，比如16的时候，会给他分配17个字节来存储。这个阈值取决于编译器

  > 在 basic_string 类内部有一个指代实际缓冲区的 union，因此 string 对象构造后，内部就具有一个 16 Bytes 的小缓冲区，当字符串内容很小的时候，先使用这个 16 Bytes 的小缓冲区，当字符串内容增长的更大时，它才会在堆上重新分配新的缓冲区。因此在栈上构造的 string，当字符串尺寸小于 16 bytes 时，string.c_str() 也是位于栈上的空间。当字符串尺寸超过 16 bytes，则 c_str() 就会位于堆上了。
  >
  > ```c++
  > // _S_local_capacity = 15
  > union {
  >     _CharT _M_local_buf[_S_local_capacity + 1];
  >     /**
  >      * 内部已经分配的内存的大小，等价于前面介绍的STL中的capacity
  >      */
  >     size_type _M_allocated_capacity;
  > };
  > ```
  >
  > <img src="E:\MarkDown\picture\image-20230825103627449.png" alt="image-20230825103627449" style="zoom:50%;" />

* 如果是 new string("aa") 的话，会直接分配32个字节，不够再分配



> 在linux下才能正常调用这个

```cpp
#include <iostream>
#include <cstdlib>
#include <string>

using std::string;
using std::cout;
using std::endl;
using namespace std;
//重写string类的new操作符,添加一个可以识别malloc操作的输出
void* operator new(std::size_t n){
    cout<< "分配" << n << "字节"<<endl;
    return malloc(n);
}

void operator delete(void *p) throw(){
    free(p);
}

int main(int argc, char const *argv[])
{
    // std::string* sss = new string("aaaaabbbbbcccc");  // 32
    // string ss("HELLOaaaaabbbbbc"); // 16
    string s("HELLO"); //直接初始化
    cout<<"初始化时的状态:"<<endl;
    cout<<"sizeof:"<<sizeof(s)<<endl;
    cout<<"size:"<<s.size()<<endl;
    cout<<"分配的内存尺寸(capacity):"<<s.capacity()<<endl;

    for(size_t i=6;i<24;++i){
        s.push_back('+');
        cout<<i<<":"<<s<<endl;
    }

    cout<<"push_back('+')之后的内存尺寸是"<<endl;
    cout<<"sizeof:"<<sizeof(s)<<endl;
    cout<<"size:"<<s.size()<<endl;
    cout<<"分配的内存尺寸(capacity):"<<s.capacity()<<endl;
}
```

<img src="E:\MarkDown\picture\image-20230825094230329.png" alt="image-20230825094230329" style="zoom:80%;" />



注意，sizeof即分配的内存会比capacity少2，即比如分配的内存是24字节，但允许容纳有效的字符capacity是22个,为什么呢？

<img src="E:\MarkDown\picture\image-20230825102227509.png" alt="image-20230825102227509" style="zoom:47%;" />



> 注意对string取地址，是取变量的地址还是字符串的地址

```cpp
#include<bits/stdc++.h>
using namespace std;
void* operator new(std::size_t n){
    cout<< "分配" << n << "字节"<<endl;
    return malloc(n);
}

void operator delete(void *p) throw(){
    free(p);
}

void instack (void* ptr) {
	int test = 2;
	if (ptr > &test) {
		cout << "stack" << endl;
		return;
	}
	cout << "heap" << endl;
	return;
}

int main () {
	string str = "aaaaaa";
	printf("变量的str内存地址:%p\n",&str);
	printf("字符串对象str内存地址:%p\n",&str[0]); // 或者str.c_str()
	instack(&str[0]); // stack

    string str2 = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";  // 分配59字节
	instack(&str2[0]); // heap
	printf("变量的str2内存地址:%p\n",&str2);
	printf("字符串对象str2内存地址:%p\n",&str2[0]);
}
```



```
变量的str内存地址:0x7fff8d6cb670
字符串对象str内存地址:0x7fff8d6cb680
stack
分配59字节
heap
变量的str2内存地址:0x7fff8d6cb650
字符串对象str2内存地址:0x16082e0
```











### char*

```c++
const char * a = "abc"; // 字符串"abc"保存在常量区，const的作用是限制char指针a指向的值不可以通过a来修改，但这里本来"abc"就已经是个常量，因此是否加const没有影响。
char * b = "abc";  // "abc"是个常量，因此不可以通过指针b来改变"abc"的值。（并且可能是在运行期间报错）
const char c[] = "abc";  // 在栈上为c申请了一段空间，其中的值赋成的"abc"，但是由于const的作用，c内的值不可以变化，因此同样不可以通过c来改变"abc"的值。注意这里的原理与b不同。（有些编译器会做一些优化，将它放到常量区）

char d[] = "abc";  // 在栈上为d申请了一段空间，并且赋值"abc"，由于没有const修饰，因此d内的值可以改变。
```

### fork

* 在父进程中调用fork函数。fork函数会创建一个新的子进程，并返回两次。在父进程中，fork函数的返回值是子进程的进程ID（PID），而在**子进程中，返回值为0**。
* 在子进程中，**执行从fork函数之后开始的代码**。由于子进程是从父进程复制过来的，因此它会复制父进程中的所有数据和资源，包括代码、数据、堆栈、文件描述符等。
* 在父进程中，可以根据fork函数的返回值判断是否成功地创建了子进程。如果返回值为负数，则表示出现了错误；如果返回值为正数，则表示当前处于父进程中，在这种情况下可以使用waitpid函数等待子进程退出并获取其状态信息。
* 子进程在执行完毕后，可以通过调用exit函数来退出，并将退出状态传递给父进程。

### C++设计原则

1. 单一职责原则（SRP）：每个类或函数只负责一个功能，尽量避免一个类或函数承担过多的职责。
2. 开放封闭原则（OCP）：对修改关闭，对扩展开放。通过抽象、继承、多态等方式，设计可以方便地进行扩展而无需修改现有代码。
3. Liskov替换原则（LSP）：子类型必须能够替代其父类型。即在任何使用父类型对象的场合，都可以用子类型对象来代替。
4. 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，它们都应该依赖抽象；抽象不应该依赖具体实现，具体实现应该依赖抽象。即要依赖于抽象，不要依赖于具体。简单的说就是对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合；
   例如：要设计一个自动驾驶系统，该系统应该这一来汽车这一抽象类型，而不应该依赖于具体的某一型号的车；
5. 接口隔离原则（ISP）：客户端不应该依赖它不需要的接口。将大接口拆分成多个小接口，符合单一职责原则。不应该强迫客户依赖于他们不用的方法；尽量使用多个功能单一的接口，而不是用一个总的接口；
6. 迪米特法则（LoD）：又称最少知识原则（LKP），一个对象应该对其他对象保持最少的了解。即一个对象不应该知道太多关于其他对象的信息，仅与朋友对象通信。

### 插入元素

> vector的push_back平均时间复杂度

​	vector的push_back平均时间复杂度为常数时间[O(1)](https://blog.csdn.net/qq_44918090/article/details/120583540)。在某些极端情况下，例如vector需要重新分配内存空间时，push_back操作的时间复杂度会退化到线性时间O(n)，其中n是vector当前容量大小。

> map和unordered_map插入元素的时间复杂度分别为：

1. map：平均时间复杂度O(log n)，最坏时间复杂度O(n)。
2. unordered_map：平均时间复杂度O(1)，最坏时间复杂度O(n)。

其中，map是基于红黑树实现的，因此插入操作的时间复杂度取决于树高，而树高又受到树的平衡性影响。在大多数情况下，map的插入操作的时间复杂度可以认为是O(log n)级别的。

相比之下，unordered_map是基于哈希表实现的，插入元素的时间复杂度通常是常数时间O(1)，但最坏情况下可能会退化到线性时间O(n)，例如哈希函数不够均匀时或者哈希冲突较多时。因此，在使用unordered_map时需要注意选择适当的哈希函数以及调整桶的数量，以保证其良好的性能表现。



### 杂

> 右值能否传给引用

通过使用右值引用，我们可以将一个右值绑定到一个对应类型的引用上，从而实现对该右值的有效利用

int&& x = 5;

> C++11里多线程的内容知道哪些

1. 线程库：C++11标准库中新增了线程库（Thread Library），可以通过<thread>头文件来使用。该库提供了线程的创建、启动、等待、同步等功能，使得多线程编程变得更加方便和易用。
2. 原子类型：C++11标准库中新增了一些原子类型（Atomic Types），如std::atomic_int、std::atomic_bool、std::atomic_flag等。原子类型提供了一种线程安全的方式来进行数据读写操作，避免了数据竞争问题。
3. 同步机制：C++11标准库中新增了一些同步机制（Synchronization Primitives），如std::mutex、std::condition_variable、std::future等。这些同步机制可以用于线程之间的通信和协调，以实现复杂的多线程应用程序。



### 拷贝构造函数的递归调用

> 形参不是引用的话会发生什么？

> C++中拷贝构造函数调用时机通常有三种情况
>
> * 使用一个已经创建完毕的对象来初始化一个新对象
> * 值传递的方式给函数参数传值
> * 以值方式返回局部对象

如果拷贝构造函数的形参不是引用类型，而是按值传递参数，则会导致对象的拷贝构造函数被递归调用，直到发生栈溢出或者程序崩溃。

具体来说，当我们通过值传递方式将一个对象作为参数传递给拷贝构造函数时，会触发编译器自动生成的默认拷贝构造函数，该函数会复制源对象的所有成员变量并创建一个新的对象。但由于该函数的形参又是一个新的对象，因此在执行时会再次调用拷贝构造函数，从而形成无限递归调用的死循环。

为了避免这种情况的发生，正确的做法是将拷贝构造函数的形参定义为引用类型，例如常见的拷贝构造函数定义如下：

> 需要注意的是，拷贝构造函数中，对于指针，或者说动态分配的内存，我们一定要采用深层复制；而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向同一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了



### 整数提升

> 整数提升通常发生在以下情况下：
>
> 1. 当某个算术表达式中包含有不同精度的整型数据类型时，**编译器**会将其中**低精度的类型提升为高精度的类型**，以便进行运算。例如，在表达式a + b中，如果a是short类型而b是int类型，则编译器会将a自动提升为int类型，使得a和b具有相同的类型并能够参与相加运算。
> 2. 当调用函数时，如果**实参的类型和形参的类型不匹配**，编译器也会执行整数提升操作，以匹配函数的参数类型。例如，如果一个函数的形参为long类型而实参为int类型，则编译器会将int类型的实参自动提升为long类型，以匹配函数的形参类型。
>
> 整数提升的目的主要是为了保证程序运行时的正确性和可移植性，避免出现隐式转换导致的计算错误或者溢出问题。因此，在程序设计时需要注意控制数据类型的精度和范围，尽可能使用更高精度的整型数据类型来避免整数提升的问题。

unsigned int 和 int 比较大小，会转成什么类型

> int是有符号整型，4字节32位，表示正数时为01111..1 = 2^31 -1 = 2147483647，表示负数时为100..0，其取值范围为-2147483648至2147483647。其中，最高位为符号位，0表示正数，1表示负数。
>
> 而unsigned int是无符号整型，其取值范围为0至4294967295，没有符号位。因此，无符号整型只能表示非负数。

在比较unsigned int和int时，会发生整数提升的现象。具体来说，当两个类型不同时，C++编译器会将它们转换成相同的类型，然后再进行比较。

在本例中，由于unsigned int的取值范围大于int，因此如果将一个负数int与无符号的unsigned int进行比较，编译器会将int提升为unsigned int，从而使得比较结果正确。例如：

```
int a = -1;
unsigned int b = 1;
if (a < b) { // a会被提升为unsigned int类型
    // ...
}
```

在上述代码中，由于a被提升为无符号的unsigned int类型，其值变为4294967295，因此判断结果为true。

> **补码**：
> 正数的补码与原码相同；
> 负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1
>
> 因此，-1的补码为1000 0000 0000 0001（int是4字节32位，这里省略了）取反1 111 1111 1111 1110再加一：1 111 1111 1111 1111，以unsigned int来看就是2^32 - 1=4294967295
>
> -100就是2^32 - 100

### 文件

> 获得文件大小的方法

**方式一**

**推荐使用此方式获得文件大小！**
C/C++、Window、Linux 环境都可以使用！

通过结构体`struct stat`获得。

需要包含头文件：`#include <sys/stat.h> // struct stat`

```c++
#include<bits/stdc++.h>
#include <sys/stat.h>
using namespace std;
// 通过stat结构体 获得文件大小，单位字节
size_t getFileSize1(const char *fileName) {

	if (fileName == NULL) {
		return 0;
	}
	
	// 这是一个存储文件(夹)信息的结构体，其中有文件大小和创建时间、访问时间、修改时间等
	struct stat file;

	// 提供文件名字符串，获得文件属性结构体
	stat(fileName, &file);
	
	// 获取文件大小
	size_t filesize = file.st_size;

	return filesize;
}

int main(int argc, char const *argv[])
{
	string file = "C:\\Users\\yzew\\Desktop\\test.cpp";
    cout << getFileSize1(file.c_str()); // 1786个字节
	
}
```



### vector移动元素

怎么将一个vector的数据**转移**到另一个vector

* 使用`std::move()`显式移动每一个元素，然后再对原先的clear和shrink_to_fit

```c++
vector<int> v1{1,2,3};
cout << v1.size() << endl;
cout << v1.capacity() << endl;
vector<int> v2;
for (auto & element : v1) {
    v2.push_back(std::move(element));
}
v1.clear();
v1.shrink_to_fit();
cout << v1.size() << endl;
cout << v1.capacity() << endl;
```

* 使用assign和移动迭代器 `make_move_iterator`

```c++
// 分配新的内容至vector中，以代替现有的内容并相应的修改其size
void assign( InputIt first, InputIt last );
vec.assign(vec1.begin(), vec1.end());
vec.assign(std::make_move_iterator(vec1.begin()), std::make_move_iterator(vec1.end())); // 移动
```

> 多线程加锁有性能问题，怎么解决？

1. 减少锁的粒度：尽量将锁的作用范围缩小到最小，即减少锁住整个数据结构的情况，而是只锁住需要修改的那部分数据。
2. **thread_local**：thread_local 说明符用来修饰变量，仅可在其上创建的线程上访问。变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以与 static 或 extern 配合使用。
3. 原子操作：使用原子操作来保证某些操作的原子性，如使用C++11及以上标准提供的`std::atomic`来实现原子操作。原子操作可以确保在多线程环境下对变量的修改是线程安全的，避免了竞争条件。



### 前向声明

最主要的功能是解决循环依赖问题。

分配对象需要知道具体的内存大小，但以下形式我们不能确定类A和类B对象的大小：

```cpp
class A {
    B b;
};
class B {
    A a;
};
```

编译器无法确定其对象占用内存，便会报错停止编译。

而前置声明加指针的组合能解决循环引用问题（指针有固定大小）：

原来：

<img src="E:\MarkDown\picture\image-20230827165835423.png" alt="image-20230827165835423" style="zoom:50%;" />

改进：

![image-20230827165807088](E:\MarkDown\picture\image-20230827165807088.png)

### 编译最耗时的部分

> reference:[编译优化](https://cloud.tencent.com/developer/article/1760370)

​	如果把编译理解为预处理、编译、汇编、链接这个过程的话，我认为最耗时的部分应该是解析头文件（**预处理**器），c++编译的一个特点就是**每个编译单元，都需要独立解析所有包含的头文件**。如果N个源文件引用到了同一个头文件，则这个头文件需要解析N次，且对于`iostream`这种比较大的头文件，解析也会比较慢；=》 可以使用预编译头文件等技术来解决；或者使用前向声明：如果只需要使用一个类的指针或引用，并且不需要访问其成员函数和成员变量，则可以使用前向声明代替头文件包含。即在cpp文件中使用class OtherClass; *// 前向声明* ，在.h文件中

其次链接过程可能也比较耗时

一般而言最终的结果都是log或者一些通用宏文件最为耗时，如果不是这样的话可能需要考虑调整头文件，多用声明来减少编译时间



unity build就非常暴力了，将多个文件include到一个文件里一起编译，由于include到一起之后头文件在多个文件之间也只需要处理一次，可以将编译时间缩短7~9倍。

但是unity build的限制也不小

* 首先由于不同的文件会include 到一起，这会导致原来可以重名的全局变量报编译错误，对代码有要求
* 对objc的文件会和cpp文件混合编译，导致无法正常执行





C++内存分布

## 操作系统

### Tasks

进程（Process）、线程（Thread）和任务（Task）是操作系统中用于管理程序执行的概念，它们之间的区别如下：

1. 进程是操作系统资源分配的最小单位，表示运行中的一个程序。每个进程都有自己独立的内存空间、代码、数据区域、堆栈等。不同进程之间不能直接共享变量等资源，进程间通信需要使用特定的机制。
2. 线程是进程中的执行单元，一个进程可以包含多个线程。线程共享进程的地址空间和其他资源，如打开的文件等。因为线程之间共享了大部分资源，所以线程间通信更加轻量级和高效。
3. 任务是程序中执行的具体工作，它可以由进程中的一个或多个线程完成。任务比线程粒度更小，更便于管理和调度。在一些多任务操作系统中，任务也可以被视为是线程的一种实现方式。一般来说，每个任务都拥有自己的虚拟地址空间，但在一些特殊的多任务模型中，tasks可能会共享同一个地址空间，称为共享地址空间模型。

总的来说，进程、线程和任务是操作系统中用于管理程序执行的不同层次概念。进程是资源分配的基本单位，线程是进程中的执行单元，任务是程序中的具体工作。在多任务操作系统中，任务可以被视为是线程的一种实现方式。不同的应用场景需要选择不同的实现方式来满足需求。



### 多进程编程

```c++
pid_t fork(void);
```

​	子进程的地址空间是基于父进程的地址空间拷贝出来的，虽然是拷贝但是两个地址空间中存储的信息不可能是完全相同的

**相同点：**

拷贝完成之后（注意这个时间点），两个地址空间中的用户区数据是相同的。用户区数据主要数据包括：

代码区、全局数据区、堆区、动态库加载区（内存映射区）、栈区
环境变量、文件描述符表

**区别：**

* 父子进程各自的**虚拟地址空间**是相互独立的，不会互相干扰和影响。

* 父子进程地址空间中代码区代码虽然相同，但是父子进程**执行的代码逻辑**可能是不同的。

* 由于父子进程可能执行不同的代码逻辑，因此地址空间拷贝完成之后，全局数据区, 栈区，堆区，动态库加载区(内存映射区)数据会各自发生变化，由于地址空间是相互独立的，因此不会互相覆盖数据。

* 由于每个进程都有自己的进程ID，因此内核区存储的父子**进程ID**是不同的。

* 进程启动之后进入就绪态，运行需要争抢CPU时间片而且可能执行不同的业务逻辑，所以父子进程的**状态**可能是不同的。

* fork() 调用成功之后，会返回两个值，父子进程的**返回值**是不同的。该函数调用成功之后，从一个虚拟地址空间变成了两个虚拟地址空间，每个地址空间中都会将 fork() 的返回值记录下来，这就是为什么会得到两个返回值的原因。

  * 在父进程中调用fork函数。fork函数会创建一个新的子进程，并返回两次。在父进程中，fork函数的返回值是子进程的进程ID（PID），而在**子进程中，返回值为0**。

  * 在子进程中，**执行从fork函数之后开始的代码**。由于子进程是从父进程复制过来的，因此它会复制父进程中的所有数据和资源，包括代码、数据、堆栈、文件描述符等。

  * 在父进程中，可以根据fork函数的返回值判断是否成功地创建了子进程。如果返回值为负数，则表示出现了错误；如果返回值为正数，则表示当前处于父进程中，在这种情况下可以使用waitpid函数等待子进程退出并获取其状态信息。

  * 子进程在执行完毕后，可以通过调用exit函数来退出，并将退出状态传递给父进程。





1.计算机组成原理相关，cache组合方式，不会

2.操作系统相关，fread、fwrite的实现方式，可能是这个有些忘记了

4.linux ls怎么实现的

1. 虚拟内存，缺页中断，32位为什么内存4G
2. 单核CPU多线程为什么也需要加锁

1. top指令，里面的load含义，三个值的含义
2. gdb怎么调试运行的程序，加断点，怎么分析core文件

linux中文件描述符是啥

5、cpu和cache关于内存换入换出，有哪些算法？

进程调度策略有哪些？

Freertos进程调度策略是什么？

Linux进程调度策略是什么？

## 计网

14、TCP的释放需要哪些过程？有没有什么方式不通过四次挥手就断开连接？  

13、用过哪些套接字？tcp的标志位，udp的标志位？用过原始套接字吗？  

12、视频媒体数据用的是udp还是tcp？ARP的工作流程？  



HTTPS的加密方式
非对称加密和对称加密的优点和缺点

1. https SSL握手过程，CA证书里有啥
2. 输入url会发生什么，从缓存中查询，linux系统中ip与url对应文件放在哪，迭代查询和递归查询，为什么三次握手，四次挥手，状态码
3. 

以视频面试这个过程来谈谈用到了计算机网络的哪些协议？（面试官看我不是科班出身，还提示了OSI五层模型，从每层来回答）

7.浏览器从输入url到显示网页的过程？没答上来

* 网络分层
* 浏览器输入url到页面解析的过程（结合网络分层详细说）
* ==IP寻址过程==
* Http 头部都有啥 ==请求体是json 、表单 对应 contentType分别是啥==

Ip地址通过什么协议转换为mac地址？

有1k数据通过tcp和udp发送，分别发几次？
数据报和数据流的区别？

8、链路层、网络层、传输层的协议

9、ping使用的什么协议

bind失败会是什么原因 

  13.为啥四次挥手？（老八股） 

  14.time_wait状态，2MSL？（老八股） 

13、TCP握手为什么是3次不是2次或者其他

14、七层vs五层

* https
  * 析构函数里能抛出异常吗
* get和post区别

1、TCP连接过程中，如果服务端send发送过程中，调用close关闭，客户端可以接收到吗？  

  1、TCP连接过程中，如果服务端send发送过程中，程序被异常终止了，客户端可以接收到吗？ 

  2、TCP连接过程中，如果服务端send发送过程中，服务端宕机了，客户端可以接收到吗？  

  3、对头阻塞的概念

1. 一个主机给另一个发送消息，包在传送过程中，如果想要拒绝包的接收，怎么办？（大概好像是这样，有点记不清了）

TIME_WAIT状态的作用
 \2.    拥塞控制方法
 \3.    TCP流量控制滑动窗口

  \4.    HTTP请求报文和响应报文，状态码 

 \5.    浏览器输入URL到返回页面的流程
 \6.    TTL是什么

作者：NeoLy
链接：https://www.nowcoder.com/discuss/353156756907958272?sourceSSR=search
来源：牛客网



## 算法

   17、字符串查找方法吗？kmp你知道吗？简要的说一下原理？  



6、设计一种数据结构进行查找，假设学校有20000人，快速查到一个学生？（这次我主动让面试官提醒一下我，懵了有点其实）



讲一下动态规划和贪心，除了动态规划和贪心还有哪些算法解决最优问题？

排序算法哪些用了分治思想？

归并排序，快速排序稳定性如何，时间复杂度是多少？

双向链表可以二分查找吗？

![image-20230824162634225](E:\MarkDown\picture\image-20230824162634225.png)

![image-20230824162702497](E:\MarkDown\picture\image-20230824162702497.png)

![image-20230824162712833](E:\MarkDown\picture\image-20230824162712833.png)

## 项目

15、10万qps，这个过程中出现过time_wait或者close_wait这种信号呢？有什么编程的选项能够避免这些状态，或者不影响这些状态？  

6.十亿个url中找有没有特定的一个网址

​	

工作线程怎么工作的？while循环的终止条件？这块代码怎么写的描述一下？如果没有等到资源，会怎么样？如果任务队列一直为空工作线程怎么办？**（这里答得不好，知道的友友评论区指导我一下）**如果一直没有等到信号量，会等待多长时间？

5.在做项目的过程中有没有遇到野指针，野指针是怎么产生的；C++中怎么创建线程

一个场景题，如何设计大语言模型的后端架构，展开说。

6.讲一讲项目中线程池的实现思路

多线程的缺点？ 

为什么选择epoll 

有做过性能相关的测试？（没） 

挑一个项目介绍一下其中的亮点，最终的成果是什么样的

8、GDB怎么操作的？（简历上写了）



sql语句性能优化

MySQL事务，为什么使用事务
\10.   MySQL如何处理同一个表上的并发问题

6、InnoDB和MyISAM区别？MySQL如何做到ACID？

6.数据库相关，十亿个数据怎么存储，数据库索引