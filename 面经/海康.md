他问的项目的实施，没有细则 

秋招还是招人的

实习转正率看表现

一周出结果

实习生一般双休，加班比较赶就大小周，下班的话没有要求

有导师带一段时间，然后就参与到项目中



## 技术面



全程怼项目，一点八股都没问，问的挺详细，答的也还行。
二叉树层序遍历(力扣102)



C/C++岗的嵌入式软件开发
1.自我介绍
2.项目相关--设备异构问题
3.多线程安全
4.数据库？不知道
5.设计模式
6.学习途径





17分钟速通，就八股文加项目，我感觉被挂，他对我感觉没啥兴趣，没有手撕，应用软件开发，武汉

项目15min+手撕15min（链表相关



二叉树的结点计算？对于满二叉树，节点数量为 `2^树深度 - 1` 



static，const等等

linux进程线程

1点半到2点刚面完，20分钟
1.自我介绍
2.项目难点
3.网络相关，为什么三次握手，端口占用等
4.**c++八股**
5.pv操作，多线程等
6.两个算法题，讲思路
7.反问



同一个岗，一直问我以前的比赛经历，深挖比赛，项目一点不问，很懵逼，总共面了27分钟 

自我介绍
讲项目（本人做了webserver和一个实验室机器学习的项目）
问了问Linux，进程线程
信号量、内存管理、互斥锁等并问我有没有实际用到过，举例
闲聊了2分钟（问家是哪的之类）
共计15min



23届的 软件开发工程师（软件/嵌入式类），base杭州

1. 自我介绍
2. 项目
3. 毕设
4. 偏向于什么语言
5. **手撕快速排序**
6. 反问：最看重的专业技能（图像处理、代码的性能）

嵌入式

1、自我介绍

2、项目

3、tcp的三次握手和四次挥手



4、get和post的区别

**5、网络编程步骤**

20分钟左右

反问

根据项目自己所写的那部分代码进行提问，这种形式是我未曾碰到过的，虽然是自己写的，但是这两个月来基本没咋看，有些东西确实忘了，给人感觉不像是自己写的，所以感觉这个凉了，难受ing。



















## 行测

牛友[海康的娃](https://www.nowcoder.com/discuss/353158314110427136?sourceSSR=users)有**图形推理**真题可以看；

海康题型：文字理解11+图表分析(推算销售额、增长率、变化趋势等)11+图形推理11+性格测试100，前三部分都现时十分钟。北森的题库，难度一般，不开摄像头。

测评一共4个部分： 

  1.文字理解（考察主题、文字意思是否符合等） 

  2.图表解读（根据数据推算某个月的销售额，或变化趋势，某项的占比等） 

  3.规律查找（考察图形变化规律） 

  4.性格测试（100道题，简单易懂很好答）

  1-3这三个部分的每道题会有规定的限定时间（60s、75s）





海康笔试90min，（18个单选54分，4个多选16分，3个编程30分。

编程题题型有简答、力扣原题、sql。白板编程，不能运行

## 我考到的

选择：

**线程本地存储是线程安全的么？**
ThreadLocal 线程本地存储是一种无同步的线程安全实现方式，通过在每个线程中保存一个变量副本的方式将共享数据的可见范围限制在本线程内部，从而避免并发访问造成的线程安全问题。

**HTTP1.1 的请求方法**：GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE、CONNECT。

**不属于hash碰撞解决方法的是？**线性检测、二次探测、拉链法、多重散列都是，而单旋转法不是

**C++是类型安全的么？**不是。
就C++而言，我们可以把0作为false，非零作为true。一个函数就算是bool类型的，我们还是可以返回int类型，并且自动把0转化成false，非零转化成true。相比之下java不能把int类型转化成bool类型。所以java是一种类型安全的语言，而C++并不是。 



两个简答一个编程。

1、指针和引用区别

2、实现一个不能被继承的类，且能正常使用

* final关键字

  ```cpp
  class A final {
      // ...
  }
  ```

* 3、二分法查一个数

## 简答题

### TCP是如何保障可靠性的？

* 通过序列号与确认应答来实现可靠传输，对于数据报丢失的情况，用重传机制解决；如超时重传、快速重传
* 通过TCP报文中的校验和来校验报文是否损坏
* 通过滑动窗口来保证通信的效率
* 通过流量控制来保证发送的数据不超过接收方的接收能力，因为若接收方处理不过来，会触发重传机制，造成网络流量的浪费
* 网络是共享的，若网络出现拥堵，我们需要拥塞控制来避免发送方的数据堵塞网络，减小数据的发送

### 写出Linux系统中能够查看CPU或者内存信息的指令

**free** 显示内存使用信息；free -t 以总和的形式查询内存的使用信息；free -s 10 每10s执行一次命令，周期性的查询内存使用信息；-b -k -m分别以字节、KB、MB显示内存使用情况

**ps** 静态显示系统中的进程，ps -aux --sort -pcpu 按 `CPU` 使用降序排列；ps -aux --sort -pmem 按内存使用降序排列;

**top** 动态显示进程，进入top页面后，大写的字母`P`和`M`分别是按照CPU占用和内存占用排序显示。

### ARP协议的原理、功能、缓存表的使用，以及arp的命令

功能：在传输一个数据报的时候，确定了源IP和目标IP后，就会通过主机路由表确定IP数据包下一跳；然而网络的下一层是数据链路层，所以我们还需要知道下一跳的MAC地址；由于主机的路由表中可以找到下一跳的IP地址，所以可以通过**ARP协议**访问路由表找到下一跳的MAC地址。

原理：ARP协议就是借助ARP请求和ARP响应两种类型的包来确定MAC地址的

* 主机会通过广播发送ARP请求，这个包中包含了想要知道的MAC地址的IP地址
* 当同个链路中的所有设备收到ARP请求时，会去拆开ARP请求包中的内容，如果ARP请求包的目标IP地址和自己的IP地址一致，那么这个设备就将自己的MAC地址塞入到ARP响应包返回给主机

操作系统通常会把第一次ARP获取的MAC地址缓存起来，以便下次直接从缓存中找到对应IP地址的MAC地址

## 编程题

### 判断大小端

小端是低地址存放低字节。主机字节序是小端，数据的低位对应内存的低位；网络字节序是大端。
0x是16进制，0x12345678从左到右是高位到低位，
<img src="E:\MarkDown\picture\image-20230510141748027.png" alt="image-20230510141748027" style="zoom:25%;" />

int a = 48，对应char是'0'，16进制表示为0x00 00 00 30
或者a = 97，对应'a'，对应16进制为0x61，从左到右是高位到低位）
存起来，然后取得其地址，再将这个地址转为char* 类型。int是四字节，char是一个字节，强制转换的话会将高位截掉，a将只保留低地址。如果是小端存储，则保留的低地址内存的就是低字节，那么char*指针就指向48，对应的ASCII码为字符‘0’；

```cpp
void judge() {
	int i = 48;  // 对应char为'0'
    int* p = &i;
    char* char_i = (char*)p;
    if (*char_i == '0') printf("小端\n");
    else printf("大端\n");
}
```

### 求平均值的函数

参数是平均值的个数和要求的平均值。模仿printf的实现原理，什么avg_list 那些根据什么宏

c语言实现：
利用可变参数列表即可，可变参数列表是通过宏来实现的，这些宏定义在stdarg.h中。注意的是可变参数列表传参时，第一个传的参数的个数。

1.定义一个va_list类型的变量 arg

2.宏va_start(arg,num)---这个宏有两个参数，第一个参数为va_list类型的变量，第二个参数为可变参数列表之前的参数。

作用就是使得 va_list 的变量指向可变参数列表的首地址。这才是一般意义上的对 va_list的初始化。

3.宏va_arg(arg,int) ---第一个参数为va_list类型的变量第二个为参数的类型。

4.宏va_end（arg）---结束标志

```cpp
#include<stdio.h>
#include<stdlib.h>
#include <stdarg.h> 
int average(int num, ...)//第一个参数传的是参数的个数，后面三个点代表可变参数列表
{
	int sum = 0;
	va_list arg;  // 定义一个va_list类型的变量
	va_start(arg, num);  // 宏 va_start
	for (int i = 0; i < num; i++) {
		sum += va_arg(arg, int);  //宏 va_arg
	}
	va_end(arg); //宏 va_end
	return sum / num;
}

int main()   {
	int aver = average(10, 1,2, 3, 4, 5, 6, 7, 8, 9,10); //第一参数为个数
	printf("%d\n", aver);
	system("pause");
	return 0;
}

// 浮点数
double average(int num, ...)//第一个参数传的是参数的个数，后面三个点代表可变参数列表
{
	double sum = 0;
	va_list arg;  // 定义一个va_list类型的变量
	va_start(arg, num);  // 宏 va_start
	for (int i = 0; i < num; i++) {
		sum += va_arg(arg, double);  //宏 va_arg
	}
	va_end(arg); //宏 va_end
	return sum / num;
}

int main()   {
	double aver = average(3, 3.0, 4.0, 3.0); //第一参数为个数
	printf("%lf\n", aver);
	return 0;
}
```

c++实现

```cpp
#include <iostream>
#include <string>
using namespace std;

double aa() {
	return 0;
}

template<typename T, typename... Args> 
double aa(T val, Args... args) {
	double size = sizeof...(args);
	// if (size == 0) return val;
	return (aa(args...) * size + val) / (size + 1);
}
int main() {
	cout << aa(3, 4, 7);
	return 0;
}
```

注意，这里的if判断是错误的，因为函数模板并不能调用，函数模板需要在编译时根据传入的实参类型进行推演，生成对应的函数，这个生成的函数才能够被调用。
而这个推演过程是在编译时进行的，当推演到参数包args中参数个数为0时，还需要将当前函数推演完毕，这时就会继续推演传入0个参数时的ShowList函数，此时就会产生报错，因为ShowList函数要求至少传入一个参数。
这里编写的if判断是在代码编译结束后，运行代码时才会所走的逻辑，也就是运行时逻辑，而函数模板的推演是一个编译时逻辑。

### 素数

```cpp
bool aa(int target) {
	if (target <= 1) return false;
	// 或i <= (int)sqrt(target)
	for (int i = 2; i <= target / 2; i++) {
		if (target % i == 0) return false;
	}
	return true;
}
```

### 标准宏求最大值

```cpp
#include <bits/stdc++.h>
using namespace std;

// c++和c一样，也允许有参宏定义
// #define  宏名(形参表)  字符串
// max_1不支持输入i++这种类型
#define max_1(a,b) (((a)>(b))?(a):(b))
#define max_2(a,b) ({\
						decltype(a) x=(a);\
						decltype(b) y=(b);\
						(x>y) ? x : y;\
						})

int main() {
    int i = 5;
	char j = 3;
	
	printf("before max_1 i=%d,j=%d\n",i,j);  // 5 3
	printf("max of i and j is:%d\n",max_1(i++,j++));  // 6
	printf("after max_1,i=%d,j=%d\n",i,j);  // 7 4
 
	printf("\nbefore max_2 i=%d,j=%d\n",i,j);  // 7 4
	printf("max of i and j is:%d\n",max_2(i++,j++));  // 7
	printf("after max_2,i=%d,j=%d\n",i,j);	// 8 5

    return 0;
}
```



## 力扣

### 求1的个数

 [191. 位1的个数](https://leetcode.cn/problems/number-of-1-bits/)

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            if (n & (1 << i)) {
                count++;
            }
        }
        return count;
    }
};
```

###  反转字符串中的单词

[151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/) 

istringstream aa(s); while (aa >> tmp) { st.push(tmp); }

### 快排

```cpp
#include <bits/stdc++.h>
using namespace std;

// 三路快排
void aa(vector<int>& nums, int left, int right) {
	if (left >= right) return;
	swap(nums[right], nums[rand() % (right - left + 1) + left]);
	int pivot = nums[right];
	int lt = left - 1, rt = right, cur = left;
	while (cur < rt) {
		if (nums[cur] > pivot) {
			swap(nums[cur], nums[rt - 1]);
			rt--;
		} else if (nums[cur] < pivot) {
			swap(nums[cur], nums[lt + 1]);
			lt++; cur++;
		} else cur++;
	}
	swap(nums[rt], nums[right]);
	aa(nums, left, lt);
	aa(nums, rt + 1, right);
	
}
vector<int> sortArray(vector<int>& nums) {
    aa(nums, 0, nums.size() - 1);
    return nums;
}
```

### 冒泡

```cpp
```

### 二叉树

以数组输入形式

```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// 根据数组构造二叉树
TreeNode* construct_binary_tree(const vector<int>& vec) {
    vector<TreeNode*> vecTree(vec.size(), NULL);
    TreeNode* root = NULL;
    for (int i = 0; i < vec.size(); i++) {
        TreeNode* node = NULL;
        if (vec[i] != -1) node = new TreeNode(vec[i]); // 用 -1 表示null
        vecTree[i] = node;
        if (i == 0) root = node;
    }
    for (int i = 0; i * 2 + 1 < vec.size(); i++) {
        if (vecTree[i] != NULL) {
            vecTree[i]->left = vecTree[i * 2 + 1];
            if(i * 2 + 2 < vec.size()) vecTree[i]->right = vecTree[i * 2 + 2];
        }
    }
    return root;
}

```

层序遍历求前序遍历

就是输入数组是层序遍历的形式

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    deque<TreeNode*> que;
    vector<vector<int>> result;
    if (root) que.push_back(root);
    while (!que.empty()) {
        int size = que.size();
        vector<int> tmp;
        for (int i = 0; i < size; i++) {
            TreeNode* node = que.front(); que.pop_front();
            tmp.push_back(node->val);
            if (node->left) que.push_back(node->left);
            if (node->right) que.push_back(node->right);
        }
        result.push_back(tmp);
    }
    return result;
}
```



### 字符串去重

保留第一次出现的字母

输入abacd，输出abcd

```cpp
string aa(const string& s) {
	string result = "";
	unordered_set<char> sett;
	for (auto i : s) {
		if (sett.find(i) == sett.end()) result += i;
		sett.insert(i);
	}
	return result;
}
```

## 设计模式

### 单例模式

```cpp
// 单例模式，饿汉模式
class TaskQueue {
public:
    // =delete 代表函数禁用, 也可以将其访问权限设置为私有
    TaskQueue(const TaskQueue& obj) = delete;
    TaskQueue& operator=(const TaskQueue& obj) = delete;
    static TaskQueue* getInstance() {
        return m_taskQ;
    }
private:
    TaskQueue() = default;
    static TaskQueue* m_taskQ;
};
// 创建单例对象
TaskQueue* TaskQueue::m_taskQ = new TaskQueue;

int main() {
    // 当使用者通过 getInstance() 获取这个单例对象的时候，它已经被准备好了
    TaskQueue* obj = TaskQueue::getInstance();
}
```

### 工厂模式

```cpp
// 工厂模式
#include <bits/stdc++.h>
using namespace std;

// 产品基类
class Base {
public:
    virtual void operate() {}
    virtual ~Base() {}
};
// 产品子类A
class A : public Base
{
public:
    void operate() override {
        cout << "子类A" << endl;
    }
};

// 产品子类B
class B : public Base {
public:
    void operate() override {
        cout << "子类B" << endl;
    }
};

// 工厂类
enum class Type:char{A, B};
class Factory {
public:
    Factory() {}
    ~Factory() {}
    Base* create(Type type) {
        Base* ptr = nullptr;
        switch (type) {
        case Type::A:
            ptr = new A;
            break;
        case Type::B:
            ptr = new B;
            break;
        default:
            break;
        }
        return ptr;
    }
};

int main() {
    Factory* factory = new Factory;
    Base* obj = factory->create(Type::B);
    obj->operate();
    return 0;
}
```

### 外观模式



### 观察者模式



## SQL

一个学生表，查每门课都大于80分的学生

<img src="E:\MarkDown\picture\image-20230510212333624.png" alt="image-20230510212333624" style="zoom:50%;" />

```sql
select name
from (SELECT name, min(score)
      FROM student
      GROUP BY name
      HAVING min(score) > 80) stu
      
select name
FROM student
where id in (SELECT name, min(score)
             FROM student
             GROUP BY name
             HAVING min(score) > 80)
```

查询选课为软件工程的学生信息

```sql
SELECT stu_name
FROM student
GROUP BY stu_name
HAVING course = ruanjia
```

查询选课数大于3的学生信息

```sql
select stu_name
from (SELECT stu_name, COUNT(course)
	FROM student
	GROUP BY stu_name
	HAVING COUNT(course) > 3) stu
```

三表查询

现有 A\B\C 三张表，现在要查询并展示A表和C表中的某些字段，但是A、C两表没有相同字段，无法关联，此时有B表恰好有两个字段，一个字段和A表一个字段相同，一个字段和C表一个字段相同，我们称B表为“中间表”，因此通过B表把A、C表关联起来

```sql
SELECT  A1,A2,C1,C2      --展示A表中的A1\A2字段和C表中的C1\C2
FROM  B                         --中间表
INNER JOIN A ON A.A1 = B.B1   --A表中的与B表中相同的字段
INNER JOIN C ON C.C1 = B.B1    --C表中的与B表中相同的字段
where    xxxxx     ---条件你自己按照需求来加，没有条件就不写where了
```



