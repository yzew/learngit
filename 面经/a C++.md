> 每月会有个周六加班
>
> 124最晚八点多
>
> 听说加班？9 8.5 5.25，一年8个月995，月末周六加班，加班费只有一倍的工资，月末周六不算加班费。年终奖平均2薪。加班费每个月可能一两千
>
> 基础薪资12k，公积金缴纳基数

# C++

## 性能优化

### 容器

#### 避免动态内存分配

使用vector.reserve()进行初始化

#### 强行在栈上分配

> c++17 多态内存资源(PMR):https://zhuanlan.zhihu.com/p/527327054
>
> unsynchronized_pool_resource：创建从不释放、可以传递一个可选的缓冲区、线程不安全的类（需要手动释放）



比如在vector中不断放入string，会发生很多次内存分配，既有vector的扩容，也有string在堆空间的分配，完全在堆上分配内存可能会导致性能问题。

容器一般默认在堆，可使用std::pmr::monotic_buffer_resource

```c++
// 在栈上分配一些内存：
std::array<std::byte, 200000> buf;

// 将它用作vector和strings的初始内存池：
std::pmr::monotonic_buffer_resource pool{buf.data(), buf.size()};
std::pmr::vector<std::pmr::string> coll{&pool};
```

​	如果分配的200,000字节不够用，vector将会继续在堆上分配更多的内存。 这是因为`monotonic_memory_resource`使用了默认的分配器， 它会把使用`new`分配内存作为备选项。

​	注意，当缓冲区没有足够的内存时还会在堆上分配新的内存。 

#### map遍历

使用auto&代替std::pair，后者可能会产生隐式拷贝

#### map添加/修改

使用operator[]在key不存在时会调用两次构造函数：key会隐式调用一次，然后不存在，又在新位置构造了移过去

解决：先判断是否存在，再做插入

#### map构造

std::piecewise_construct，只构造一次，没有多的移动和拷贝构造函数

#### 迭代器

使用++iter

#### 容器查找

优先用成员函数find，而不是std::find

#### 容器拷贝赋值

标准库都是值语义，改为使用移动语义



### IO相关

#### 输入输出

> libfmt代替原生printf

* `libfmt` 是现代 C++ 中的一个库，用于格式化字符串和输出。它是 C++11 及更高版本的标准库的一部分，提供了类型安全和高度灵活的格式化功能。

* `libfmt` 使用了类似于 Python 的字符串格式化语法，允许你在字符串中插入变量值，同时提供了类型安全的格式化选项。例如：

  ```c++
  int value = 42;
  std::string text = fmt::format("The answer is {}.", value);
  fmt::print("{}\n", text); // 输出格式化后的字符串
  ```

* `libfmt` 支持各种类型的格式化，包括整数、浮点数、字符串、自定义类型等。它还支持格式化控制，如对齐、精度、填充字符等。例如，可以使用 `{:.2f}` 来格式化浮点数到小数点后两位，或者使用 `{:<10}` 来左对齐一个字符串，并确保它占用至少 10 个字符的宽度。

* `libfmt` 的性能通常比 `printf` 更好，因为它使用了现代 C++ 的特性，如类型推导和模板元编程，来优化字符串格式化。



### 类与对象

#### 移动构造函数

要定义为noexcept性能优化，`noexcept` 声明告诉编译器，该移动构造函数不会抛出异常。这允许编译器在某些情况下进行更多的优化，尤其是在使用标准容器或使用异常处理机制的代码中。

#### 类的成员

用初始化列表构造能减少构造函数调用：
	可以直接初始化成员变量，而不是先使用默认构造函数初始化，然后再赋值。这种直接初始化方式通常更高效，因为它避免了额外的构造和赋值操作。

#### 变量定义

使用前再定义，防止过早自动调用构造函数

#### 智能指针

可使用unique_ptr代替裸指针，勿滥用shared_ptr，会影响影响，引用计数器是原子操作

用make_shared代替new创建shared_ptr

#### 默认函数

手动删除不需要的构造函数、析构函数、隐式构造转换，运算符重载





### 编译优化

#### 内联函数

3行左右，写在头文件，lambda自动内联

#### 复制省略

​	RVO（Return Value Optimization）和NRVO（Named Return Value Optimization）是C++中的优化技术，用于避免不必要的对象拷贝构造或移动构造，从而提高程序的性能。这些优化是编译器自动执行的，无需程序员显式干预。

​	RVO和NRVO的主要思想是，当函数返回一个局部对象时，编译器可以直接在函数的栈帧中构造该对象的副本，而不是创建一个新的临时对象，然后再进行拷贝或移动操作。这样可以避免不必要的对象复制和销毁。

#### 短字符串优化SSO

短字符串直接保存在栈上

#### 编译等级

编译等级需要设置为O2以上



### 其他

#### auto无引用

auto不会自动推导引用&

#### 字符串

字符串不用+用+=，比如s1+=s2，而不是s1 = s1+s2

循环体外创建string，内部用clear代替直接创建string

const char* 转string，比如"SevenX"是一个const char* ，如果函数形参是string就会调用隐式转换





## 指针

### 描述一下指针

* 指针的声明形式为数据类型* 变量名，这里p存储了一个地址，指向任意的数据类型。为p赋值需要取地址，获得结果需要解引用
* 指针在使用前必须先初始化，否则会指向位置的地址

### 常量指针与指针常量

常量指针，即`int* const p`，地址不可修改。这里的常量指a，这里a是指针，即不可以改变指针的指向（存放在指针中的地址不可变），但可以用 *a改变所指对象的值。引用的本质在c++内部实现是一个常量指针，this指针的本质是一个常量指针

指针常量，const int* p / int const *a

这里的常量指 *a，即不能用 *a改变所指对象的值 ，但可以a=&b来改变指针的指向

#### this指针

> **this指针的本质是一个常量指针，Person* const this，指针的指向不可修改**

​	在C++中成员变量和成员函数是分开存储的，每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。而这一块代码是如何区分哪个对象调用自己的呢？

​	C++ 通过提供特殊的对象指针，this 指针，解决上述问题。**this 指针指向被调用的成员函数所属的对象**。this 指针是隐含每一个非静态成员函数内的一种指针，并且不需要定义，直接使用即可。

this指针的用途：

*  当形参和成员变量同名时，可用this指针来区分
*  **在类的非静态成员函数中返回对象本身，可使用return *this**(this为一个指向p1(即一个对象)的指针，*this解引用得到p1这个对象) ，可以实现链式编程



#### 引用

> 引用的本质在c++内部实现是一个常量指针

即int* const p。这也就解释了为什么引用一旦初始化后，就不可以更改，即c指向a后，不能更改成指向别的，因为常量指针是指针指向不可改，但指向的值可以修改。

所有的指针操作编译器都帮我们做了

```cpp
//发现是引用，转换为 int* const ref = &a;
void func(int& ref){
	ref = 100; // ref是引用，转换为*ref = 100
}
int main(){
	int a = 10;
    
    //自动转换为 int* const ref = &a; 常量指针是指针指向不可改，也说明为什么引用不可更改
	int& ref = a; 
	ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;
    
	cout << "a:" << a << endl;
	cout << "ref:" << ref << endl;
    
	func(a);
	return 0;
}
```



### 野指针

野指针是指向未知或无效内存地址的指针。

* 指针未初始化，会包含一个随机的值，可能是一个无效的内存地址

* 指针被释放，比如指针指向的对象析构后没有赋空值

* 指针越界，比如一个指针变量指向的内存地址超出了它所指向的内存块的范围，如访问一个数组元素之外的内存或访问一个已释放的内存块

  

### 引用和指针

> 区别？引用有哪些使用**场景**？
>
> int& b = a;

* 引用是变量的一个别名，本身不是一种数据类型，因此引用本身不占用内存空间；而指针是通过一个指针变量指向变量的地址，需要占用内存空间，四字节或八字节
* 作为函数形参，引用只需要在被调函数中使用"&"操作符，引用的实参和形参是同一地址，对引用的操作与对变量直接操作效果完全相同；而指针在主调函数中需要使用"&"取地址操作符传递参数，在被调函数中需要使用"*"操作符来解引用
* 引用一旦声明就必须同时对其进行初始化，使其指向一个已经存在的对象；而指针可以指向为空；
* 引用初始化后就不能再指向其他对象；而指针则可以被重新赋值以指向其他变量
* 指针可以有多级，引用只有一级
* sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小 
* 场景：
  * 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
  * 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式  


> 如何初始化一个指针数组？

指针数组是指数组中的每一个元素都存放一个地址；由于指针数组中的每个元素都是一个指针，所以将指针数组初始化也就是将指针数组中的每个元素都初始化，即每个元素都指向一个地址即可；如：

```C++
int *p[4];
int a = 1, b = 2, c = 3;
int *p[3] = {&a, &b, &c};		// 使用变量来初始化指针数组，即数组中的每个元素存放的是变量的地址
```



### 智能指针

**介绍智能指针**

> ​	智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针可以自动释放所指向的对象，避免内存泄漏等问题
>
> > 注意，std::auto_ptr，deprecated in C++11，removed in C++17

* auto_ptr有很多问题：

  * 不支持复制 (拷贝构造函数) 和赋值 (=)，但复制和赋值的时候不会提示出错。
  * **可能导致对同一块堆空间进行多次delete**。 当两个智能指针都指向同一个堆空间时，每个智能指针都会delete一下这个堆空间，这会导致未定义行为；
  * auto_ptr采用**copy语义来转移指针资源**，**转移指针资源的所有权的同时将原指针置为NULL**，这跟通常理解的copy行为是不一致的(正常的copy不会修改原数据)，而这样的行为在有些场合下不是我们希望看到的。**unique_ptr禁用了copy，而用move替代**

* **shared_ptr**允许多个指针指向同一个对象，内部使用了引用计数法，即每个shared_ptr都有一个关联的计数器，称为引用计数。拷贝shared_ptr时计数器就会递增；给shared_ptr赋新值或shared_ptr被销毁时，析构函数就会递减所指向对象的引用计数。引用计数变为0时，析构函数就会销毁对象，并释放它占用的内存。使用use_count()成员函数可以显示引用计数的值

  * 在submitTask提交任务的时候，我们通过make_shared创建的packaged_task包装的任务对象，将任务对象用lambda表达式包装为函数对象后放到deque中

    * 在容器析构的时候，容器中的对象或指针会被析构，但指针指向的对象不会被析构，需要手动释放，此时通过智能指针即可自动释放。

    * 对于task，一开始存在deque中，而我们使用的时候又需要queue.front()取出来，因此用shared_ptr就可以使得可以多个指针指向这个对象，都销毁的时候才销毁

    * 延长任务对象的生命周期，因为我们在向线程池提交任务后，需要线程来执行任务，我们必须保证这个任务在被执行前是一直存在的

* **unique_ptr**独占所指向的对象，同一时刻只能有一个 unique_ptr 指向给定对象(禁止通过拷贝语义)；不支持拷贝和赋值，但比 auot_ptr 好，直接赋值编译器会报错，可以使用 std::move 来转移所有权；unique_ptr的生命周期从创建开始，离开作用域后自动销毁

  * 线程池项目中构建了一个Thread类，每个线程对象的创建和销毁比较麻烦，这里就用了unique_ptr。
  * 我们的线程类对象是用unordered_map来存的，线程id对应着一个unique_ptr对象。通过make_unique创建线程类对象，然后将创建的unique_ptr用std::move变为右值引用，存到unordered_map中（因为unique_ptr支持右值引用的拷贝和赋值，仅是转移所有权）
  * 比如在cached模式下销毁多余的线程，或fixed模式下线程池对象析构，需要销毁线程对象，仅需要通过map.erase(id)，即可通过unique_ptr将线程类自动销毁。

  ```cpp
  std::unique_ptr<int> p1(new int(5));
  std::unique_ptr<int> p2 = p1;  // 编译会出错，因为unique_ptr不支持拷贝赋值
  std::unique_ptr<int> p3 = std::move(p1);  // 转移所有权，现在那块内存归p3所有，p1成为了无效的指针；std::move(p1)将左值p1转换为右值
  ```

* **weak_ptr**是一种不控制所指向对象生存期的智能指针，指向由一个shared_ptr管理的对象，但不会增加引用计数，也不影响其释放。当所指对象被销毁时，会自动变成空指针。

  因为 weak_ptr 不保证它指向的内存一定是有效的，在使用之前需要检查 weak_ptr 是否为空指针；

  这个weak_ptr存在的意义，就是他不影响一个给定的shared_ptr管理的对象的生命周期，但可以用来阻止用户访问一个不存在的对象。比方说在一个函数里面处理一个对象的时候，若这个对象在函数外部有被销毁的可能，那么直接引用这个对象就是不安全的。所以，在进入函数的时候，生成一个将要处理对象的伴随类，每次需要操作对象的时候，用lock()方法检查weak_ptr指向的对象是否存在，程序就更安全了。

  ```cpp
  auto p = make_shared<int>(42);
  weak_ptr<int> wp(p);
  if (shared_ptr<int> np = wp.lock()) {
  }
  ```

  

**作用：**

* 自动释放内存，避免了手动的释放内存，避免内存泄漏
* 可以用智能指针确保在异常发生后资源能被正确的释放。因为如果是普通指针，在delete前抛出异常，则内存将永远不会释放。
* 避免空悬指针，会在指向的对象被销毁后自动将指针置为NULL
* 像是shared_ptr，可以延长对象的生命周期，因为只要有一个shared_ptr指向这个对象，这个对象就不会被销毁，像是在我的线程池项目中的任务对象，在创建后就通过shared_ptr延长生命周期，因为我们在向线程池提交任务后，需要线程来执行任务，我们必须保证这个任务在被执行前是一直存在的

**注意事项：**

* shared_ptr不是线程安全的，读安全写不安全。其引用计数是原子的，是线程安全的。但shared_ptr管理的资源可以被多个shared_ptr访问，是临界资源，有线程安全问题。因此**当我们多个线程访问同一个 shared_ptr 时，应该要进行加锁操作**
* 可以使用atomic<shared_ptr<T>>和atomic<unique_ptr<T>>来保证线程安全
* shared_ptr是16字节 = 8字节（指向对象的指针）+ 8字节（指向计数的指针），如果定义了删除器的话，还会多 8字节
* unique_ptr同理，为8字节或16字节

**make_shared**

此函数是一个模板函数，在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。

与new的区别：

shared_ptr对象指向两个内存位置：1.指向对象的指针；2.用户控制引用计数的指针

* 使用new创建 shared_ptr 对象，在堆上创建了两块内存：存储对象的内存和用于引用计数的内存

  带有参数的shared_ptr构造函数是explicit类型（也就是只支持显示构造）

  ```C++
  std::shared_ptr<int> p1 = new int(10);		//错误：只支持显示构造
  std::shared_ptr<int> p1(new int(10));		//正确
  ```

* 使用 make_shared 创建空的 shared_ptr 对象，一次性为 int 对象和用于引用计数的数据都分配了内存，而 new 操作符只是为 int 分配了内存  (为引用计数的数据分配内存不太准确，应该是为控制块分配内存)

  ```C++
  std::shared_ptr<int> ptr = std::make_shared<int> (2);
  ```

所以使用 new 初始化 shared_ptr 会两次申请内存，使用 std::make_shared 只会申请一次

### 手撕shared_ptr

首先要有一个引用计数。每次创建类的新对象时，初始化指针并将引用计数置为1；
当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；
对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；
调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则自动删除所指向的堆内存）。

```cpp
template<class T>
class share_ptr
{
private:
	int* count;
	T* ptr;
	void remove()
	{
		--(*count);
		if (*count == 0)
		{
			delete count;
			delete ptr;
			count = nullptr;
			ptr = nullptr;
		}
	}
public:
	share_ptr() :count(new int(0)), ptr(nullptr) {};
	share_ptr(T* _ptr) :count(new int(1)), ptr(_ptr) {};
	share_ptr(const share_ptr<T>& other)
	{
		count = other.count;
		ptr = other.ptr;
		++(*count);
	}
	share_ptr& operator=(const share_ptr<T>& other)
	{
		if (ptr == other.ptr) return *this;
		if (ptr > 0)
		{
			remove();
		}
		ptr = other.ptr;
		count = other.count;
		++(*count);
		return *this;
	}
	~share_ptr() {
		remove();
	}
	T* operator->()
	{
		return ptr;
	}
	T& operator*()
	{
		return *ptr;
	}
	int getCount()
	{
		return *count;
	}
	
};
int main()
{
	share_ptr<int>sp(new int(1));
	cout << "sp:" << sp.getCount() << " " << *sp << endl;
	cout << "------------------------------------" << endl;
	share_ptr<int>sp2(sp);
	cout << "sp:" << sp.getCount() << " " << *sp << endl;
	cout << "sp2:" << sp2.getCount() << " " << *sp2 << endl;
	cout << "------------------------------------" << endl;
	for (int i = 0; i < 1; i++)
	{
		share_ptr<int>sp3 = sp2;
		cout << "sp:" << sp.getCount() << " " << *sp << endl;
	    cout << "sp2:" << sp2.getCount() << " " << *sp2 << endl;
	    cout << "sp3:" << sp3.getCount() << " " << *sp3 << endl;
	}
	cout << "------------------------------------" << endl;
	cout << "sp:" << sp.getCount() << " " << *sp << endl;
	cout << "sp2:" << sp2.getCount() << " " << *sp2 << endl;
}

```





### 智能指针的内存泄漏

> shared_ptr环形引用：互相引用形成环，这样两个指针指向的内存都无法释放；需要手动打破循环或者使用weak_ptr。

​	如果有一个类A和类B，其数据成员是一个shared_ptr指向彼此。那么此时类A和类B的引用计数ref为1。如果此时又有两个智能指针分别指向A和B，那么此时类A和类B的引用计数为2，当这两个智能指针离开其作用域的时候ref减为1，但并不会释放智能指针所指向的对象。会造成内存泄漏。

解决方案：在类中相互指向的话用weak_ptr

### unique_ptr底层原理

**unique_ptr**独占所指向的对象，同一时刻只能有一个 unique_ptr 指向给定对象(禁止通过拷贝语义)；不支持拷贝和赋值，但可以使用 std::move 来转移所有权；unique_ptr的生命周期从创建开始，离开作用域后自动销毁

* 构造时传入托管对象的指针，析构时delete对象

* 禁用拷贝构造函数和拷贝赋值运算符

  ```cpp
  unique_ptr(const unique_ptr<T>&) noexcept = delete;
  unique_ptr& operator = (const unique_ptr&) noexcept = delete;
  ```

* 定义好移动构造函数

### 指针和迭代器

> 已经有指针，为什么要用迭代器

​	泛型算法并不是单独的为某一种容器去设计的，而是**可以供多种不同的容器去使用的算法**。为了满足这个需求，对于算法来说，就需要屏蔽掉容器的实现方法，但是却可以按照同一种顺序去访问大多数的容器，这就是**迭代器**的作用

迭代器是每一个容器都需要定义的一个class，它最起码具有以下特征：

* 具有一个指向容器空间的指针成员
* 重载了\*和->操作符，使这个class可以像指针一样去访问自己的指针成员
* 重载了++操作符，通过++可以遍历整个容器
* 定义了自己的五个标准型别



使用迭代器可以让代码更加通用和可重用

迭代器重载的这些操作符可以让代码更简洁易读

迭代器可以实现一些保护机制，比如检查访问越界和空指针等，更安全

> 指向double数组的指针
>
> double arr[];
> double *p = arr;
> *(p+1)指向数组第二个元素

### 指针的维护和使用

* 内存泄漏
* 悬空指针：若指针指向的内存已经被释放，但指针没有被置为NULL，则会变为悬空指针。使用悬空指针会导致程序崩溃或出现未知行为
* 内存越界：若指针指向的内存区域超出了其所在内存块的范围，就会导致内存越界，会导致程序崩溃或出现未知行为
* 多线程安全

### 类中的引用

* 必须要在构造函数中初始化引用，否则会出现编译错误
* 必须在成员初始化列表中进行，因为引用在定义时必须初始化，且不能重新赋值

```c++
class A {
    A(int& ref) : a(ref) {}
    int& a;
};
```





## 多态相关

### OOP和泛型编程

面向对象编程OOP和泛型编程都能处理在编写程序时不知道类型的情况。区别在于：

* OOP能处理类型在程序运行之前都未知的情况；
* 泛型编程（通过模板实现）在编译时就能获知类型。

### 面向对象的三大特性

**答：**封装（隐藏），继承，多态

基于三个基本概念：数据抽象、继承和动态绑定

**封装**（隐藏）：把属性和行为封装成抽象的类，并将属性和行为加以权限控制。隐藏实现细节，只暴露必要的接口，可以提高代码的可维护性和可重用性以及安全性，保护数据



* 将公共的数据和方法使用public修饰，这是类为外界提供的接口；
* protected类内可以访问，类外不可以访问，继承的话子类可以访问。用于给派生类使用的数据可以声明为protected
* private 类内可以访问，类外不可以访问，继承的子类不可以访问。不希望外界访问的数据和方法用 private 修饰，通常将成员的属性设置为私有



**继承**：目的是减少重复代码。可以让某种类型的对象获得另一个类对象的属性和方法。派生类的成员包括基类继承来的成员和派生类自己的成员

* 普通继承
* 虚继承(`class A : virtual public B`)，主要用于解决多重继承中的"菱形继承"问题，在虚继承中，派生类只继承了基类的一个实例，即虚基类，这样可以避免多个派生类继承一个基类时出现的重复继承问题。



**多态**：多态是一种面向对象编程的概念，指的是同一个函数名称可以有不同的实现方式。具体来说，多态允许同一个类的不同实例对同一个消息作出不同的响应。这样做的好处是可以提高代码的重用性和灵活性，同时也能够更加方便地进行代码维护和扩展。

* 静态多态: 函数重载（编译器根据函数参数列表来选择调用哪个函数）、运算符重载、模板（模板在编译期间生成代码）
* 动态多态: 派生类和虚函数实现运行时多态

静态多态和动态多态区别：

* 静态多态的函数地址早绑定  ——  编译阶段确定函数地址
* 动态多态的函数地址晚绑定  ——  运行阶段确定函数地址

​	我们**把具有继承关系的多个类型称为多态类型**，当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。

​	多态性是通过虚函数实现的，虚函数是在基类中声明的函数，可以被派生类重写，并在运行时通过对象的实际类型调用相应的函数。



### 多态

​	多态是一种面向对象编程的概念，指的是同一个函数名称可以有不同的实现方式。具体来说，多态允许同一个类的不同实例对同一个消息作出不同的响应。这样做的好处是可以提高代码的重用性和灵活性，同时也能够更加方便地进行代码维护和扩展。

* 静态多态: 函数重载（编译器根据函数参数列表来选择调用哪个函数）、运算符重载、模板（模板在编译期间生成代码）
* 动态多态: 派生类和虚函数实现运行时多态

静态多态和动态多态区别：

* 静态多态的函数地址早绑定  -  编译阶段确定函数地址
* 动态多态的函数地址晚绑定  -  运行阶段确定函数地址

​	我们**把具有继承关系的多个类型称为多态类型**，当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。

​	多态性是通过虚函数实现的，虚函数是在基类中声明的函数，可以被派生类重写，并在运行时通过对象的实际类型调用相应的函数。

### 虚函数

> 三个类A、B、C，C继承B，B继承A，A中有一个虚函数，三个类对象的虚表和成员变量在内存中的分布。
>
> A：虚表指针、A自己的成员变量
>
> B：虚表指针、A的成员变量、B自己的成员变量
>
> C：虚表指针、A的成员变量、B的成员变量、C自己的成员变量

​	虚函数主要和派生类配合，用于实现动态多态，允许同一个类的不同实例对同一个消息作出不同的响应。比如派生类中有一个和基类同名的函数，且两函数都是虚函数，具体调用哪个函数就依据调用对象的实际类型决定。

​	虚函数的实现原理就是不在编译时确定调用的是哪个函数，而是在程序运行过程中才确定指向的对象；而虚函数实现多态这种特征就需要虚函数表；

虚函数表：

​	当一个类中存在虚函数时，**编译器**会为该类构造一个虚函数表。

​	一个类的所有实例都指向同一个虚表。虚函数表是一个指针数组，存放每个虚函数的入口地址。虚表的开头存放着运行时类型信息RTTI，后面就是虚函数。

​	每个多态类型的对象中都有一个指向当前类型的虚表的指针，该指针在构造函数中赋值；当通过基类的指针或者引用 调用虚函数时，就可以通过虚表指针找到该对象的虚表，进而在虚表条目中找到存放该虚函数的指针；将该条目中存放的指针读出后，就可以获得应当被调用的函数的入口地址，然后调用该虚函数，**虚函数的动态绑定就是这样实现的**



基类指针指向派生类对象，基类与派生类含有同名同参的函数，调用函数应该调用哪个，当函数有虚函数时又该调用哪个？

* 基类指针pBase指向派生类对象basePlus时，基类与派生类都含有同名同参函数且是一虚（virtual）一实，pBase调用他们中的实函数
* 基类与派生类都含有同名同参函数，且都是实函数时，调用的是基类的函数。
* 基类与派生类都含有同名同参函数，且都是虚函数时，根据对象的实际类型决定，这里调用的是派生类的函数。





#### 虚表指针，虚表是什么时候初始化的？

​	虚表指针是随着对象创建的，对象是在程序运行过程中被创建出来的，所以vptr也就是在程序运行过程中被创建的，在类的构造函数中赋值；

​	虚函数表创建时机是在编译期间，编译期间编译器就为每个类确定好了对应的虚函数表的内容，所以程序在运行期间，编译器就会把虚函数表的首地址赋值给虚函数表指针，那么这个虚函数表指针就被初始化了

#### 虚函数表和虚函数的位置

> [reference](https://blog.csdn.net/qq_28114615/article/details/98041319)

​	**虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。**

#### 如何通过手动的方式强行调用虚表中的函数？

> 具体访问时，虚函数表指针的偏移量是如何计算出来的？如何真正找到我想到访问的函数？

​	对于一个派生类/有虚函数的类，类的内存模型中的第一个就是指向虚表的指针。因此对对象取地址得到的地址，就指向虚表的指针，解引用就可以得到虚表的地址。虚表是个数组，就可以根据下标得到每个虚函数的地址。而虚表中虚函数的顺序，就是按类里面声明的顺序。而对于派生类的虚表，基类声明的虚函数对应的指针放在前面，派生类新增的虚函数的对应指针放在后面，这样一个虚函数的指针在基类虚表和派生类虚表有相同的位置。

例子：指针访问虚函数

```cpp
class A {
public:
    virtual void a() { cout << "A a()" << endl; }
    virtual void b() { cout << "A b()" << endl; }
    virtual void c() { cout << "A c()" << endl; }
    int x, y;
};

int main(){
    typedef long long u64;
    typedef void(*func)();
    
    A a;
    u64* p = (u64*)&a;  // p指向 指向虚函数的指针/虚指针的地址
    cout << *p << endl;  // 140695023172728，虚表的地址
    
    A a2;
	p = (u64*)&a2;
	cout << *p << endl;  // 140695023172728，类的不同实例指向一个虚表
    
    
    u64* arr = (u64*)*p;  // arr 指向虚函数表的第一个元素
   
    func fa = (func)arr[0];
    func fb = (func)arr[1];
    func fc = (func)arr[2];
    fa(); fb(); fc();  // 输出 A a() A b() A c()
    return 0;
}
```

<img src="E:/MarkDown/picture/image-20230423195314878.png" alt="image-20230423195314878" style="zoom:40%;" />

​	对于派生类B，与基类指向不同的虚表，而类的多个实例指向一个虚表。若B实现了虚函数，则指向自己的，否则指向基类的虚函数.

> 虚表指针是对象的，因此A* a3 = new B;指向的虚表还是B的

```
A* a1 = new A;
A* a2 = new A;
A* a3 = new B;
B* b = new B;
```

<img src="E:\MarkDown\picture\image-20230504231502424.png" alt="image-20230504231502424" style="zoom:40%;" />



#### 类的每个实例化对象都有虚表指针吗？

> 一个类实例化多个对象，是否这些对象都各自有自己的虚表指针？

​	虚表是针对类的，虚表指针是针对对象而言的；所以同一个类实例化多个对象，这些对象有各自的虚表指针，但是共用一块虚表；即这些对象的虚表指针的指向都是相同的，指向同一个虚表



#### 虚析构函数的作用

> 为什么析构函数可以是虚函数？

​	析构函数的功能就是在类对象消亡之前进行一些必要的清理工作。将析构函数声明为虚函数后，就可以在使用指针或引用时实现动态绑定，保证使用基类的指针就能够调用适当的析构函数针对不同的对象进行析构。

​	如果定义了一个基类指针指向派生类对象，在执行析构函数时就会先执行派生类的析构函数，再执行基类的析构函数；而不是仅执行基类的析构函数。注意，**使用基类指针的话，必须将基类的析构函数声明为虚函数，否则将仅调用基类的析构函数**，派生类的析构函数并没有调用，此时派生类就会导致内存泄露；

​	如果不是定义一个基类指针指向派生类对象，而是直接用派生类构造了一个对象，**此时即使基类的析构函数没有声明为虚析构函数**，对象析构时也会逐级往上调用析构函数，即先调用派生类的析构函数，再调用基类的析构函数；

#### 虚函数可以是内联函数吗/什么函数不能声明为虚函数？

​	虚函数的作用是实现动态多态性；动态多态性的**特点就是不在编译时确定调用的是哪个函数，而是在程序运行过程中才动态的确定操作所针对的对象**

1.static声明的静态成员函数不能做虚函数。因为static成员函数没有this指针，而vptr (虚表指针) 和vtable (虚表)需要通过对象的this指针来访问

2.内联函数不能是虚函数；因为对虚函数的调用需要动态绑定，而对内联函数的处理是静态的，内联函数是在编译时将函数体嵌入在每一个调用处（郑莉P136，P81）

3.多态是依托于类的，普通函数(即非成员函数)就不能声明为虚函数

4.友元函数不能是虚函数；C++不支持友元函数的继承，不能继承的函数不是虚函数

5.**构造函数不能是虚函数**；因为在执行构造函数前对象还没有创建，还没有vptr这个指向虚函数表的指针，就没法在虚函数表中找构造函数。

### 虚继承

> 虚继承解决什么问题, 虚继承的内存分布

[继承、虚继承、虚函数内存分布（MSVC下）_JACKSONMHLN的博客-CSDN博客](https://hd.nowcoder.com/link.html?target=https://blog.csdn.net/JACKSONMHLK/article/details/123872817)

​	虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这一是会浪费存储空间，二是使用时存在二义性问题。主要来解决菱形继承问题

菱形继承：两个派生类继承同一个基类，又有某个类同时继承者两个派生类。最后这个类继承自基类的数据继承了两份，使用的时候就会有二义性。

虚继承：继承前加virtual关键字后，变为虚继承。此时公共的父类称为虚基类。在多继承情况下，虚基类关键字的作用范围和继承方式关键字相同，只对紧跟其后的基类起作用。声明了虚基类之后，虚基类在进一步派生过程中始终和派生类一起，维护同一个基类子对象的拷贝

虚继承如何解决这种二义性的呢？从具有虚基类的类继承的类在初始化时进行了特殊处理，在虚派生中，由最低层次的派生类的构造函数初始化虚基类。通过虚基类指针和虚基类表找到最开始的基类，直接调用这个基类的构造函数。



```cpp
class Base {
public:
	int m_Age;
};

class A : virtual public Base {};
class B : virtual public Base {};
class C : public A, public B {};
```

​	虚继承底层实现原理与编译器相关，一般通过**虚基类表指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类表指针（占用一个指针的存储空间，8字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类表指针也会被继承

​	实际上，bptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚基类表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间

​	虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体

![image-20230511120100690](E:\MarkDown\picture\image-20230511120100690.png)

### 友元和虚继承

​	友元的目的就是让一个函数或者类 访问另一个类中的私有成员。全局函数、类、成员函数都可以做友元。
​    设计一个模板辅助类Base，将构造函数声明为私有的，这个Base类就是不能被继承的类，但无法正常使用；再设计一个类FinalClass，将FinalClass 作为Base的友元类，这样就可以正常访问Base。构造FinalClass类对象时们可以直接访问父类（Base）的构造函数。

```cpp
template <typename T>
class Base{
    friend T;
private:
    Base(){ cout << "base" << endl; }
    ~Base(){}
};

class FinalClass : virtual public Base<FinalClass>{  
 //一定注意 必须是虚继承
public:
    FinalClass(){
        cout << "FinalClass()" << endl;
    }
};

class C:public FinalClass{
public:
    C(){}     //继承时报错，无法通过编译
};


int main(){
    FinalClass b;      //B类无法被继承
    //C c;
    return 0;
}
```



### 虚析构函数

​	如果定义了一个基类指针指向派生类对象，在执行析构函数时就会先执行派生类的析构函数，再执行基类的析构函数；而不是仅执行基类的析构函数。注意，**使用基类指针的话，必须将基类的析构函数声明为虚函数，否则将仅调用基类的析构函数**，派生类的析构函数并没有调用，此时派生类就会导致内存泄露；

​	如果不是定义一个基类指针指向派生类对象，而是直接用派生类构造了一个对象，**此时即使基类的析构函数没有声明为虚析构函数**，对象析构时也会逐级往上调用析构函数，即先调用派生类的析构函数，再调用基类的析构函数；

### 纯虚函数和抽象基类

​	含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类，也就是不能被实体化的类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象，可以定义其派生类对象，**前提是这些类覆盖了纯虚函数**

​	**一个纯虚函数无须定义**。我们通过在函数体的位置(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数**声明**语句处

> 与虚函数区别

纯虚函数没有实现，必须在派生类中被重写；虚函数可以在基类中有默认实现，也可以重写。

纯虚函数只能通过派生类对象调用（因为基类没有实现

纯虚函数不会增加对象的大小，因为其没有实现；虚函数会增加，因为需要在对象中存储虚函数表的指针

### 析构函数不能抛出异常

c++11起，析构函数默认是noexcept的，抛出异常将会 terminate。

* 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
* 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。 

### overload、override、overwrite

> 重载和重写(覆盖)以及隐藏的区别？

overlaod叫重载  override叫覆盖   overwrite叫隐藏

具有相同函数名，但参数的个数、类型、顺序不同，编译器就会根据实参和形参的最佳匹配，自动确定来调用哪一个函数，此即为**重载**；

**覆盖**，函数名、参数列表、返回值相同；一般多用于类的继承中，将基类中与派生类同名的函数声明为虚函数，常用于派生类对基类函数的重新实现。可以使用override关键字显式地注明派生类将使用哪个成员函数改写基类的虚函数

> 协变：
> 在C++中，只要原来的返回类型是基类类型的指针或引用，新的返回值类型是派生类的指针或引用，覆盖的方法就可以改变返回类型，这样的返回类型称为协变返回类型。
> 这个时候返回类型小于父类了

**隐藏**是指派生类的函数屏蔽了其同名的基类函数。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，这样定义在内层作用域（即派生类）的函数将隐藏定义在外层作用域（即基类）的同名函数。可以通过作用域运算符base::来访问被隐藏的基类成员。

隐藏规则如下：

1.如果派生类的函数与基类的函数同名，但是参数不同；此时无论有无virtual关键字，基类的函数将被隐藏 （注意与重写区别开，通常基类的public成员函数在派生类中也可以使用，但是隐藏的话就不可见了，基类的成员函数在派生类中就被屏蔽掉了）

2.如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字；此时基类的函数将被隐藏



补充：需要注意使用默认形参值的函数重载形式时，需要防止二义性，如：

```c++
void fun(int length, int width = 2, int height = 3);        
void fun(int length);
//调用fun(1)直接报错，无法匹配
```



## 关键字

### 存储类

> 寄存器：中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。
>
> 内存：一般分为只读存储器（ROM）、随机存储器/内存（RAM）和高速缓存存储器（cache）。

c存储类：auto register static extern

[c++存储类](https://www.runoob.com/cplusplus/cpp-storage-classes.html)：auto(C++17开始不再作为存储类) register(C++17开始被弃用) static extern mutable thread_local(C++11)

**auto**：所有局部变量默认的存储类。在函数开始时被创建，在函数结束时被销毁。

**register**：用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。`register int miles; ` 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

**static**：指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

**extern**：用于提供一个全局变量的引用，全局变量对**所有的程序文件都是可见的**。当使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。

**mutable**：与const函数配合使用，修饰一个 const 方法中可变的数据成员

**thread_local**：thread_local 说明符用来修饰变量，仅可在其上创建的线程上访问。变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以与 static 或 extern 配合使用。一般用于需要保证线程安全的函数中。

### extern C

> ​	`extern` 是 `C/C++` 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
>
> ​	**而被 extern "C" 修饰的变量和函数是按照 `C` 语言方式编译和连接的。**可以实现c程序调用c++及C++调用C



> C和C++区别

​	`C++`为了支持函数重载，编译后在符号库中的名字与 `C` 语言的有所不同。比如函数被 `C` 编译器编译后在符号库中的名字为 `_foo` ，而 `C++` 编译器则会产生像 `_foo_int_int` 之类的名字（不同的编译器可能生成的名字不同），包含了函数名、函数参数数量及类型信息， `C++` 就是靠这种机制来实现函数重载的。

​	另一方面，`C++` 中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，以 `.` 来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。



假设在 `C++` 中，模块 `A` 的头文件如下：

```cpp
//模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
int foo( int x, int y );
#endif
```

在模块 `B` 中引用该函数：

```cpp
// 模块B实现文件　moduleB.cpp
#include "moduleA.h"
foo(2,3);
```

​	在连接阶段，连接器会从模块 `A` 生成的目标文件 `moduleA.obj` 中寻找 `_foo_int_int` 这样的符号！

​	对于上面例子，如果 `B` 模块是 `C` 程序，而A模块是 `C++` 库头文件的话，会导致链接错误；同理，如果B模块是 `C++` 程序，而A模块是C库的头文件也会导致错误。



#### 对于C调用C++

在C++头文件中要调用的函数前加上extern "C"，为了让 `C++` 编译时候能够生成 `C` 形式的符号

C程序并不include头文件（因为C语言不支持extern "C"关键字），而是`extern int add( int x, int y );`这个C++函数

```c
//C++头文件 cppExample.h
#ifndef CPP_EXAMPLE_H
#define CPP_EXAMPLE_H
extern "C" int add( int x, int y );
#endif

//C++实现文件 cppExample.cpp
#include "cppExample.h"
int add( int x, int y )
{
    return x + y;
}

/* C实现文件 cFile.c
/* 这样会编译出错：#include "cExample.h" */
extern int add( int x, int y );

int main( int argc, char* argv[] )
{
    add( 2, 3 );   
    return 0;
}
```

#### 对于C++调用C

在 `C++` 中引用 `C` 语言中的函数和变量，在包含 `C` 语言头文件（假设为 `cExample.h` ）时，需进行下列处理：

```cpp
extern "C"
{
    #include "cExample.h"
}
```

​	因为 `C` 库的编译是用 `C` 的方式生成的，其库中的函数标号是 `_foo` 的形式，没有任何参数信息，所以**在 `C++` 中，要指定使用 extern "C" ，进行 `C` 方式的声明**（如果不指定，那么 `C++` 中的默认声明方式是 `C++` 方式的，也就是编译器会产生 `_foo_int_int` ，这样的函数标号在已经编译好了的、可以直接引用的 `C` 库中是没有的）。通过头文件对函数进行声明，再包含头文件，就能引用到头文件中声明的函数(因为函数的实现在库中呢，所以只声明，然后链接就能用了)。

​	在 `C` 语言中，对其外部函数只能指定为 `extern` 类型，因为 `C` 语言中不支持 extern "C" 声明，在 `.c` 文件中包含了 extern "C" 时，当然会出现编译语法错误。

```cpp
/* c语言头文件：cExample.h */
#ifndef C_EXAMPLE_H
#define C_EXAMPLE_H
extern int add(int x,int y);
#endif

/* c语言实现文件：cExample.c */
#include "cExample.h"
int add( int x, int y )
{
    return x + y;
}

// c++实现文件，调用add：cppFile.cpp
extern "C"
{
    #include "cExample.h"
}
int main(int argc, char* argv[])
{
    add(2,3);
    return 0;
}
```

​	可见，如果 C++ 调用一个 C 语言编写的 `.DLL` 时，在包含 `.DLL` 的**头文件**或声明接口函数时，应加 `extern "C" {　}` 。这个时候，其实 extern "C" 是在告诉 C+ ，链接 C 库的时候，采用 `C` 的方式进行链接（即寻找类似 `_foo` 的没有参数信息的标号）。





​	可以和 `#ifdef __cplusplus #endif` 配合使用，`__cplusplus` 宏，是用来识别编译器的，也就是说，将当前代码编译的时候，是否将代码作为 `C++` 进行编译。如果是，则定义了 `__cplusplus` 宏。

```cpp
//incvxworks.h
#ifndef __INCvxWorksh
#define __INCvxWorksh

#ifdef __cplusplus
extern "C" {
#endif

    /*...*/

#ifdef __cplusplus
}
#endif

#endif /* __INCvxWorksh */
```



### union和enum

enum关键字用来定义枚举类型

https://zhuanlan.zhihu.com/p/595288133

https://blog.csdn.net/xiangbaohui/article/details/103689091

### explicit

* 应用于包含一个以上参数的构造函数。只有当**明确**调用构造函数的时候才会调用它，**不会发生隐式类型转换**

* 只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复

### static

可以加在变量前、函数前和类中

**全局静态变量**

* 只在**声明它的文件下可见**（从定义到文件结尾），普通全局变量在整个工程中是可见的。
* 不会被其他文件访问和修改；其他文件使用相同的名字的变量不会发生冲突

**局部静态变量**

* 存储位置从原来的栈区改为静态存储区。静态局部变量都会被程序自动初始化为0
* 局部静态变量的作用域仍然是局部的，没有改变。但static指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁，因此使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

**静态函数**

* 还是存放在代码区
* static修饰函数主要是改变了函数的作用域，**静态函数只在声明他的文件当中可见**，因此可以在其他文件中定义相同的静态函数名，不会发生冲突；

**静态成员变量**

* 静态成员变量位于全局数据区
* 静态成员变量**属于整个类所有**，所有对象共享类的静态成员变量，**生命期不依赖于任何对象，为程序的生命周期**
* 可以**通过类名或对象名访问**公有静态成员变量
* 静态成员变量需要在类外进行赋值
* 注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。

**静态成员函数**

* 静态成员函数没有this指针，不能访问普通成员变量和普通成员函数，只能访问静态成员变量和静态成员函数。如果一个函数只对静态成员进行操作，加上 static 语义更加明确。
* 静态成员函数经常用于在类内为泛型算法定义的二元谓词。比如刷leetcode时为sort提供一个谓词，如果写成成员函数的话是会有三个参数的（当然用lambda表达式更方便



​	编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，调用成员函数时就会把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。

普通成员变量占用对象的内存

**静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。**

> 静态成员函数经常用于在类内为泛型算法定义的二元谓词。如下例中，我们定义了cmp函数作为sort的谓词，但由于cmp为成员函数，所以其实际的参数为三个，即增加了this指针参数`bool cmp (Solution* this, ..., ...)`，而sort只能接收二元谓词，因此就会报错。加上static变为静态成员函数后，就没有了this指针。
>
> ```cpp
> class Solution {
> static bool cmp(vector<int>& a, vector<int>& b) {
>   if (a[0] == b[0]) return a[1] < b[1];  // 若身高相等，按k递增的顺序
>   return a[0] > b[0];  // 按身高递减
> }
> public:
> vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
>   sort(people.begin(), people.end(), cmp);
>   list<vector<int>> lst;
>   return vector<vector<int>>(lst.begin(), lst.end());
> }
> };
> ```



> static全局变量的报错会发生在哪个阶段

* 在编译阶段，如果在使用该变量的函数中没有声明这个变量，会提示变量未定义
* 在链接阶段，如果static定义在多个编译单元中，并被链接到同一个可执行文件中，则连接器会报错，提示该变量重复定义。比如static全局变量的定义被放在了头文件中，被多次包含后就会生成多个实例，导致链接错误



### const

const用来声明变量、成员函数等为不可修改的。

#### **const常量**

> 注意：
>
> * const修饰的量必须同时赋值：const int a = 4;
> * const常量被设定为仅在文件内有效，当多个文件出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。

​	C 语言中，const用来限制一个变量，表示这个变量不能被修改，定义的const将重新分配一个内存空间，C语言对 const 的处理和普通变量一样，会到内存中读取数据。

​	C++ 中，编译器对const做了特殊处理，将const常量放到**符号表**中，少了读取内存的过程，直接从符号表中读取。优点是提高了程序执行效率，缺点是**不能反映内存的变化，一旦 const 变量被修改，C++ 就不能取得最新的值**。（const在c++中是可以修改的。

> ​	我们知道，**变量是要占用内存的，即使被 const 修饰也不例外**。m、n 两个变量占用不同的内存，int n = m;表示将 m 的值赋给 n，**这个赋值的过程在C和C++中是有区别的**。
>
> ```c
> const int m = 10;
> int n = m;
> ```
>
> * 在C语言中，**编译器会先到 m 所在的内存取出**一份数据，再将这份数据赋给 n；
> * 而在C++中，**编译器会直接将 10 赋给 m，没有读取内存的过程，和`int n = 10;`的效果一样**。

#### **const函数**/**常函数**

> const可以用来修饰返回值、形参和成员函数
>
> * const int& fun(int& a); //修饰返回值
>   a.fun(2)=3;
>
>   多是引用类型的情况下，为了避免返回值被修改的情况
>
> * 形参通常会选择引用传递，这样可以节省内存，有的时候我们并不希望改变实参的值，就要加上const关键字，如const int &a，这里的常量指&a，即a的地址，故不可以改变引用指向的地址，但可以通过其他途径改变地址中的值
>
>   
>
> * 成员函数**后**加const(大括号前)，即紧随参数列表之后有const关键字，我们称为这个函数为**常函数**/常量成员函数，这里const的作用是修改隐式this指针（为常量指针）的类型，变为指向常量的常量指针，即const Person * const this

​	常函数的作用就是不改变对象成员的值，常函数内**不可以修改成员属性**；成员属性声明时加关键字==mutable==后，变为**可变数据成员**，在常函数中依然可以修改。

#### **常对象**

用法

> 声明对象前加const称该对象为常对象

**常对象只能调用常函数**

> * 指针的类型必须与其所指对象的类型一致，因为非常函数的this的类型是常量指针，T *const p，与所指的常对象const T类型不一致，因此常对象没法调用非常函数
> * 但有个例外就是允许一个指向常量的指针（const T *p，指针常量）指向一个非常量对象，因此普通的对象也可以调用常函数

```cpp
class Person {
public:
	Person() {
		m_A = 0;
		m_B = 0;
	}

	//this指针的本质是一个常量指针，Person* const this，指针的指向不可修改
    //若在前面再加一个const，则为const Person* const this，指针指向的值也不可以修改。因此这里把前面这个const加到了成员函数后面
	//如果想让指针指向的值也不可以修改，需要声明常函数
	void ShowPerson() const {
		//this = NULL; //不能修改指针的指向 Person* const this;
		//this->mA = 100; //但是this指针指向的对象的数据是可以修改的

		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
		this->m_B = 100;
	}

	void MyFunc() const {
		//mA = 10000;
	}

public:
	int m_A;
	mutable int m_B; //可修改 可变的
};


//const修饰对象  常对象
void test01() {

	const Person person; //常量对象  
	cout << person.m_A << endl;
	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

	//常对象访问成员函数
	person.MyFunc(); //常对象只能调用const的函数
}

int main() {

	test01();
 
	system("pause");
	return 0;
}
```



**常量折叠、符号表/常量表**

​	**常量折叠**，即将const常量放在符号表中，给其分配内存，但实际读取时类似宏替换。或者说const变量（即常量）值放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化。

​	**符号表/常量表/Symbol Table**是分配给函数和变量的名称与其在内存中的地址的映射，包括类型、范围和大小等元数据。最终由编译器使用。编译后的目标文件中有一个称为符号表的数据结构，它将目标文件中的不同项目映射到链接器可以理解的名称

​	而对于const常量，在g++和dev c++编译器中可以通过加上==volatile==关键字进行修改，在VC++6.0编译器中不支持

```cpp
#include<stdio.h>
int main() {
    const volatile int i = 10;
    int* pi = (int*)(&i);  
    *pi = 100;  
    printf("*pi: %d\n",*pi);  // 100
    printf("i: %d\n",i);  // 100
    printf("pi: %p\n",pi);  // 0xbfd97228
    printf("&i: %p\n", &i);  // 0xbfd97228
    return 0; 
}
```

通过gdb查看其**汇编代码**（gdb，然后输入：disass main）可以发现，加上volatile后输入*pi 和 i 时均是从堆栈（即内存）中取数的。

![image-20230301115837236](E:\MarkDown\picture\image-20230301115837236.png)

而在去掉volatile后，pi和i的地址还是相同，但const 变量 i 的值是没有改变的。查看其汇编代码可以发现，输出 i 的值时直接将 0xa（10）值从符号表输出，即此处编译器进行了优化，没有从内存中读。而在此基础上加上volatile修改符，即告诉编译器该变量属于易变的，不要对此句进行优化，每次计算时要去内存中取数。

![image-20230301120045051](E:\MarkDown\picture\image-20230301120045051.png)

#### 顶层const和底层const

> 对于顶层const，作为形参时会忽略掉顶层const，即传入的可以是const int，也可以是int
> 这就导致函数重载时不能以形参前面是否有const为区别
> <img src="E:\MarkDown\picture\image-20220605153118879.png" alt="image-20220605153118879" style="zoom: 33%;" />

指针本身是一个对象，又可以指向另外一个对象。
因此用顶层const表示指针本身是一个常量；更一般的，表示任意的对象是常量。
底层const表示指针所指的对象是一个常量。

常量指针int *const a为顶层const；const int ci = 42;也是顶层const。
指针常量const int *a为底层const；用于声明引用的const都是底层const，如const int &r = ci；

顶层const指对象本身是一个常量，执行拷贝操作不会改变被拷贝对象的值，因此不会有影响
底层const指指向的对象是一个常量，执行对象的拷贝操作时。拷入拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够相互转换。说白了就是看拷贝过去之后是不是还能保持常量，如底层const不能赋给一个不包含底层const定义的普通变量，但普通变量可以赋值给底层const，因为如int* 就可以转换为const int *

#### 构造函数不能const

​	构造函数不能声明为const的，因为我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得“常量”属性，因此构造函数在const对象的构造过程中可以向其写值，所以不能是const的

#### const变量存放的位置

​	在 c++ 中，是否为 const 常量分配内存空间依赖于如何使用。一般说来，如果一个 const 仅仅用来把一个名字用一个值代替(就像使用 #define 一样)，那么该存储局空间就不必创建。如果存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。 
​	取一个 const 地址, 或者把它定义为 extern，则会为该 const 创建内存空间。在 c++ 中，出现在所有函数之外的 const 作用于整个文件(也就是说它在该文件外不可见)，默认为内部连接，c++中其他的标识符一般默认为外部连接。

1、const int data = 10；//data先放入符号表

2、如果对data取地址 系统才会给data开辟空间

3、const int a = b; //b是变量名 系统直接给a开辟空间 而不放入符号表

4、cosnt 修饰自定义数据如类对象，系统为自定义数据开辟空间

对于分配了内存的const，存放在栈区或静态存储区

#### const成员函数构成重载

因为函数签名不同，const成员函数会在函数名后加上const关键字，表示该函数不会修改对象的状态。

#### 函数参数加const

值传递，即aa(const int a)不构成重载，这是顶层const，作为形参时会忽略

指针、引用作为参数加const构成重载，因为传进去是一个真实有效的值，它把a或者b直接传到函数中，这个const是有效的，因为他会影响到底传进去的这个参数能不能被修改。成员函数传递this指针 所以构成

#### const与#define区别

const最初的动机就是替代#define，const是优于define的

* #define没有类型检查，const在编译期做类型检查；
* **#define是在预处理阶段替换**，而**const是在编译阶段替换**。
* const方便调试和定位bug

#### const与static区别

​	const是一个关键字，用来声明变量、成员函数等为不可修改的。常函数的作用就是不改变对象成员的值，常函数内**不可以修改成员属性**；成员属性声明时加关键字==mutable==后，变为**可变数据成员**，在常函数中依然可以修改。

​	static 当与变量一起使用时，它表示变量具有静态存储持续时间，这意味着它在程序执行的整个持续时间内都存在；当与函数一起使用时，它表示该函数仅在声明它的文件中可见；当与类成员一起使用时，它表示该成员在该类的所有实例之间共享。

### #define

> C++定义常量两种方式
>
> * \#define 宏定义： `#define 常量名 常量值`
>   * ==通常在文件上方定义==，表示一个常量
>
> * const修饰的变量 `const 数据类型 常量名 = 常量值`
>   * ==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改。

#define 定义一个标识符来表示一个常量。其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。而预编译所执行的操作就是简单的“文本”替换

注意：

1. **这个#define是替换，如下面程序里，#define day a的话，就是将day变成了变量a，此时typeid(day).name()输出int；若是#define day 'b' ，则是char，#define day 7.2，则是double**
2. **使用 define 定义的宏可修改**
3. #define 后无分号

```c++
#include<iostream>// iostream是input output stream的缩写，意思是输入输出流头文件。
using namespace std;
#define day a
#define day 'b'  // 定义一个宏常量

#define N 5
#define LEFT (i + N - 1) % N  // 注意这里，可以用define表示变量
void test(int i) {
	cout<<LEFT<<endl;
}

int main() {
    test(2);  // 输出1
	const int a = 5;

	cout << typeid(day).name() << endl;  // char
	cout << typeid(a).name() << endl;  // int
	cout << day << endl;  // b
#define day 8  // 使用 define 定义的宏可修改
	cout << day << endl;  // 8
	system("pause");
	return 0;
}
```





#### typedef与#define区别

- **typedef** 仅限于为类型定义符号名称，**#define** 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。
- **typedef** 是由编译器执行解释的，**#define** 语句是由预编译器进行处理的。

### volatile

​	用于告诉编译器该变量的值可能会在程序执行期间被改变，因此需要在每次使用时从内存读取最新的值，而不是使用缓存中的旧值

​	直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制；例如，程序可能包含一个由系统时钟定时更新的变量；当对象的值可能在程序的控制或者检测之外被改变时，应该将该对象声明为 volatile；关键字 volatile 就是**告诉编译器不应对这样的对象进行优化(编译器的优化操作通常会将变量优化到寄存器chche中，若是不对变量进行改变，就直接读取寄存器中的值)，而是从内存中读取数据**，从而可提供特殊地址的稳定访问；

​	主要用于以下两种情况：

* **多线程环境下的共享变量：**在多线程环境中，如果一个变量被多个线程共享并且可能在一个线程中被修改，在另一个线程中被读取，可以保证对变量的访问不会被优化，从而保证线程之间的正确同步。
* **禁止编译器优化**

eg:

```c++
volatile int i = 10;
int a = i;
int b = i;
```

​	若没有 volatile ，由于编译器发现两次从 i 读取的数据之间的代码没有对 i 进行任何操作，它自动会把上次读取的数据放在b中，而不是重新从 i 里面读取，这样一来如果 i 是一个寄存器变量或者表示一个端口数据就容易出错。
​	volitate指出 i 是随时可能发生变化的，当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。每次使用它的时候必须从 i 的地址中读取，因此编译器生成的汇编代码会重新读取数据放在b中；

通过汇编改变变量的例子：

```cpp
int main() {
	int i = 10;
	int a = i;
	printf("%d", i);  // 10
	// 下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道
	__asm
	{
		mov dword ptr[ebp - 4], 20h
	}
	int b = i;
	printf("i=%d", b);  // 在debug调试版本模式运行下，输出32，在release版本下输出10
	return 0;
}
```

在release模式下，编译器对代码进行了优化，具体优化结果如下：
**由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i 是一个寄存器变量或者表示一个端口数据就容易出错**

加上volatile后：`volatile int i = 10;`在debug和release版本下均为32

> * volatile对应的变量可能在你的程序本身不知道的情况下发生改变
>   * 比如多线程的程序，共同访问的内存当中，多个程序都可以操纵这个变量，你自己的程序，是无法判定何时这个变量会发生变化。这些全局变量最好使用valotile修饰。这样可以避免因为编译器优化而引起的错误
>   * 还比如，他和一个外部设备的某个状态对应，当外部设备发生操作的时候，通过驱动程序和中断事件，系统改变了这个变量的数值，而你的程序并不知道
> * 对于volatile类型的变量，系统每次用到他的时候都是直接从对应的内存当中提取，**而不会利用cache当中的原有数值，**以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化——显然也是因为它的数值随时都可能变化的情况。

注：volatile不能取代锁来解决多线程竞争问题

volatile是用来修饰一些因为程序不可控因素导致变化的变量，比如访问底层硬件设备的变量，以提醒编译器不要对该变量的访问擅自进行优化，但是volatile并不能保证操作的原子性，在读取、写入变量的过程中仍然可能被其他线程打断导致意外结果发生，所以线程之间竞争问题的解决还是需要锁

**下面的函数被用来计算某个整数的平方，它能实现预期设计目标吗？如果不能，试回答存在什么问题：**

```cpp
int square(volatile int* ptr) {
    int a, b;
    a = *ptr;
    b = *ptr;
    return a * b;
}
```

不能。*ptr 的值可能在两次取值语句之间发生改变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：

```cpp
#include <stdio.h>
#include<iostream>
using namespace std;

long square(volatile int* ptr) {
    int a;
    a = *ptr;
    return a*a;
}

int main() {
	volatile int i = 10;
	cout << square(&i);
	return 0;
}
```



### inline

> 什么是内联函数？什么情况需要使用内联函数？

inline关键字修饰的函数

​	对一些功能简单，规模又小但使用很频繁的函数，可以设计为内联函数，在函数名前面加上inline关键字；内联函数是在**编译**时将函数嵌入在每一个调用处，这样就节省了参数传递和调用的开销；有利于提高效率



注意：

* 在C++中，**在类的内部定义了函数体的函数，被默认是内联函数**
* 关键字inline必须与函数定义体放在一起才能使函数成为内联，如果函数的定义放在了**类的外部**，函数定义前必须加inline才能成为内联函数，而函数声明前加不加都无所谓

所以可以说inline是一种用于实现的的关键字，而不是一种用于声明的关键字；



附：引入内联函数的目的是为了解决程序中函数调用的效率问题

​	函数调用会带来降低效率的问题，因为调用函数实际上会将程序执行顺序转移到函数所存放在内存中的某个地址，将函数中的代码执行完后，再返回到执行该函数前的地方。这种转移操作要求在转移前要保护现场并记忆执行的地址，转移后 (也就是函数调用完成后) 要恢复现场，并按原来保存地址继续执行。因此，函数调用有一定的时间和空间方面的开销，将影响程序执行效率。特别是对于一些函数体代码不是很大，但又频繁地被调用的函数来讲，解决其效率问题尤为重要；引入内联函数实际上就是为了解决这一问题



> 内联函数一定会被展开吗

不一定，由编译器决定，根据函数大小、调用次数等决定是否展开

> 虚函数可以是内联函数吗？

不可以。内联函数是在编译阶段展开，而虚函数是在运行时动态绑定

**缺点:**

> 滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。

在使用内联函数时要留神：

- 在内联函数内不允许使用循环语句和开关语句(switch)；
- 内联函数的定义必须出现在内联函数第一次调用之前；
- 类结构中所在的类说明内部定义的函数是内联函数。
- 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。



#### inline和宏

都可以用来实现代码的内联展开

* 展开时机不同：inline是由编译器，宏是由预处理器
* 内联函数会进行类型检查
* 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义



### constexpr

​	使指定的常量表达式获得在程序编译阶段就能计算出结果，而不必等到程序运行阶段。

**常量表达式**指值不会改变并且==在编译过程就能得到计算结果==的表达式。

​	一般当认定一个变量为常量表达式，那就声明为constexpr类型，用于定义编译时常量，且还能用于函数和构造函数



* 字面值属于常量表达式
* 用常量表达式初始化的const对象也是常量表达式


具体来说就是前面带有const，**且能直接得到计算结果的**

<img src="E:\MarkDown\picture\image-20220427183825246.png" alt="image-20220427183825246" style="zoom:67%;" />
如这个的具体值要运行时才能得到，因此不是<img src="E:\MarkDown\picture\image-20220427183833927.png" alt="image-20220427183833927" style="zoom:67%;" />



常量表达式会有什么**好处**：

* 允许一些计算只在编译时进行一次，而不是每次程序运行时；
* 编译器可以进行尺度更大的优化；
* 可以用在需求编译期间常量的上下文，例如数组长度等；



​	在一个复杂系统中，几乎不能分辨一个初始值是不是常量表达式。因此 **c++11** 新标准中规定，可以将变量声明为constexpr类型以便由编译器验证变量的值是否为常量表达式。声明为constexpr的变量一定为一个常量，并且必须用常量表达式初始化
![image-20220427184554113](E:\MarkDown\picture\image-20220427184554113.png)



> 注意：
> **若在constexpr声明中定义了一个指针，则这个限定符仅对指针有效，即int* const p常量指针**
>
> ![image-20220427194245375](E:\MarkDown\picture\image-20220427194245375.png)

> 与const区别：

​	const 变量的初始化可以延迟到运行时，而 constexpr 变量必须在编译时进行初始化。所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。
​	**const**用于定义一个不可修改的常量。把对象声明为const也为编译器提供了潜在的优化可能。具体来说就是，如果把一个量声明为const，并且没有其他地方对该量作取址运算，那么编译器通常(取决于编译期实现)会用该量的实际常量值直接替换掉代码中所有引用该量的地方，而不用在最终编译结果中生成对该量的存取指令，即常量折叠
​	**constexpr**的主要功能则是让更多的运算可以在编译期完成，并能保证表达式在语义上是类型安全的。(译注：相比之下，C语言中#define只能提供简单的文本替换，而不具任何类型检查能力)。与const相比，被constexpr修饰的对象则强制要求其初始化表达式能够在编译期完成计算。之后所有引用该常量对象的地方，若非必要，一律用计算出来的常量值替换。

**constexpr函数（编译期的函数）**

虽然不能用普通函数作为constexpr变量的初始值，但新标准允许定义**constexpr函数**，使得编译时就可以计算结果。

constexpr函数指能用于常量表达式的函数，且要求：函数的返回类型及所有**形参**的类型都必须为字面值类型，且函数体中有且只有一条return语句（不产生实际代码的语句可以在常量表达式函数中使用，如static_assert,using,typedef等。在c++14中进一步放宽，只保留了“函数的返回值类型及所有形参的类型都是字面值类型”·）。在函数前面加上constexpr即可

执行该初始化任务时，constexpr函数先被**隐式的指定为内联函数**来方便在编译过程中随时展开，后编译器把对函数的调用替换成结果值



##### **constexpr构造函数：**

> constexpr修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，可用于各种只能使用constexpr的场合。

​	构造函数不能是const的，但字面值常量类的构造函数可以是constexpr函数。constexpr函数可以声明成=default形式或=delete形式，否则就==必须保证constexpr构造函数体是空的==。且constexpr构造函数必须初始化所有数据成员
![image-20220725190722813](E:\MarkDown\picture\image-20220725190722813.png)

![image-20220725192956906](E:\MarkDown\picture\image-20220725192956906.png)



### override

检查是否正确重写了基类中的虚函数，否则会提示错误信息。

​	C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个override关键字。
​	override意为覆盖、改写，应用在虚函数上，要求函数的签名(包括函数名，参数类型，参数个数和顺序，以及它所在类和命名空间。注意，const也是函数签名的一部分)必须完全相同。
​	通常是作为一个保险，常用于本意是要 override ，但写错了，导致意外创建了一个新虚函数，导致派生类的函数并没有覆盖掉基类中的版本。这时如果加上 override ，编译器就会报错来提醒我们。即**如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错**。` error: 'void B::aa(int)' marked 'override', but does not override`

> ​	在C++11之前，关于子类覆写父类虚函数后，子类的虚函数还要不要加`virtual`关键字，还是个值得争论的问题。
> ​	C++11后，通常在**最顶层的虚函数上加上`virtual`关键字**，其余的子类覆写后**就不再加`virtual`了**，但是要**统一加上`override`**。

### mutable

​	mutable关键字是用来修饰类的成员变量的，而变量本来就是可变的。因此mutable的作用是**修饰一个 const 方法中可变的数据成员的**。通常配合const使用：const修饰的方法中，mutable修饰的成员数据可以发生改变，除此之外不应该对类/对象带来副作用。一个使用场景就是当我们在一个需要对外表现为const的函数中改变一些变量，比如修改成员变量、实现线程安全等，就需要将成员变量和锁都声明为mutable。

* mutable可用来修饰类的成员属性，声明为mutable后变为可变数据成员，则mutable成员在const成员函数中也可以进行修改

  ```cpp
   class Mesh {
     std::vector<Vertex> vertices;    //模型顶点的集合
     mutable std::mutex mtx;
     mutable double volume;              //计算出来的体积
     mutable bool volumeCalculated;      //当前体积是否已计算的标识
   public:
     Mesh(std::vector<Vertex> vxs = {}): volume{0}, volumeCalculated{false}, vertices(std::move(vxs)) {}
     
     double getVolume() const {
       std::scoped_lock lock{mtx};                     //OK
       if(volumeCalculated) {
         return volume;
       }
       volume = geometry::calculateVolume(vertices);   //OK
       volumeCalculated = true;                        //OK
       return volume;
     }
     
     void addVertex(Vertex const& v) {
       std::scoped_lock lock{mtx};
       vertices.push_back(v);
       volumeCalculated = false;
     }
     
     //...
   };
  ```

  

* 另外一个使用场景是在值捕获的lambda表达式中，在参数列表后加上关键字mutable来改变这个被捕获的变量的值

  ```cpp
  size_t v1 = 10;
  auto f = [v1]() mutable { return ++v1; };
  ```



### typedef与using

#### Type Alias类型别名

type alias就是将某一个type重新命名为另一个更加直观简单的名字。有两种方法定义类型别名：

* typedef
* **using**（c++11）

**typedef关键字**

C语言提供

1、为类型取一个新的名字
不只是简单的宏替换，可以用作同时声明指针型的多个对象

```cpp
typedef int A;  // 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写
A m1,m2;
typedef A base,*p;  // base是int的别名，p是int*的别名

typedef char* PCHAR;
PCHAR pa, pb; // 可行，同时声明了两个指向字符变量的指针

// 若别名指代的是复合类型或常量，则会比较复杂
typedef char *pstring;  // 这里pstring是char*的别名，是指向char的指针
const pstring cstr = 0;  // 这里const是对给定类型的修饰，因此cstr是一个指向char的常量指针，即char* const。而不是简单的把pstring替换成char*，成了const char* cstr，这是错误理解
const pstring *ps;  // ps是一个指针，ps指向的对象是 指向char的常量指针
```

而且可以用typedef来定义与平台无关的类型

比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：
 typedef long double REAL; 
 在不支持 long double 的平台二上，改为：
 typedef double REAL; 
 在连 double 都不支持的平台三上，改为：
 typedef float REAL; 
 也就是说，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。
 标准库就广泛使用了这个技巧，比如size_t。

2、为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称

为用户自定义的结构体取一个新的名字（常用于旧的c++代码中

```cpp
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;
 
int main( )
{
   Book book;
   strcpy( book.title, "C 教程");
   return 0;
}
```

或者先定义结构类型，再起别名

```cpp
struct tagPoint
{
    double x;
    double y;
    double z;
} ;
int main() {
	typedef tagPoint Point;  // typedef struct tagPoint Point;，struct可省略
	Point oPoint1={100,100,0};
    Point oPoint2;
	//__type_traits<int>::aa a;
	system("pause");
	return 0;
}
```



3、为数组定义简洁的类型名称

```cpp
typedef int INT_ARRAY_100[100];
INT_ARRAY_100 arr;
cout<<typeid(arr).name()<<endl;  // 输出A100_i
cout<<arr[0]<<endl;  // 1878353108，未赋值，输出乱码
cout<<typeid(arr[0]).name()<<endl;  // 输出i，为int
```

#### using

```cpp
using SI = Sales_item;  // 把SI作为等号右侧类型的别名


// 类型别名(Type Alias)声明和类型定义(typedef)声明之间没有区别。此声明可以出现在块作用域、类作用域或命名空间作用域中。

// typedef void (*func)(int, int);  // typedef
using func = void (*) (int, int);  // Type Alias,func为一个函数指针

void example(int, int) {}
func fn = example;  // 函数名就是函数指针（地址


// type alias can introduce a member typedef name
template<typename T>
struct Container {
    // typedef T value_type;
	using value_type = T;  
};

// type alias used to hide a template parameter
template<class CharT> using mystring = std::basic_string<CharT, std::char_traits<CharT>>;
mystring<char> str;



// 通过类型别名简化函数指针
using F = int(int*, int);  // F为函数类型
using PF = int(*)(int*, int);  // PF为函数指针类型

PF f(int);  // 返回指向函数的指针，这里f的形参对应指向函数的返回值
F f(int);  // 错误，不能返回一个函数
F *f(int);  // 正确，显式地指定返回类型是指向函数的指针

// 直接声明
int (*f(int))(int*, int);

// 尾置返回类型（c++11，对于返回类型比较复杂的函数最有效
// 在本应出现返回类型的地方放置一个auto
auto f(int) -> int(*)(int*, int);
```



#### typedef和using的区别

typedef和using实现的功能是完全一样的。

C++编译器不支持使用typedef关键字为模板类设置别名，即typedef不能和template一起使用。只有using才可以使用template



## 模板

### ==模板与泛型编程==

[可变参数模板详细使用教程](https://blog.csdn.net/bit_zyx/article/details/127336991)

> 模板的头文件通常既包含声明也包括定义

<img src="E:\MarkDown\picture\image-20230508214806487.png" alt="image-20230508214806487" style="zoom:60%;" />



### 模板了解多吗

### 模板特例化

16.1 定义模板

> 标准库算法都是**函数模板**，标准库容器都是**类模板**

函数模板、实例化、非类型模板参数、模板编译(模板的头文件包括声明和定义)、类模板、友元、模板类型别名、类模板的static成员、默认模板实参、成员模板、显式实例化、



> 一个模板特例化就是一个用户提供的模板实例，它将一个或多个模板参数绑定到特定类型或值上。
>
> **使用场景：**
>
> ​	当我们不能(或不希望)使用模板版本时，可以定义类或函数模板的一个特例化版本
>
> ​	例如，在某些情况下，我们为某个特殊版本定义一个普通的非模板函数，会影响函数的匹配：
> ![image-20221112163710733](E:\MarkDown\picture\image-20221112163710733.png)![image-20221112163634887](E:\MarkDown\picture\image-20221112163634887.png)
>
> > 编译器会优选选择特例化版本的模板函数。但如果同时有函数模板和非模板函数，会优先选择非模板函数。
>
> **本质**
>
> 特例化的本质是**实例化一个模板**而非重载他。本质上是接管了编译器的工作，即为原模板的一个特殊实例提供了定义。因此特例化不影响函数匹配
>
> **注意事项**
>
> 模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。

#### 函数模板特例化

> 一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型

```cpp
// 为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中
// 原函数模板的声明
template <typename T> int compare (const T&，const T&) ;


// compare的特殊版本，处理字符数组的指针
// T为const char*，在特例化版本中，使用的类型是一个 指向const char的 const指针 的引用
template <>
int compare (const char* const &p1, const char* const &p2) {
    return strcmp(p1, p2);
}

```

#### 类模板特例化:全特化和偏特化

> 分全特化和偏特化
> 全特化：将类模板完全特例化
> 偏特化：部分特例化，即指定部分参数或参数的一部分。其模板参数列表是原始模板的参数列表的一个子集或一个特例化版本

```cpp
// 原始的、最通用的版本
template <class T> struct remove_reference {
	typedef T type;
};

// 部分特例化版本，将用于左值引用和右值引用
// 其他也可以<T*>、<const T*>等
template <class T> struct remove_reference<T&>  // 左值引用
	{ typedef T type; };
template <class T> struct remove_reference<T&&>  // 右值引用
	{ typedef T type; };

int i;
// decltype(42)为int，使用原始模板
remove_reference<decltype(42)>::type a;
// decltype(i)为int&,使用第一个(T&)部分特例化版本
remove_reference<decltype(i)>::type b;
// decltype (std::move(i))为int&&,使用第二个(即T&&)部分特例化版本
remove_reference<decltype(std::move(i))>::type C;

```

> 编译器更倾向于选择全特化的模板，然后是偏特化的模板，最后是主模板。

```cpp
template <typename T, int Line, int Column>     // (1)
class Matrix;

template <typename T>                           // (2) 偏特化
class Matrix<T, 3, 3>{};

template <>                                     // (3) 全特化
class Matrix<int, 3, 3>{};

Matrix<int, 3, 3> m1;          // class Matrix<int, 3, 3>
Matrix<double, 3, 3> m2;       // class Matrix<T, 3, 3> 
Matrix<std::string, 4, 3> m3;  // class Matrix<T, Line, Column> => ERROR
```

* 主模板：第 (1) 行是主模板。主模板必须在部分或全特化模板之前声明。如果不需要主模板，像第 (1) 行这样的声明就可以了
* 偏特化：第 (2) 行是偏特化模板。只有类模板支持偏特化。一个偏特化模板有模板形参和明确指定的模板实参。在这个例子中，类 `Matrix<T, 3, 3>` 的 `T` 是模板形参，数字是模板实参。

* 全特化：第 (3) 行是全特化模板。“全”意味着所有的模板实参都已明确，模板形参列表为空：正如第 (3) 行的 `template <>` 所示。

#### 特例化成员而不是类

可以只特例化特定成员函数而不是特例化整个模板

```cpp
template <typename T> struct Foo {
	Foo(const T &t = T()) : mem(t) { }
	void Bar() { /* ... */ }
	T mem;
	// Foo的其他成员
};

template<>  // 我们正在特例化一个模板
void Foo<int>::Bar()  // 我们正在特例化Foo<int>的成员Bar
{
    // 进行应用于int的特例化处理
}

// 只特例化Foo<int>类的一个成员，其他成员将由Foo模板提供:
Foo<string> fs;  // 实例化Foo<string>::Foo()
fs.Bar () ;  // 实例化Foo<string>::Bar()
Foo<int> fi;  // 实例化Foo<int>::Foo()
fi.Bar() ;  // 使用我们特例化版本的Foo<int>::Bar()
```



## 容器

### 容器

容器是一种类模板。可以分为顺序容器、关联式容器、无序容器

* 顺序容器
  * 数组(array)： 顺序存储、支持下标访问、不可扩增（c++11)
  * 向量(vector)： 顺序存储、支持下标访问、可在尾部扩增
  * 双向队列(deque)： 非顺序存储，**支持下标访问**，可双向扩增
  * 双向链表(list)： 非顺序存储，不支持下标访问，可在任意位置扩增
  * 至于另外一些常见的如栈(stack)、单向队列(queue)、单向链表(forward_list)、优先队列(priority_queue)等等，都只是基本容器的适配器。

* 关联容器

​	set multiset map multimap 底层红黑树

* 无序容器

​	unordered_set unordered_map 底层哈希表



> 顺序容器使用场景

* 如果需要经常随机访问，而不在乎插入和删除的效率，使用vector
* 如果需要大量的插入和删除，而不关心随机存取，则应使用list
* 如果要随机访问，而且关心两端数据的插入和删除，则应使用deque。

> list和vector遍历哪个快

​	在绝大多数情况下，`std::vector` 的遍历速度会比 `std::list` 快得多。这是因为 `std::vector` 是一个连续存储的动态数组，而 `std::list` 是一个双向链表。连续存储的特性使得 `std::vector` 在内存中的数据紧密排列，有利于 CPU 缓存的预取和使用，从而提高遍历速度。

​	相比之下，`std::list` 的元素在内存中是分散存储的，每个元素都包含指向前一个和后一个元素的指针，这会导致更多的内存访问开销和缓存不命中。

> sizeof和strlen的区别

**用途不同：**`sizeof` 用于获取类型或变量在内存中的字节数，而 `strlen` 用于获取字符串的长度(在运行时遍历字符串，直到找到 null 终止字符，不包括 null 终止字符在内)。

**运算时机：** `sizeof` 在编译时计算，而 `strlen` 在运行时计算。

**参数类型：**`sizeof` 可以接受类型或变量作为参数，而 `strlen` 只能接受以 null 终止的 C 字符串作为参数。

> 有哪些logN复杂度查询的数据结构

1. **平衡二叉搜索树：** 平衡二叉搜索树，如 AVL 树、红黑树等，在每个节点保持平衡的情况下，能够在 O(log N) 时间内进行查找、插入和删除操作。这使得它们适用于需要频繁的搜索操作的场景。
2. **堆：** 堆是一种特殊的树形数据结构，分为最大堆和最小堆。最大堆或最小堆的查找最值（最大值或最小值）操作的复杂度是 O(1)，插入和删除操作的复杂度是 O(log N)。
3. **有序数组：** 在有序数组中，可以使用二分查找来在 O(log N) 时间内进行查找操作。然而，插入和删除操作的平均复杂度是 O(N)，因为需要移动其他元素。
4. **哈希表（Hash Table）：** 虽然哈希表的查找、插入和删除操作通常是 O(1) 复杂度，但在最坏情况下会退化为 O(N)，取决于哈希函数的性能和冲突处理策略。



> 仿函数怎么用到map中

在定义map时加上仿函数，`map<int, int, MyFunc> map`



> stack的底层实现

和queue一样，内部用的deque

> vector的底层实现

就是一块连续的内存，当size超过了capacity时，进行扩容，即重新分配一块更大的内存块，并复制元素

包含指向内存块的指针、size、capacity等



> push_back()和emplace_back()区别

注意，在c++11之后，这两个就相同了，push_back直接调用emplace_back

* push_back() 向容器尾部添加元素时，首先会**创建**这个元素，然后再将这个元素**拷贝**或者**移动**到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）。即调用构造函数后再调用移动构造函数
  <img src="E:\MarkDown\picture\image-20230403114322455.png" alt="image-20230403114322455" style="zoom:55%;" />
* emplace_back() 在实现时，通过forward完美转发直接将x传递给对应类的构造函数，直接将构造函数所需的参数传递过去，然在容器尾部构建一个新的对象，省去了拷贝或移动元素的过程。即只调用构造函数。



> map对于自定义类为key的时候，需要注意什么（应该是重载比较运算符，当时没想到）

需要重载<运算符和==运算符，使得key能正确的比较大小

如果是unordered_map，还需要实现hash函数，以便能正确的将key映射到桶中

> 重载<操作符的函数原型？

对于STL容器中的元素，可以使用函数对象的方式进行重载

```c++
struct A {
    int a;
    int b;
}
struct myless {
    bool operator()(const A& x, const A& y) const {
        return x.a < y.a || (x.a == y.a && x.b < y.b);
    }
};

std::set<A, myless> set;
```



> unordered_map中插入一个已存在的key会发生什么

如果是insert插入，会返回一个pair，first是插入元素的迭代器，second是插入是否成功的bool，会插入失败并返回false

如果是[]操作符，会覆盖value



> 哈希碰撞解决方法

* 链地址法 / 拉链法：有冲突的信息具有相同的key值，将它们按顺序链接在同一地址下（尾插法）
  * 链表查找时间复杂度，On岂不是影响性能，怎么优化？
  * 优化链表结构，比如使用跳表或红黑树代替链表
  * 使用其他解决哈希的方法
* 开放寻址法 / 再散列法：比如线性检测再散列：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

再哈希法：同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

> deque双端队列的实现原理

​	deque 对外是连续的，但内部不是连续的，内部空间是`分段连续空间`，类似hashtable 的形式，**通过一个数组保存指针类型的map结点。数组中每个map指针都指向了另一个数组，而这个数组才是用来存放数据的（称为buf）**。在map数组中，最开始并不会直接用第一个元素去创建buf数组，而是从map数组的中间开始创建第一个buf数组。这样，若最前端的buf中不能满足在前边加入元素的话，那就在这个buf数组的map节点的前一个map节点在开辟出一个buf数组。如下图所示

![image-20221114185253999](E:\MarkDown\picture\image-20221114185253999.png)

​	当整个map空间全部占用后，在需要拓展空间并不需要拷贝全部的数据成员，只需要将原map数组拷贝到新内存空间的中段，这样deque就可以保持向左和向右扩张的能力，这就大大节省了时间上的开销。
![image-20221115105649467](E:\MarkDown\picture\image-20221115105649467.png)



> map的底层为什么是红黑树，红黑树和AVL树的区别？

因为红黑树插入、删除、查找等操作的时间复杂度都是O(logn)，且具有较好的稳定性

### 红黑树

> 红黑树和BST二叉搜索树的区别

​	红黑树是一种平衡二叉搜索树，在BST中一个结点的左子树小于这个结点的值，右子树大于这个结点的值的基础上，多了平衡的特性，即左右子树的高度差不大于1，来避免BST在数据更新的过程中退化为链表的问题。

​	红黑树对比标准的平衡二叉搜索树，只是近似的平衡，保证最长路径不超过最短路径的两倍，因此插入、删除的维护成本也较低。

**与AVL树对比**

​	AVL树是一种高度平衡的二叉树，所以查找的效率非常高，但是有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。
​	红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。

> 红黑树的原理

1. **每个节点不是红色就是黑色**
2. **根节点为黑色**
3. **如果节点为红色，其子节点必须为黑色**
4. 每个叶子节点都是黑色的空节点，也就是说，叶子节点不存储数据  
5. **任意节点至叶子节点的任何路径中，所含黑节点数必须相同**

在插入和删除节点时，需要通过旋转和重新着色来维持红黑树的平衡。





### **hashtable 对比 R-B Tree**

* map始终保证遍历的时候是按key的大小顺序的，默认有序，这是一个主要的功能上的差异。unordered_map无序。
* 时间复杂度上，红黑树的查找和删除性能都是O(logN)，是相对于稳定的，最差情况下都是高效的。
  而哈希表的查找和删除性能理论上都是O(1)，这有个前提就是哈希表不发生数据碰撞。在发生碰撞的最坏的情况下，哈希表的插入和删除时间复杂度最坏能达到O(n)。最坏情况就是所有的哈希值全部都在同一个链表上
* 红黑树可以做范围查找，而哈希表不可以。
* 对于**内存占用**，红黑树占用的内存更小（仅需要为其存在的节点分配内存，每一个节点需要保存其父节点位置、孩子节点位置及红/黑性质，因此每一个节点占用空间大），而哈希事先就应该分配足够的内存存储散列表，是牺牲内存换取更快的查找速度。
  对于**内存效率**，unordered_map的散列空间会存在部分未被使用的位置，所以其内存效率不是100%的。而map的红黑树的内存效率接近于100%。
* Hash Table 由于建立了哈希表，在最开始建立的时候比较耗时间
* **扩容导致迭代器失效**。
  map的iterator除非指向元素被删除，否则永远不会失效。
  unordered_map的iterator在对unordered_map修改时有时会失效。因为在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。

适用场景：
	在**有顺序要求**的场合，肯定是要用RB-tree的；
	如果我们只操作一次，为了**保证最坏情况下的运行时间**，最好也适用RB-tree；
	而如果是需要经常操作，RB-tree肯定是没有hash_table快的。
因此，除了有**顺序要求和有单次操作时间要求的场景下用RB-tree**，其他场景都使用hash_table。

> 给你1百万个数据，怎么来选择容器

如果没有查找要求，用顺序容器

* 如果需要经常随机访问，而不在乎插入和删除的效率，使用vector
* 如果需要大量的插入和删除，而不关心随机存取，则应使用list
* 如果要随机访问，而且关心两端数据的插入和删除，则应使用deque。

如果有查找要求，选关联容器或无序容器

* 对于有**顺序要求**，比如需要进行范围查找，选关联容器
* 如果有单次操作时间要求，需要保证最坏前情况下运行时间，选关联容器
* 其他场景都使用hash_table。





### 二叉树的查找复杂度，描述一下为什么是这个复杂度

普通二叉树取决于树的高度，最差为O(n)

平衡二叉树则最差为O(log2n)



### 清空vector

vector.clear会为vector中保存的所有对象调用析构函数，并将size置为0，但capacity没变，内存没有真正被释放

我们可以通过与一个空vector swap，来将size和capacity清空：`vector<int>().swap(vec);`

C++11推出了 `shrink_to_fit` 方法，减少容器的容量以适应其大小并销毁超出容量的所有元素。这样clear后再 `vec.shrink_to_fit()` 就可以将capacity也置为0



### 栈和队列的实现

底层是用deque实现的

> ​	stack栈和queue队列的内部实现都是直接用的deque。功能只是deque的子集。并且不提供iterator，因为会破坏容器先进后出、先进先出的性质。因此也没有find等算法

queue和stack中含有一个deque，然后调用已经完成的deque来完成我们需要的操作

![image-20221115114915476](E:\MarkDown\picture\image-20221115114915476.png)

![image-20221115114924197](E:\MarkDown\picture\image-20221115114924197.png)





### 用队列实现栈

一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了

```cpp
void push(int x) {
    que.push(x);
}
int pop() {
    int size = que.size();
    size--;
    while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
        que.push(que.front());
        que.pop();
    }
    int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
    que.pop();
    return result;
}
```

### vec.clear()

clear会为vector中保存的所有对象调用析构函数，并将size置为0，但capacity没变，内存没有真正被释放

我们可以通过与一个空vector swap，来将size和capacity清空：`vector<int>().swap(vec);`

C++11推出了shrink_to_fit方法，减少容器的容量以适应其大小并销毁超出容量的所有元素。这样clear后再 `vec.shrink_to_fit()` 就可以将capacity也置为0

### vector的数据移动

vec2 = std::move(vec)，移动后vec为空

部分数据拷贝：vec2.assign(vec.begin() + 1, vec.begin() + 4);

### 迭代器失效

> 注意，但凡是使用了迭代器的循环体`for(vector<int>::iterator it = a1.begin();it!=a1.end();++it){}`，都不要向迭代器所属的容器添加元素，因为任何一种可能改变对象容量的操作，如push_back，都会使迭代器失效

* vector发生扩容之后，比如插入时size>=capacity、在中间位置插入等
* erase删除元素的时候



* map的iterator除非指向元素被删除，否则永远不会失效。
* unordered_map的iterator在对unordered_map修改时有时会失效。因为在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。



> insert和erase后如何让迭代器继续有效

使用函数的返回值，会指向被插入的元素或删除元素的下一个元素，来代替之前的迭代器



## 其他

### C和C++区别

**1.面向对象编程：**

* C 语言是一种过程式编程语言，主要关注于过程和函数的编写，不支持面向对象编程。
* C++ 引入了类和对象的概念，支持面向对象编程，包括封装、继承和多态等特性。

**2.类和对象：**

* C 没有类和对象的概念，代码组织相对较简单。C是分为数据和函数，而函数可以处理Data产生的所有的数据，这些数据没有关键字的约束，是全局的，各个函数都可以去处理他
* C++ 允许定义类和对象，可以将数据和方法封装成一个整体，提供更好的抽象和封装。

**3.函数重载和运算符重载：**

* C 不支持函数重载和运算符重载。

**4.标准模板库（STL）：**

* C 没有标准模板库（STL），需要手动实现常用的数据结构和算法。
* C++ 提供了 STL，它包含了各种容器、算法和函数对象，可以大大简化和加速程序开发。

**6.异常处理：**

* C 不支持内置的异常处理机制，错误处理通常使用错误码或返回值。
* C++ 引入了异常处理机制，可以更好地处理运行时错误，增强代码的健壮性。

**7.命名空间：**

* C 没有命名空间的概念，容易引起命名冲突。
* C++ 引入了命名空间，可以将代码分组，避免命名冲突。

**8.内存管理：**

* C 使用 `malloc` 和 `free` 来动态分配和释放内存。
* C++ 使用 `new` 和 `delete` 运算符来动态分配和释放内存，还提供了 RAII（资源获取即初始化）的概念。

**9.扩展性：**

* C++ 可以与 C 语言代码兼容，可以使用 C 语言库，从而方便地与现有 C 代码进行交互。



### C++、C#、Python的区别

* Python 是解释型语言，C 和 C# 需要编译为二进制代码才能运行
* C++ 需要手动管理内存，C# 和 Python 都有垃圾回收机制
* C++ 和 C# 都是静态类型语言，需要在编译时明确定义变量的数据类型；Python 是动态类型语言，不需要在变量声明时指定数据类型，类型检查发生在运行时。



* 与 C++ 相比，C# 不支持多重继承（**当 B 类从 A 类派生，C 类从 B 类派生**），只能单一继承；
* C# 的接口与单一继承，承载着处理逻辑；
* C# 编程可用于创建控制台应用程序，Windows 应用程序，移动应用程序等。Windows 之外很少使用。



**应用领域：**

* C++ 通常用于系统编程、游戏开发、嵌入式系统和高性能应用。
* C# 主要用于 Windows 开发，包括桌面应用、Web 开发和游戏。
* Python 用于各种应用领域，包括 Web 开发、数据科学、机器学习、自动化脚本等。

### c++11

智能指针

移动语义相关：move、右值引用

容器：基于哈希表的set和map、单向链表、std::array

范围for循环：遍历容器中的元素

auto自动类型推导

lambda表达式：匿名函数，用于简化代码



可变参模板

constexpr

nullptr

**线程相关**

[`std::chrono`](https://subingwen.cn/cpp/chrono/)日期和时间相关的库。包含三个类：时间间隔duration、时钟clocks、时间点timepoint，其中时钟类中的`high_resolution_clock`类较为常用

[`std::thread`](https://subingwen.cn/cpp/thread/)线程类以及关于线程的命名空间[`std::this_thread`](https://subingwen.cn/cpp/this_thread/)

`std::call_once()`和`std::once_flag` 证函数在多线程环境下只能被调用一次

四种[互斥锁](https://subingwen.cn/cpp/mutex/)类：
std::mutex：独占的互斥锁，不能递归使用
std::timed_mutex：带超时的独占互斥锁，不能递归使用
std::recursive_mutex：递归互斥锁，不带超时功能
std::recursive_timed_mutex：带超时的递归互斥锁

`std::lock_guard`模板类用于对锁进行包装，在构造时自动加锁，析构时自动解锁



两种[条件变量](https://subingwen.cn/cpp/condition/)：
`condition_variable`：需要配合 std::unique_lock< std::mutex > 进行 wait 操作，也就是阻塞线程的操作。
`condition_variable_any`：可以和任意带有 lock()、unlock() 语义的 mutex 搭配使用

`std::unique_lock`模板类，一般配合条件变量使用，条件变量的wait等成员函数需要输入一个unique_lock包装后的锁。比lock_guard更灵活，有自己的成员函数进行加锁解锁，而lock_guard只能在构造和析构的时候加减锁

[`std::atomic<T>`](https://subingwen.cn/cpp/atomic/)原子类型，通过原子类型管理的内部变量就为原子变量，如 std::atomic_int 等（底层为CAS循环，即Compare and Swap）

> 在c++20中，`std::atomic<T>`增加了新的功能函数：wait()、notify_one()、notify_all()，与条件变量中的功能一致，因此可以用原子类型来阻塞线程



[`std::future`](https://subingwen.cn/cpp/async/#1-std-future)模板类可以通过和其他类配合，在主线程中得到某个子线程任务函数返回的结果

`std::promise`是一个协助线程赋值的模板类，它能够将数据和 future 对象绑定起来，为获取线程函数中的某个值提供便利。

`std::packaged_task`模板类包装了一个std::function对象，可以将包装的函数和future类绑定到一起。std::packaged_task<函数类型>

`std::async`模板函数比上面两个要更高级，可以直接启动一个子线程并在这个子线程中执行对应的任务函数

**可调用对象包装器**

[`std::function`](https://subingwen.cn/cpp/bind/#1-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1)类模板是可调用对象的包装器，可以容纳除了类成员（函数）指针之外的所有可调用对象。

`std::bind`用来将可调用对象与其参数一起进行绑定



### ==如何检测内存泄漏==

**内存泄漏**：

​	内存泄漏(memory leak) 是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

​	当所消耗的资源达到系统的上限时，程序自己会崩溃，严重者甚至会导致系统崩溃

***

**c++中常见的内存泄漏场景**：

**（1）堆内存泄漏 （Heap leak）。**malloc、realloc、new 后没有调用对应的 free 或者 delete 删掉，或在delete前发生异常且没被捕获，则这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak 。

**（2）系统资源泄露（Resource Leak）**。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

***

Linux**查看内存泄漏的命令**

ps或者top命令查看程序的内存使用情况

***

常见的**内存问题**一共七种：

1. 动态内存泄露；2. 资源泄露，比如文件指针不关闭；3. 动态内存越界；4.数组内存越界；5.动态内存double free；6.使用野指针，即未初始化的指针；7.释放野指针，即未初始化的指针。

***

内存泄漏工具：[valgrind](https://zhuanlan.zhihu.com/p/75328270)

​	如 Valgrind工具里面有一个 memchek 功能可以检测

​	对于一个编译好的可执行文件(gcc/g++并且加上-g选项)，可以采用命令行的方式进行内存检查，比如我想检查TestFaceDetection程序是否有问题，可以用以下命令：

```
 valgrind --tool=memcheck ./TestFaceDetection --leak-check=full
 // --tool=memcheck进行内存检查
 // --leak-check=full可以进一步获取内存泄漏的信息
```

![img](E:\MarkDown\picture\v2-4ada719ff11fb524dfa7b156d4809c3d_1440w.webp)

***

ASAN，gcc自带，可以用来解决内存泄漏问题。

***

不使用工具，如何检测内存泄漏：

​	通过[重载 operator new 的方法](https://www.zhihu.com/question/29859828/answer/1798470821)可以检测new和delete引起的内存泄漏问题，以及智能指针使用不当引起的内存泄漏

```cpp
void* operator new(std::size_t size, const char* file, int line);
void* operator new[](std::size_t size, const char* file, int line);
```

​	通过对new使用宏定义，让底层程序申请内存时调用重载的这个函数。有了这个宏定义后，在new A的时候底层就会自动调用operator new(std::size_t size, const char* file, int line)函数，至此达到了我们记录内存申请位置的目的。

```cpp
#define new new (__FILE__, __LINE__)
```



### 深浅拷贝

​	一个类若在构造函数中分配动态内存，则需要定义一个析构函数来释放内存。此时如果没有定义自己的拷贝构造函数和拷贝赋值运算符，则编译器会构造一个默认的拷贝构造函数，仅拷贝了指针，则会出现多个对象指向相同内存的情况，在析构时就会进行多次delete，造成了堆区内存的重复释放，这就是浅拷贝。解决办法就是自己定义好拷贝构造函数和拷贝赋值运算符，在其中再开辟一块堆区存放数据

​	需要析构函数的类，几乎可以肯定它也需要拷贝构造函数和拷贝赋值运算符。因此通常管理类外资源的类必须定义拷贝控制成员。（（例外是基类的析构函数，它需要设定为虚函数，但不一定需要拷贝操作））





### float存储小数

float在内存中占4字节，32-bit。浮点型在内存中，有3部分构成：

* 符号位（Sign bit）
* 指数位（Exponent）
* 尾数位（Mantissa)

<img src="E:\MarkDown\picture\image-20230813152549328.png" alt="image-20230813152549328" style="zoom:60%;" />

如：9.125 = 2^3 +2^0 +2^(-3)，其二进制形式为：1001.001，二进制形式科学计数法为1.001001 * 2^3

此时，float数据9.125的存储形式为：

* 符号位为0

* 以科学计数法表示时，指数为3，因此指数位为：3+127=130，二进制形式为：1000 0010
* 其小数部分为001 001，因此尾数部分保存数据为001 001，其余位以0补充

因此，9.125的内存存储形式二进制结果位：0 10000010 00100100000000000000000



### switch与if else的区别

* switch/case需要建立一张跳转表，因此需要一定的空间的，更像是以空间换效率。当case常量分布范围很大但实际有效值又比较少的情况，switch…case的空间利用率将变得很低。
* if/else能进行逻辑判断，而switch不行,因此在需要进行逻辑判断时使用if/else语句；
* switch/case只支持整数类型和枚举类型：int、long和枚举类型，其中byte、short、char都可以隐含转换为int，因此switch支持的数据类型为：byte、short、char，int、long和枚举类型，不支持：boolean、float、double；
  if/else支持更多的数据类型，如string, double等；
* 在条件比较多时，swich的执行效率更高

### 强制类型转换cast

> 强制类型转换(cast)，要尽量避免使用强制类型转换

命名的强制类型转换：cast-name<type>(expression);
type：目标类型 expression：要转换的值；
cast-name：static_cast、dynamic_cast、const_cast、reinterpret_cast



**reinterpret_cast**

​	将一个指针或引用转换为另一个不相关类型的指针或引用

**static_cast**

​	只要不包含底层const，就可以使用static_cast进行强制类型转换

**const_cast**

​	可以对指针或引用去掉或加上const属性。只有const_cast可以改变表达式的常量属性。
​	比如可以将 const int *p 去掉const后赋给 int *p
​	使用const_cast去掉const属性，其实并不是真的改变原类型(或基本类型)的const属性，它只是又提供了一个接口(指针或引用)，使你可以通过这个接口来改变类型的值。也许这也是const_case只能转换指针或引用的一个原因吧。

**dynamic_cast**

​	dynamic_cast支持运行时类型识别，用于将基类的指针或引用安全地转换成派生类的指针或引用。如果在基类中有一个或多个虚函数，可以使用dynamic_cast请求一个类型转换，该转换的安全检查将在运行时执行

```cpp
// dynamic_cast<派生类*>(基类)
if (Derived *dp = dynamic_cast<Derived*>(bp)) {
	// 使用dp指向的Derived对象
}
```

​	如果我们已知某个基类向派生类的转换是安全的，则我们可以使用 **static_cast** 来强制覆盖掉编译器的检查工作。

​	尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然(显式或隐式地)定义了拷贝控制成员。因此，我们通常**能够将一个派生类对象拷贝、移动或赋值给一个基类对象**。不过需要注意的是，这种操作**只处理派生类对象的基类部分**
​	当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉，即将一个派生类对象赋值给基类对象后，这个基类对象的构造函数只处理了基类部分，派生类部分被切掉了

```cpp
Bulk_quote bulk;  // 派生类对象
Quote item(bulk);  // 使用Quote::Quote (const Quote&)构造函数
item = bulk;  // 调用Quote::operator= (const Quote&)
```

### x64内存对齐

​	按结构体中size最大的成员对齐

​	对齐可以提高CPU的计算速度，因为可以一次性将数据读出来，而不需要额外的操作。假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块，剔除不想要的字节（0地址），然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器，这需要做很多工作。现在有了内存对齐，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。



### 结构体和类的区别

> struct和class的区别

* 默认的访问权限不同。class类中的成员默认是private属性的；struct结构体中的成员默认是 public 属性的；
* class继承默认是private继承，而struct继承默认是public继承；
* class以使用模板，struct不能使用模板。



**在 C 语言中：**

* struct只能包含成员变量，不能包含成员函数。
* C 中的结构体没有构造函数、析构函数、继承、访问控制等类似面向对象编程的特性。

**在 C++ 中：**

* 在 C++ 中，你可以使用 `struct` 来定义类，拥有封装、继承、多态等面向对象编程的特性。
* 结构体的定义也可以放在函数内部，使得结构体作用范围局限于函数内部。
* 可以在 `struct` 内部定义构造函数、析构函数，以及其他成员函数。



附：struct初始化方式

C语言里面的struct的初始化只有一种方式

```c++
struct stuinfo {
   char *name;
   int age;
};
struct stuinfo students[2] = {{"xiaowang",12}, {"xiaoli",22}};
```

C++里面的struct初始化有两种方式

方法一：按照C里面的方式     方法二：利用构造函数

```c++
struct stuinfo {
   std::string name;
   int age;
   stuinfo() {}
   stuinfo(std::string m_name, int age) : name(m_name), age(m_age) {}
};
stuinfo students[2] = {{"xiaowang", 12}, stuinfo("xiaoli", 22)}；
```

















### lambda表达式

* 匿名函数可以免去函数的声明和定义。这样匿名函数仅**在调用函数的时候才会创建函数对象**，而调**用结束后立即释放**，所以匿名函数比非匿名函数`更节省空间`
* 相比于定义一个可能只使用一次，且找其实现比较麻烦的函数对象类，**使用 Lambda 表达式可以减少程序中函数对象类的数量**，使得程序更加优雅。
* lambda表达式作为可调用对象，存储在栈区
* 一个比较广泛的用途是与STL中的函数结合使用

```cpp
[外部变量访问方式说明符] (参数表) -> 返回值类型 {
	语句块
}
[=] (int x, int y) -> bool {return x%10 < y%10; }

int a[4] = {11, 2, 33, 4};
sort(a, a+4, [=](int x, int y) -> bool { return x%10 < y%10; } );
for_each(a, a+4, [=](int x) { cout << x << " ";} );
```

​	线程池结束，即线程池结束的时候，会通过条件变量的wait以及lambda表达式，等线程池中所有的线程执行完后，再销毁线程池对象

### 访问修饰符

private、protected、public关键字

* public:无论是类内类外成员还是继承的类都是可以访问的
* protected 类外不可访问
* private 只有类内可访问

这些都可以被友元函数访问



通常将一些变量设为private，然后提供public的接口来操作

可以**通过using声明改变派生类继承的某个名字的访问级别**

​	在类的内部使用using声明语句，using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。如果一条using声明语句出现在类的private部分,则该名字只能被类的成员和友元访问;如果using声明语句位于public部分，则类的所有用户都能访问它;如果using声明语句位于protected部分，则该名字对于成员、友元和派生类是可访问的。



c# 额外的两个：

internal：内部访问修饰符，只能在同一程序集内访问该成员

protected internal：在同一程序集内以及该类的派生类访问该成员



### C语言中的字符串

[C语言中的字符串](https://www.runoob.com/cprogramming/c-strings.html)

### main函数执行前后

![image-20230524214508420](E:\MarkDown\picture\image-20230524214508420.png)

`__attribute__` 可用于为函数或者数据声明赋属性值。给函数分配属性的主要目的是为了让编译程序可以优化处理。分配给函数的属性位于函数原型的声明中。

* `__attribute__((constructor))` 先于main()函数调用
* `__attribute__((destructor))`在main()函数后调用

```cpp
#include<bits/stdc++.h>

__attribute__((constructor)) void before() {
    printf("before main\n");
} 

__attribute__((destructor)) void after() {
 printf("after main\n");
}

int main() {
    printf("main\n");
    return 0;
}
```



### 递归和循环的效率

* 通常来说循环更快，因为递归的实现是调用函数，每次调用都需要做地址保存、参数传递，参数传递要进行压栈等，会有一些额外的开销
* 然而，在 C++11 中引入的尾递归优化可以减少递归的额外开销，从而提高递归的效率。尾递归指的是在递归函数的最后一行代码中调用自身，此时编译器可以将其优化为循环实现，从而避免了额外的函数调用开销。在实现递归算法时，考虑使用尾递归可以提高代码的效率。

> 尾递归优化
>
> reference:https://zhuanlan.zhihu.com/p/47876964

```cpp
double fabonacci(int n) { //normal recursion
    if(n<=0) {
        cout<<"wrong parameter for fabonacci(n)!"<<endl;
    } else if(n==1) return 1;
    else if(n==2) return 1;
    else return fabonacci(n-1) + fabonacci(n-2);
}
```

上面这个算法的时间复杂度是 O(2^n)，比如

fab(6)

= fab(5) + fab(4)

= fab(4) + fab(3) + fab(3) + fab(2)

= fab(3) + fab(2) + fab(2) + fab(1) + fab(2) + fab(1) + fab(2)

= fab(2) + fab(1) + fab(2) + fab(2) + fab(1) + fab(2) + fab(1) + fab(2)

```cpp
double tail_fabonacci(int a, int b, int n) {  // tail recursion
    if(n<0) cout<<"wrong parameter for tail_fabonacci(int, double *)!"<<endl;
    else if(n==0) return a;
    else if(n==1) return b;
    else return tail_fabonacci(b, a+b, n-1);
}
```

写成这种形式，就能进行尾递归优化



阶乘

```cpp
int frac_re(int n) {  // 递归
    if (n == 0) return 1;
    else if (n == 1) return 1;
    else return n * frac_re(n - 1);
}

int frac_it(int n) {  // 迭代
    if (n == 0) return 1;
    if (n == 1) return 1;
    int ret = 1;
    for (int i = 2; i <= n; ret *= i++);
    return ret;
}

int frac_tr(int n, int ret = 1) {
    if (n == 0) return ret;
    else if (n == 1) return ret;
    else return frac_tr(n - 1, n * ret);
}
```

斐波那契数列

```cpp
int fib_it(int n) {  // 迭代
    if (n == 0) return 0;
    if (n == 1) return 1;
    int ret = 1, a = 1, b = 0;
    for (int i = 2; i <= n; i++)
    {
        ret = a + b; b = a; a = ret;
    }
    return ret;
}

int fib_re(int n) {  // 递归
    if (n == 0) return 0;
    else if (n == 1) return 1;
    else return fib_re(n - 1) + fib_re(n - 2);
}

int fib_tr(int n, int ret = 0, int tmp = 1) {  // 尾置递归
    if (n == 0) return ret;
    else return fib_tr(n - 1, ret + tmp, ret);
}
```

由于斐波那契数列的特殊性，使得他可以被改造成线性递归



* 无论递归语句是放在if的上半句还是下半句，-O2都会进行尾递归优化；换为switch也一样

```cpp
unsigned factorial_if_1(unsigned x, unsigned r) {
    if (x == 0) 
        return r;
    else
        return factorial_if_1(x-1, x*r);
}

unsigned factorial(unsigned x)
{
    return factorial_if_1(x, 1);
}
```



> gcc编译优化——-O[s123]

```cpp
// 使用方法一：将这句代码放到程序的开头位置
#pragma GCC optimize(1)
#pragma GCC optimize(2)  // 如这里是O2
#pragma GCC optimize(3)
#pragma GCC optimize(3, "Ofast", "inline")
// 使用方法二：编译时加上-O[s123]
g++ test.cpp -O2
```

​	On(n＝0,1,2,3,也可以是其它单词)是gcc为了一般人方便而做的设定，根据n值大小包含预设好一些优化选项，均为-fxxx(xxx为优化项)，但注意，即使是最高优化选项-O3，也不是包含所有的-f选项，这只是为大多数人的使用方便而预设的。

* O0不做任何优化，这是默认的编译选项。
* O/O1的目的都是在不影响编译速度的前提下，尽量采用一些优化算法降低代码大小和可执行代码的运行速度。主要对代码的分支，常量以及表达式等进行优化。 
* O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。`打开O2后，stl里大量的函数都被inline了，故而比原来快好多，毋庸置疑，stl没有inline基本上是威力全无，切记。`
* O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。 
* Os主要是对代码大小的优化。-O3的目标是宁愿增加目标代码的大小，也要拼命的提高运行速度，但是这个选项是在-O2的基础之上，尽量的降低目标代码的大小，这对于存储容量很小的设备来说非常重要。
* 其他还有Ofast和Og





### 判断点p是否在三角形内

按顺时针判断每条线与点p的横向的交点，奇数则在内



### 判断x是否是2的n次方

```cpp
if (x & (x - 1) == 0 && x != 0) { return true; }
```



### 强弱符号

> ​	这种弱符号与弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的[库函数](https://so.csdn.net/so/search?q=库函数&spm=1001.2101.3001.7020)，或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起的时，功能模块就可以正常使用。如果我们去掉某些模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更加容易裁剪和组合。

​	强弱符号用于指定链接器如何处理全局函数或全局变量的重复定义。

​	强符号指程序中定义的全局变量或函数，在编译的时候会分配一个固定的内存地址。如果同时有强符号和弱符号，链接器会优先选择强符号的定义；当一个强符号被定义多次时，链接器会报错。

​	弱符号在编译时不会分配一个固定的内存地址，而是在**链接**时根据需要进行分配。当一个弱符号被定义多次时，链接器会选择其中一个定义，通常是选择最后一个被编译的定义，并忽略其他定义。

​	弱符号通常用来定义一些可选的函数或变量，若程序中没有定义强符号，链接器会选择弱符号的定义。可以使用extern来指定弱符号`extern int x;`



​	比如两个全局变量都命名为a，若一个进行了初始化，那么这个是强符号；另一个没有初始化，则这个是弱符号。或者两个重名的函数，编译时候可能会报重定义错误，那么可以通过weak属性声明，此时编译是没问题的，但是链接阶段会报错。

```cpp
//func.c
int a = 1; // 强符号
int b; // 弱符号
void func(void)
{
    printf("func：a = %d\n", a);  // 1
    printf("func: b = %d\n", b);  // 2
}

//main.c
int a; // 弱符号
int b = 2; // 强符号
void func(void);
int main(void)
{
    printf("main：a = %d\n", a);  // 1
    printf("main: b = %d\n", b);  // 2
    func();
    return 0;
}
```



​	在一个工程中，不能同时定义两个同名的强符号，即初始化的全局变量或函数，否则就会报重定义错误。但是我们可以使用 GNU C 扩展的 weak 属性，将一个强符号转换为弱符号。

通过__attribute__声明weak属性，可以将一个强符号转换为弱符号：

```cpp
__attribute__((weak)) void func(void);
__attribute__((weak)) int num;
```







### 函数调用约定

> 百度看了一下大概就是`__cdecl、__stdcall、__fastcall、__pascal、__thiscal`

函数调用约定对两个方面进行了约定：

* 按什么顺序将参数入栈，比如一般是从右向左，这样最左边的参数将第一个出栈
* 函数调用后，由调用者还是被调用者负责将参数出栈



### Linux排查异常

> linux开发时候怎么去定位错误调试的？
>
> 看日志、打断点、gdb

​	比如死锁，就是测试程序出现了堵塞，然后 `ps -aux | grep a.out` 看了下a.out对应的进程，发现这个程序处在休眠状态，就感觉应该是死锁了，且CPU和内存占用都是0，**可以排除是死循环的问题**，因为死循环会造成CPU使用率居高不下，而且线程的状态也不会是S。

使用gdb attach PID来调试正在运行的程序

```shell
# 将gdb attach到一个PID号中
gdb attach PID
```

* bt：查看函数调用栈的所有信息，当程序执行异常时，可通过此命令查看程序的调用过程；

* info threads：显示当前进程中的线程；

* thread id：切换到具体的线程id，一般切换到具体的线程后再执行bt等操作。
* **thread apply ID1 ID2 command** 让一个或者多个线程执行GDB命令command。 

```shell
# 查看所用线程堆栈信息
thread apply all bt
```

之后发现这个子线程堵塞在了notify_all中



### windows排查异常

> windbg、任务管理器

​	只有华为那个项目是在windows下开发的，通常报错都能显示到行号，比较容易排查和定位，一般打log、打断点等都能解决。

​	其他有改动程序出错导致exe的进程无法结束的情况，通过任务管理器（Ctrl+Shift+ESC）发现是exe的资源没有释放，杀掉后改动程序就好了。

​	其他的话也可以使用windbg等工具，对exe文件进行调试，查看进程的调用栈等。



### windows下的异常机制和处理

​	从信号源的角度来讲，异常大体可以分为两类：**软件异常**和**硬件异常**。前者由操作系统/应用程序引发，后者由CPU引发。

​	异常和中断的区别在于，中断可以在任何时候发生，和CPU正在执行什么指令无关，可以被取消。而异常是由于CPU执行了某条指令而引起的，不能被取消。

**软件异常：**

​	由操作系统/应用程序引发，比如C++关键字throw、Windows API函数的RaiseException。软件异常归根结底都是基于 RaiseException 这个用户态API和 NtRaiseException 的内核服务建立起来的。

**硬件异常：**

​	硬件异常是由CPU发现的异常，比如说除零异常、内存访问异常。基本可以分为三类，错误异常、陷阱异常、终止异常。

* 错误异常fault：处理错误异常时，操作系统首先保护当前环境（上下文），然后然后调用相应的异常处理函数，如果异常处理成功则恢复现场环境继续执行。

* 陷阱异常trap：和错误异常不同，陷阱异常发生时会保存要执行的下一条指令的环境（而不是正在执行的指令的环境），在处理异常后，直接执行导致异常的指令的下一条指令，调试器的断点就是基于陷阱异常实现的。

* 终止异常abort：主要用来处理严重的硬件错误，和上面的异常不同，这种异常不会恢复执行而是直接退出。

> 在windows系统中，硬件异常和中断被不加区分的存放在了一个向量表中，即IDT(interruption descriptor table)，可以使用windbg的!idt指令查看IDT。

***

**异常处理**：

异常产生时，CPU是通过IDT（中断描述符表）进入内核来寻找处理函数：

* 当内核可以处理这个异常时，异常处理程序执行完后会恢复现场并继续执行，这个过程应用程序感知不到。
* 当内核不能处理这个异常时，如果该异常来自内核，则蓝屏；如果该异常来自应用程序，则异常处理权转交给应用程序的异常处理函数，程序如果处理了该异常则程序继续执行，没有处理则崩溃。

​	则将异常信息连同线程上下文环境送入程序的栈中，并调用 `KiUserExceptionDisptcher `（由 ntdll 导出，所有的异常分发都会走这个函数），但实际发挥作用的是 `RtlExceptionDisptcher`，如果该接口返回成功，则调用 ZwContinue 继续执行，否则调用 ZwRaiseException 结束进程。

​	硬件异常会通过IDT（中断描述符表）去调用异常处理例程（一般为KiTrap系列函数）。  软件异常则是通过API的层层调用传递异常的信息。但无论是硬件异常还是软件异常，最后都会走到 `KiDispatchException`。如果程序被调试，则异常处理权限转交给调试器。如果调试器处理了这个异常则程序继续执行，如果没有处理则将异常处理权限转交给应用程序。如果程序没有被调试，那么则调用`RtlDispatchException`函数进行异常处理。

#### RtlExceptionDisptcher

其具体工作如下：

​	首先遍历 VEH 链表，逐个执行异常处理器，一旦某个处理器处理成功则返回成功，线程继续运行。如果 VEH 链表遍历完毕异常仍然没有被处理则遍历 SEH 链表，再逐个执行 SEH 的异常处理器一旦某个处理器处理成功则返回成功，线程继续运行。如果 VEH 和 SEH 都没有处理这个异常，则进程结束。





> windows 提供了三种异常处理方式，**结构化异常处理**(SEH)、**向量化异常处理**(VEH、VCH)、**顶级异常处理**(TopLevelEH)。

**结构化异常处理（SEH）：**

​	SEH是基于线程的一种处理机制，依赖于栈进行存储和查找，所以也被称作是基于栈帧的异常处理机制（只能处理自己线程的异常，而不是像VEH那样可以影响整个进程）。

​	可以把SEH理解为高级语言的（try-catch），它的作用就是构造一个SEH节点，并将该节点放入SEH链表头部。在从 C/C++ 中，可以使用 `__try 和 __expect` 来处理 windows 的 SEH 异常，还可以使用`SetUnhandledExceptionFilter`注册一个异常处理函数。

​	当一个异常产生，且`__try 和 __expect`没有处理处理这个异常时，异常会转交给`SetUnhandledExceptionFilter`。但是如果存在调试器，则调试器就会接管这个异常，那么异常就不会走`SetUnhandledExceptionFilter`注册的异常处理函数（调试器默认情况下是接管的）。

**向量化异常处理（VEH、VCH）：**

在每个进程的 `ntdll.dll` 中有一张 VEH 链表， 可以向其中添加一个节点来注册自己的异常处理器，使用`AddVectordExceptionHandler`函数。

VCH 和 VEH 类似，但是只会在异常被处理的情况下，最后调用。

**顶级异常处理（TopLevelEH）：**

本质上也是 SEH，在最顶层的SEH中，可以注册一个顶层异常处理器（和 SEH 不同的是它可以影响所有的线程）。

当 SEH 链表中的异常处理器都处理不了某个异常，在最顶层的SEH中就会检查是否注册了顶层异常处理，如果注册了顶级异常处理器，就会给 SEH “最后一次处理异常的机会” ，把异常抛给 TopLevelEH（但如果程序被调试时就会忽略 TopLevelEH）。

**各异常之间的关系**

1. 当异常交由用户处理时，按照以下顺序调用异常处理方式 VEH -> SEH -> VCH。
2. 当 VEH 表示处理了异常，就不会传递给 SEH，但是会传递异常给 VCH。
3. 当 VEH 没有处理了，就会传递给 SEH。
4. 当 SEH 的所有异常处理函数没能够处理异常，会调用默认的 SEH （就是 UEH，只是方式属于SEH）处理函数。
5. 当 SEH 处理了异常，从 except 开始执行，就不会再将异常传递给 VCH。
6. 当 SEH 返回异常产生处执行，在返回之前会调用 VCH。

```c++
┌─────┐ unable  ┌─────┐ unable  ┌─────┐  unable  ┌─────┐
│ VEH ├────────►│ SEH ├────────►│ UEH ├─────────►│ VCH │
└──┬──┘ handle  └──┬──┘ handle  └─────┘  handle  └──▲──┘
   │               │            handle              │
   │               └────────────────────────────────┤
   │            handle                              │
   └────────────────────────────────────────────────┘
```







### 框架设计要考虑哪些因素

* 理清功能需求及如何实现
* 要能返回错误信息，从而让我们能够据此清晰快速地定位问题位置并纠正
* 控制代码量，对于一些重复的代码，封装成函数或使用多态等简化。
* 交互性，方便操作人员的使用，比如线程池项目提交任务的接口，其使用和thread相同；而像rpc项目，其发布就稍微麻烦些，服务发布方需要定义proto文件来描述方法及请求响应类型、继承protobuf生成的基类并重写基类方法，即可将本地方法发布为远程RPC方法。但对于rpc方法的调用就比较简单，初始化框架后，定义请求和相应，调用rpc函数就能得到响应值
* 解耦，减少类之间的依赖关系，提高程序的可维护性和可扩展性
* 进行性能优化，提高程序性能
  * 避免不必要的内存分配，尽可能用栈上的内存
  * 减少函数调用次数，比如使用inline函数等
  * 使用编译器优化选项





### 解耦

如何实现代码之间的解耦，解耦的好处是什么

* 使用设计模式等
* 封装和抽象。可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。
* 单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。
* 中间层：引入中间层能简化模块或类之间的依赖关系。

​	如图，在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰。

![image-20230809213915991](E:\MarkDown\picture\image-20230809213915991.png)



* 模块化
  	不同的模块之间通过 API 来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样将各个模块组装起来，构建成一个超级复杂的系统。
  	对于每个模块，只提供封装了内部实现细节的接口给其他模块使用，这样可以减少不同模块之间的耦合度。

https://www.cnblogs.com/ukzq/p/14821268.html

## 移动语义



### 右值

> 右值在模板编程有哪些应用

* 移动语义：可以用于实现移动语义
* 完美转发：forward
* 可以在STL容器中使用，避免不必要的拷贝

### 移动语义

​	std::move显式地将一个左值转换为对应的右值引用类型，进而可以调用移动构造函数等操作

```cpp
template<typename T>
typename remove_reference<T>::type&& move (T&& t) {
    return static_cast<typename remove_reference<T>::type&&>(t);
}
```



**为什么需要移动操作**

>  * 在有些情况下，如重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。比如可以加速容器操作，对容器的效率有大幅度的改善。特别是对于容器增长
>  * IO类或unique_ptr这样的类，都包含不能被共享的资源（如指针或IO缓冲），因此这些类型的对象不能拷贝，但可以移动。（补充：标准库容器、string和shared_ptr类既支持移动也支持拷贝）



### 完美转发

> ​	当函数参数传入右值时，函数内便会分配栈空间来保存传参。此时的右值已经被传参中的变量名所指向，所以再次传入此右值时，实际传入的是指向它的变量名，即一个左值。所以会出现上图中传参为右值但是直接转发却为左值的情况。

forward就可以不改变左值/右值特性

```cpp
// 接收左值
template <typename T>
constexpr T&& forward(typename std::remove_reference<T>::type& param) {
    return static_cast<T&&>(param);
}
// 接收右值
template <typename T>
T&& forward(typename std::remove_reference<T>::type&& param) {
    return static_cast<T&&>(param);
}
```





## 内存管理

### 内存泄漏

**内存泄漏**：

​	内存泄漏(memory leak) 是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

​	当所消耗的资源达到系统的上限时，程序自己会崩溃，严重者甚至会导致系统崩溃

***

**c++中常见的内存泄漏场景**：

**（1）堆内存泄漏 （Heap leak）。**malloc、realloc、new 后没有调用对应的 free 或者 delete 删掉，或在delete前发生异常且没被捕获，则这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak 。

**（2）系统资源泄露（Resource Leak）**。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

***

Linux**查看内存泄漏的命令**

ps或者top命令查看程序的内存使用情况

***

常见的**内存问题**一共七种：

1. 动态内存泄露；2. 资源泄露，比如文件指针不关闭；3. 动态内存越界；4.数组内存越界；5.动态内存double free；6.使用野指针，即未初始化的指针；7.释放野指针，即未初始化的指针。

***

内存泄漏工具：[valgrind](https://zhuanlan.zhihu.com/p/75328270)

​	如 Valgrind工具里面有一个 memchek 功能可以检测

​	对于一个编译好的可执行文件(gcc/g++并且加上-g选项)，可以采用命令行的方式进行内存检查，比如我想检查TestFaceDetection程序是否有问题，可以用以下命令：

```
 valgrind --tool=memcheck ./TestFaceDetection --leak-check=full
 // --tool=memcheck进行内存检查
 // --leak-check=full可以进一步获取内存泄漏的信息
```

![img](E:\MarkDown\picture\v2-4ada719ff11fb524dfa7b156d4809c3d_1440w.webp)

***

ASAN，gcc自带，可以用来解决内存泄漏问题。

***

不使用工具，如何检测内存泄漏：

​	通过[重载 operator new 的方法](https://www.zhihu.com/question/29859828/answer/1798470821)可以检测new和delete引起的内存泄漏问题，以及智能指针使用不当引起的内存泄漏

```cpp
void* operator new(std::size_t size, const char* file, int line);
void* operator new[](std::size_t size, const char* file, int line);
```

​	通过对new使用宏定义，让底层程序申请内存时调用重载的这个函数。有了这个宏定义后，在new A的时候底层就会自动调用operator new(std::size_t size, const char* file, int line)函数，至此达到了我们记录内存申请位置的目的。

```cpp
#define new new (__FILE__, __LINE__)
```



### 限制类的对象只能建立在堆/栈上

​	在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* p = new A；这两种方式是有区别的。

​	静态建立一个类对象，是由**编译器**为对象在**栈**空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。使用这种方法，直接调用类的构造函数。

​	动态建立类对象，是使用**new**运算符将对象建立在**堆**空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。

#### 限制类只能建立在堆上

> 将构造和析构函数设为protected，然后在类内部实现一个new和delete的接口
>
> 通过new和delete实现将对象建立在堆上

```cpp
class A {
protected:
    A(){}
    ~A(){}
public:
    static A* create() {
        return new A();
    }
    void destory() {
        delete this;
    }
};
int main()
{
	A* p = A::create();
	p->destory();
}
```

#### 限制类只能建立在栈上

> 重载new函数设为私有
>
> 只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可。代码如下：

```cpp
class A  
{  
private:  
    void* operator new(size_t t){}  // 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr){}  // 重载了new就需要重载delete  
public:  
    A(){}  
    ~A(){}  
};
```



### new和malloc区别

> [malloc简单介绍](https://blog.csdn.net/zstuyyyyccccbbbb/article/details/123166028)

相同点：都能用于内存的动态申请和释放

**属性的区别**

new/delete：这两个是C++中的关键字，若要使用，需要编译器支持；

malloc/free：这两个是库函数，若要使用则需要引入相应的头文件<cstdlib>才可以正常使用。

**使用上的区别**

malloc：申请空间需要显式填入申请内存的大小；

new：无需显式填入申请的内存大小，new会根据new的类型分配内存

```cpp
#include<cstdlib>
int* a = (int*)malloc(4);  // (int*)是强制类型转换为指向int的指针
free(a);
a = NULL;  // “free(p)”释放的是指针变量 p 所指向的内存，而不是指针变量 p 本身。指针变量 p 并没有被释放，仍然指向原来的存储空间。因此，在释放内存后，必须把指针指向 NULL，以防止指针在后面不小心又被解引用了。

int* a = new int(4);
delete a;
```

**内存位置的区别**

* new：分配的内存空间是在自由存储区；
* malloc：申请的内存是在堆空间。
* 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete或free语句才能正确的释放本内存空间。

**返回类型的区别/类型安全**

* new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。

* malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。所以在C++程序中使用new会比malloc安全可靠。

```cpp
int* a = (int*)malloc(4);  // (int*)是强制类型转换为指向int的指针

int *p = new float[2];  // 编译错误
int *p = (int*)malloc(2 * sizeof(double));  // 对返回的dobule*强制类型转换为int*，编译⽆错误
```

**分配失败情况的区别**

* malloc分配内存失败时返回NULL，我们可以通过判断返回值可以得知是否分配成功；
* new内存分配失败时，会抛出bad_alloc异常，它不会返回NULL，分配失败时如果不捕捉异常，那么程序就会异常退出，我们可以通过异常捕捉的方式获取该异常。

```cpp
int *p = new int;  // 若无可用内存导致分配失败，会抛出一个类型为bad_alloc的异常
// 定位new，允许我们向new传递额外的参数
int *p = new (std::nothrow) int;  // 传递给new一个由标准库定义的nothrow对象，不会抛出异常，只返回一个空指针
```



**定义对象系统调度过程的区别**

new简单类型直接调用operator new分配内存；使用new操作符来分配对象内存时会经历三个步骤：

* 调用operator new 函数（对于数组是operator new[]）分配一块足够的内存空间（通常底层默认使用malloc实现，除非程序员重载new符号）以便存储特定类型的对象；
* 编译器运行相应的构造函数以构造对象，并为其传入初值。
* 对象构造完成后，返回一个指向该对象的指针。

delete简单数据类型默认只是调用free函数；使用delete操作符来释放对象内存时会经历两个步骤：

* 调用对象的析构函数。
* 编译器调用operator delete(或operator delete[])函数释放内存空间（通常底层默认使用free实现，除非程序员重载delete符号）

malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数。在对⾮基本数据类型的对象使⽤的时候，对象创建的时候还需要执⾏构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的  

**扩张内存大小的区别**

malloc：使用malloc分配内存后，发现内存不够用，那我们可以通过realloc函数来扩张内存大小，realloc会先判断当前申请的内存后面是否还有足够的内存空间进行扩张，如果有足够的空间，那么就会往后面继续申请空间，并返回原来的地址指针；否则realloc会在另外有足够大小的内存申请一块空间，并将当前内存空间里的内容拷贝到新的内存空间里，最后返回新的地址指针。

new：new没有扩张内存的机制。

**重载**

C++允许重载new/delete操作符，特别的placement new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回地址。malloc不允许重载。



> new和malloc失败分别返回什么?

new失败会抛出bad_alloc异常（内存不足时会抛出），可以使用try-catch语句捕获异常并处理`catch(const std::bad_alloc& e) { std::cerr << e.what(); }`

malloc会返回一个空指针，可以通过判断返回值是否为空

### malloc底层实现

* 检查当前内存池中是否有足够空闲内存，有则分配并返回指针。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序
* 若无空闲内存，则发起系统调用，请求分配一块新的内存空间
  * malloc小于128k的内存，使用 `brk` 分配内存，将堆的结束地址_edata向高地址方向移动，即增大了堆空间；
  * malloc大于128k的内存，使用 `mmap` 分配内存，在内存映射区内存地址的增长方向是由高地址向低地址增长，mmap_base 定义内存映射区的起始地址；
  * 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；
  * brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。
* malloc将新的内存空间加入到内存池中，并分一块给程序使用



* 被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。





### **RAII**

* RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.
* 在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定
* RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子





### 堆溢出

* 使用 `new` 运算符分配一段非常大的内存空间。如果分配的内存空间超出了堆的容量，就会发生堆溢出错误。比如new一个很大的数组。
* new很多个对象（如new很多个到一个数组里）；或者一个类在构造函数里new一个空间，没写析构函数，然后创建了若干个对象。

```shell
# 报错：
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
```

### 栈溢出

> 如何写一段代码使得栈溢出，还有什么其他的方法吗（不断new 小对象），不断创建线程会导致栈溢出吗（我说的不会，因为栈是线程独有的）

**栈**：由编译器自动分配和释放，用于存放函数调用时的参数、**局部变量**以及函数调用的返回地址等信息。

​	栈溢出指的是在程序中的栈空间中写入过多的数据，导致数据覆盖了栈空间的边界，进而覆盖了一些关键数据，比如返回地址、函数参数和局部变量等。这通常是由于递归调用函数、大量使用局部变量或者缓冲区溢出等引起的。栈溢出可能导致程序崩溃、内存泄漏等问题。

* 递归调用时递归层数过多或递归没有出口

* 定义很多局部变量或者比较大的拘数组

* 通过memcpy函数也可以实现栈溢出。函数的返回地址等也都存放在栈中，可以通过memcpy将返回地址处的内容覆盖，实现栈溢出攻击。调用 `memcpy()`、`strcpy()` 等函数复制数据时，没有对数据的长度进行验证，从而 `返回地址` 被复制的数据覆盖了。

  

### 讲讲堆栈

**从 c++ 内存分区来说堆区和栈区**

* c++的内存分区从上到下是高地址到低地址，栈的位置在最顶端，从高地址向低地址增长；堆的位置是从低地址向高地址的方向增长；
* 栈是由编译器自动分配和释放，保存的是局部变量、函数调用时的参数、返回地址等信息；堆是程序员通过new等手动分配和释放。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收；
* 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。堆区的分配和释放速度较慢，但其大小和生命周期一般比较灵活，可以根据实际需要进行调整；
* 内存管理：对于**堆**，系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）；对于**栈**，只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出；
* 空间大小：堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，因此不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大；栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在编译时确定， VC中可设置），linuxx下4M；
* 碎片问题：对于堆，频繁的new/delete会造成大量碎片，使程序效率降低；对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一 对应，不会产生碎片。

**从数据结构方面来说堆和栈**

栈是stack，先入后出。是一个容器适配器，底层是deque，不提供迭代器

堆是heap，可以看作是一种特殊的完全二叉树。所有父结点都比子结点要小的完全二叉树我们称为最小堆，堆顶为最小值。反之，如果所有父结点都比子结点要大，这样的完全二叉树称为最大堆。cpp中堆的实现是优先队列priority_queue。堆的实现的话，底层默认是vector，也可以改为deque。堆的实现有两个重点，一是索引，可以看作是将一个二叉树存储在数组中，这样一个结点的左结点就是i * 2+1，右节点就是i*2+2；二是下沉和上浮操作。比如构建大顶堆，就需要让小的元素下沉

> 堆和栈的速度

![image-20230524224723032](E:\MarkDown\picture\image-20230524224723032.png)

> C++中一般是不能使用变量作为一个数组的长度的，必须使用常量

数组作为C++的内置数据类型，其空间分配在**栈内存**中，这部分空间的大小在**编译时就要确定**，不能等到运行时再分配。常量的值在编译时就能得到，而变量的值在运行时才能确定。

但是仍然有办法使用变量作为数组的长度：绕过栈内存，**将数组空间开辟在堆空间内**：`int* vec = new int[n]`

> 栈怎么用数组来实现  

vector的话通过vec.back()、vec.push_back()、vec.size()等实现

数组的话需要额外定义一个栈顶变量

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

```cpp
class MyStack {
public:
    int stack[100];  // 假设栈中最多 100 个元素
    int MAX_SIZE = 100;
    int tag = -1;  // 栈顶
    MyStack() {}
    
    void push(int x) {
        if (tag >= MAX_SIZE - 1) {
            cout << "Stack overflow!" << endl;
            return;
        }
        tag++;
        stack[tag] = x;
    }
    
    int pop() {
        if (tag < 0) {
            cout << "Stack underflow!" << endl;
            return -1;
        }
        return stack[tag--];
    }
    
    int top() {
        if (tag < 0) {
            cout << "Stack underflow!" << endl;
            return -1;
        }
        return stack[tag];
    }
    
    bool empty() {
        if (tag == -1) return true;
        return false;
    }
};
```

### 栈的大小

> 栈的大小的确定？一个函数的栈的大小取决于什么？函数栈是在什么期间确定？

**栈**：由编译器自动分配和释放，用于存放函数调用时的参数、**局部变量**以及函数调用的返回地址等信息。

​	栈溢出指的是在程序中的栈空间中写入过多的数据，导致数据覆盖了栈空间的边界，进而覆盖了一些关键数据，比如返回地址、函数参数和局部变量等。这通常是由于递归调用函数、大量使用局部变量或者缓冲区溢出等引起的。栈溢出可能导致程序崩溃、内存泄漏等问题。

* 递归调用时递归层数过多或递归没有出口

* 定义很多局部变量或者比较大的拘数组

* 通过memcpy函数也可以实现栈溢出。函数的返回地址等也都存放在栈中，可以通过memcpy将返回地址处的内容覆盖，实现栈溢出攻击。调用 `memcpy()`、`strcpy()` 等函数复制数据时，没有对数据的长度进行验证，从而 `返回地址` 被复制的数据覆盖了。

  

  栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

编译选项会对内存进行优化：比如内存对齐； 递归调用，会创建新的函数帧来占栈的内存。

### 队列和栈的区别及实现

队列先进先出，栈先进后出

队列和栈的实现，一般底层都是deque，这两个为容器适配器，功能只是deque的子集。并且不提供iterator，因为会破坏容器先进后出、先进先出的性质。因此也没有find等算法

栈实现队列：一个输入栈和一个输出栈
队列实现栈：对于pop操作，仅需要将队列头部的元素（除了最后一个元素外）全部重新添加到队列尾部，此时在去弹出元素



### malloc之后怎么在里面创建一个指针变量

指向void的指针。这一类型被用作“通用指针”。将void 指针值赋值给其他类型的指针并不构成类型冲突。

因此只有malloc时用void*类型保存，再将void *转换为Int**即可

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	void* ptr = malloc(sizeof(int*)); // 分配一个指向 int* 类型的指针变量的内存空间
	int** p = (int**)ptr; // 将 void* 类型的指针强制转换为 int** 类型的指针
    cout << p << endl;  // 0xe61938
    cout << ptr << endl;  // 0xe61938
	*p = (int*)malloc(sizeof(int)); // 在分配的内存空间中创建一个指向 int 类型的指针变量
	**p = 10; // 在分配的内存空间中存储一个 int 类型的值
	cout << ptr << endl;  // 0xe61938
	cout << p << endl;  // 0xe61938
	cout << *p << endl;  // 0xe61830
}
```



## 编译

### c和c++编译区别

目标文件中的符号表是不同的，因为支持函数重载和运算符重载，会编译成func_int_int这样的形式。这会导致在链接的时候，C和C++会存在冲突



### 编译四阶段

词法分析、语法分析、语义分析、代码生成

词法分析：将代码分解为一个个单词并分类。

语法分析：得到语法树

语义分析：分析语法树，检查代码是否符合语义规则

代码生成：将语法树转换为汇编代码，最终生成可执行文件

### 动态联编和静态联编

动态联编即运行时绑定，即动态多态

静态联编即编译时绑定，即静态多态



### 静态链接和动态链接

链接分为静态链接和动态链接，两者最大的区别就在于链接的时机不一样，静态链接是在形成可执行程序前，而动态链接则是在程序执行时



#### 静态链接

​	使用静态库进行链接，静态库就是函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。



​	静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

* 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
* 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

<img src="E:\MarkDown\picture\image-20230311150520736.png" alt="image-20230311150520736" style="zoom:60%;" />

> 为什么要进行静态链接？
> 	在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即每个*.c文件会形成一个*.o文件，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。这个链接的过程就是静态链接
>
> 优缺点：
> **空间浪费**：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
> **更新困难**：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
> **运行速度快**：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

#### 动态链接

​	动态链接使用动态链接库进行链接，基本思想是把程序按照模块拆分成各个相对独立部分，在程序`运行`时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

>为什么会出现动态链接？

​	动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。

>动态链接的过程：

​	假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是**将内存中已经存在的lib.o映射到program2的虚拟地址空间中**，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。

>优缺点：

* **共享库**：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；
* **更新方便**：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标；
* **性能损耗**：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。据估算，动态链接和静态链接相比，性能损失大约在5%以下。经过实践证明，这点性能损失用来换区程序在空间上的节省和程序构建和升级时的灵活性是值得的。

### 静态库和动态库

静态库

* 优点：

  * 静态库被打包到应用程序中加载速度快

  * 发布程序无需提供静态库，移植方便

* 缺点：
  * 相同的库文件数据可能在内存中被加载多份，消耗系统资源，浪费内存
  * 库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间。

动态库

* 优点：
  * 可实现不同进程间的资源共享
  * 动态库升级简单，只需要替换库文件，无需重新编译应用程序
  * 程序猿可以控制何时加载动态库，不调用库函数动态库不会被加载
* 缺点：
  * 加载速度比静态库慢，以现在计算机的性能可以忽略
  * 发布程序需要提供依赖的动态库

> 改变动态链接库中的哪一部分代码会导致重新编译

​	如果修改了动态库的代码，只需要重新编译动态库就可以了而无需重新编译我们自己的程序，因为可执行文件当中仅仅保留了动态库的必要信息，重新编译动态库后这些必要都信息是不会改变的，编译好新的动态库后只需要简单的替换原有动态库，下一次运行程序时就可以使用新的动态库了。

​	但如果修改了动态库的名字和动态库导出的供可执行文件使用的函数，则需要重新编译我们自己的代码。

### 如何生成静态库和动态库

> .a是静态库，.so是动态库

**静态库**

方法一：

先将源文件编译为.o文件，再执行` ar -rcs libxxx.a a.o b.o`，其中库名一般以.a为扩展名，以lib开头。-rcs是ar的参数

方法二：

```shell
# 编译的时候指定库信息
-L: 指定库所在的目录(相对或者绝对路径)
-l: 指定库的名字, 掐头(lib)去尾(.a) ==> xxx
# -L -l, 参数和参数值之间可以有空格, 也可以没有  -L./ -lcalc
gcc main.c -o app -L ./ -l xxx
```

**动态库**

将threadpool.cpp文件编译为动态库libxxx.so

```shell
g++ -fPIC -shared threadpool.cpp -o libxxx.so -std=c++17
```

* -fPIC：表示编译为位置独立的代码，不用此选项的话，编译后的代码是位置相关的，所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。
* -shared：指明编译成动态库。

### 链接顺序

​	gcc 中库的链接顺序是从左到右，即先链接依赖库，再链接被依赖库，因此被依赖的静态库需要放在后面的位置，这样左边的库就可以调用右边库的代码。

# 项目

> linux用过哪些命令 

## 项目相关

> 面向对象你是怎么设计的

面向对象的三大特性是封装、继承、多态

首先根据项目的需求，确定需要哪些类和对象，以及他们之间的继承等关系，然后对于每个类，确定其属性和方法，以及访问权限，最后实现代码。

> 为什么用future而不是回调函数？

有些场景，需要我们的线程执行任务提供返回值，此时就需要给Task类的run函数设置一个返回结果。而这个返回结果，根据不同的需求可能是不同的类型。因此想到可以用模板。但注意，run是虚函数，虚函数是不能和模板写在一起的

> 如果有时候偶然的数据出现问题，怎么排查？或者说常规的方法还能不能用？

就分析一下出问题的可能是哪个部分，然后进行调试

查看日志

> 有没有抓包分析过

https://xiaolincoding.com/network/3_tcp/tcp_tcpdump.html#%E8%A7%A3%E5%AF%86-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B

> 网卡接收数据包过程

​	将物理层传来的数据信号转换为数字信号；检查MAC地址，看是否是自己需要接收的；如果是，读取头部信息，一般会调用TCP/IP协议栈进行处理

* 网卡驱动程序提取这个帧的全部内容，去掉以太网的帧头，然后向上传递给IP层
* IP层接收到包，继续去掉IP头的内容，然后交给TCP层
* TCP层根据TCP协议定义的格式，继续解包，read()从socket buffer读取数据，然后传递给应用层
* 应用层根据TCP层传来的数据，按照对应的应用层来分析包

> 代码量

统计工具：cloc，下载后打开命令行窗口，输入 `cloc 目录`，即可统计代码行数、注释行数等

线程池项目：三百多行

rpc项目：一千行左右

华为项目：1.7K

> 详细说一下RPC的流程

> webserver有没有考虑一个线程挂了对服务器的影响

​	线程没有独立的地址空间，如果崩溃，会发信号，如果没有错误处理的handler，OS一般直接杀死进程。就算是有handler了处理，一般也会导致程序崩溃，因为很有可能其他线程或者进程的数据被破坏了。

> 发生死锁可能是哪些因素造成的，可能的原因

[死锁的四个条件](https://xiaolincoding.com/os/4_process/deadlock.html)

* **互斥条件**；即多个线程不能同时访问同一个资源
* **持有并等待条件**；即一个线程已经持有了资源1，又需要获取资源2，但资源2被另一个线程持有，则线程就进入到了持有资源1且处于等待的状态
* **不可剥夺条件**；线程持有资源后，在自己使用完之前不能被其他线程获取
* **环路等待条件**：两个线程获取资源的顺序构成了环形链，即A持有1等待2，B持有2等待1

因此想要避免死锁，只需要破坏其中一个条件，比如使用资源有序分配法，即线程以相同的顺序申请想要的资源

​	一次死锁是在写完资源回收这部分的代码的时候，运行程序发现死锁了。之后分析代码发现是因为逻辑上有点问题，主线程堵塞等待子线程进行析构，子线程又提前进入了while（running)的循环堵塞在了里面



> 介绍下 WebServer 项目以及主要改进点



实现难点等



现在要对日志文件进行每秒十几万行的写入，如何提升你的日志库性能

> 如何定位Bug

log日志加打断点等



> 多线程之间怎么通信

线程池中是有任务队列和线程map，实现了个生产者消费者模型，通过信号量唤醒线程

webserver中主线程和子线程的通信通过eventfd

* EventLoop类的成员变量：shared_ptr包装的 `Poller` 指针，包装了epoll；int型的`event_fd_`（在EventLoop的构造函数中初始化）用于进程间通信，用于异步唤醒SubLoop的Loop函数中的Poll(epoll_wait因为还没有注册fd会一直阻塞)；shared_ptr包装的`Channel`，这是event_fd的channel；线程ID；锁；`vector<Function>`存放等待处理的函数；
* mainReactor向subReactor分配连接是轮询，而主Reactor如何唤醒从Reactor？因为这些Reactor都是堵塞的，堵塞在epoll_wait上等待新事件的发生。这里通过**eventfd**实现
* 初始化poller，event_fd，给event_fd设置事件以及读写操作的回调函数，并将event_fd注册到epoll中
  * 文件描述符有socket fd、pipe fd等很多种，而**eventfd**就是事件fd。[详解](https://zhuanlan.zhihu.com/p/393748176)
  * eventfd是一个专门用于事件通知的文件描述符，可以被用于一个事件的wait/notify，不仅可以用于进程间的通信，还能用于用户态和内核态的通信。
  * eventfd 是一个计数相关的fd。计数不为零是有可读事件发生，`read` 之后计数会清零，`write` 则会递增计数器。（注意要设置为非堵塞
  * 这里的主要作用是当主Reactor获取一个新用户的channel，通过轮询算法选择一个从Reactor，**通过eventfd唤醒 从Reactor**。（具体是写了个函数，向eventfd中写入数据，比如写入个1。需要唤醒注册有eventfd的从Reactor时就调用这个函数，使从Reactor解除堵塞）解除堵塞后，从Reactor就可以执行正在等待的函数，即处理连接套接字及其绑定事件的函数

> 非阻塞IO怎么判断数据是否准备好

​	这里采用了epoll的边沿触发模式，epoll_wait()检测到文件描述符有新事件才会通知，有新数据达到只会通知一次，那么必须要保证得到通知后将数据全部从读缓冲区中读出。通常采用循环接收数据的方式，将数据全部从读缓冲区中读出。

​	因为套接字操作默认是阻塞的，当读缓冲区数据被读完之后，读操作就阻塞了，当前线程被阻塞之后就无法处理其他操作了。要解决阻塞问题，就需要**将套接字修改为非阻塞**，需要使用 fcntl() 函数进行处理







