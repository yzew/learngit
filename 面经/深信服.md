# 笔试

https://www.nowcoder.com/discuss/400398173057957888?sourceSSR=search

**1. 公约数**

**2. 入侵主机（贪心）**

**3. 包含最长1个数的子串（可能不止一个答案，用vector存，最后求和就行）**





第一题用一个双端队列模拟就行了，赢K次就行。 

第二题复杂度是O(n²)，获取每一段区间的最大值和最小值，如果差等于区间的长度减一，就记录下结果，取最大值。(保证严谨的话可以用哈希表检测重复，但是用例里并没有重复数字)

第三题复杂度是O(n)，从头遍历数组，记录下最大值和最小值，如果差大于2x，结果加一，并且重新记录最值。





之前看深信服往年笔试只有编程，结果他搞偷袭，来了一堆选填！ 

  一、选择题 

  1.c++容器array，deque我只记得有这两个 

  2.sleep函数的作用 

  3.线性结构有哪些 

  4.二叉排序树、 

  5.执行态与就绪态的转换 

  6.char数组 

  7.宏定义 

  8.正则表达式（a|b)*c+[^0-9] 

  9.表达式为真。int a=6869,int b==6976,然后一堆判断的，不太懂 

  10.&的运用 

  二、填空 

  1.网络字节序特指？ 

  2.（unsigned short int)(-1234) 

  3.中序 

  4.int a 最低有效位起算第三个字节的数值 

  5.数学题 

  6.后缀表达式 

  7.static 局部变量未初始化，然后++问输出值。。 

  8.（a=w>x&&b=y>z)之后a与b的值 

  9.sizeof内存对齐？ 

  10.fun（&ptr）之类的 

  三、编程 

  1.k轮胜者 

  vector erase不行吗？后面手动实现了一下 

  2.最长连续排序数目 

  随机快排加单指针遍历过90 

  dp能过100 

  3.区间交集数目 

  贪心10min秒了。









算法A卷

第一题：日志分析   

   一组攻击先后包含 s w r。现有 T 份日志，每份是一个小写字母字符串，需要从每份日志里，统计有多少种可能的潜在攻击。   

   输入：正整数 T，紧接着是 T 行日志   

   输出：T 行，每个日志的潜在攻击数。需要对 1e9+7 取模   

  


  解法：这题相当于查找字符串中有多少个 "swr" 子序列。用**动态规划**比较高效，否则有些大测试点估计过不了 

  考虑如下三个动态规划函数： 

* ​    dp_s。其中 dp_s[i] 代表字符串的前 i 个字符，有多少个子序列 "s"。      
* ​    dp_sw。其中 dp_sw[i] 代表字符串的前 i 个字符，有多少个子序列 "sw"。       
* ​    dp_swr。其中 dp_swr[i] 代表字符串的前 i 个字符，有多少个子序列 "swr"。      

  状态转移，需要看字符串的第 i 位是什么。**比如是 'r'，那么它可以额外提供的 "swr" 子序列数量即为** **dp_sw****[i]**。其余同理，因此状态转移函数总结如下： 

* ​    如果字符串的第 i 位是 's'，则 dp_s[i] = dp_s[i - 1] + 1，否则 dp_s[i] = dp_s[i - 1]       
* ​    如果字符串的第 i 位是 'w'，则 dp_sw[i] = dp_sw[i - 1] + dp_s[i]，否则 dp_sw[i] = dp_sw[i - 1]       
* ​    如果字符串的第 i 位是 'r'，则 dp_swr[i] = dp_swr[i - 1] + dp_sw[i]，否则 dp_swr[i] = dp_swr[i - 1]      

 注意到，每个函数只有最后一个值会被用到，因此**可以用滚动数组节省空间**。 

  我只用了 s w r 三个变量表示循环中的三个函数值。最终输出 dp_swr[n] % (1e9+7)  的值即可。 

```py3
T = int(input())
for _ in range(T):
    info = input()
    s = w = r = 0
    for i in range(len(info)):
        if info[i] == 's':
            s += 1   # 遍历到第i位时，s表示 dp_s[i]的值，下同
        elif info[i] == 'w':
            w += s
        elif info[i] == 'r':
            r += w
    print(int(r % (1e9+7)))
```

   第二题：深信服旅游   

   有 T 组测试数据。每组包含正整数 n，表示员工数。之后是 n 行，每行两个正整数a, b，表示一位员工方便旅游的时间段为 [a, b]。问最多可以同时让多少位员工觉得方便。   

   输入：正整数 T。之后 T 组数据，每组先输入正整数 n；然后是 n 行，每行两个正整数   

   输出：T行，每组测试数据的结果   

   备注：O(n^2)的算法可得一半分，O(nlogn)的算法可得满分   


​    

   解法：贪心算法  

   对于每组数据，分别用数组A， B记下来所有的开始时间和所有的结束时间，**并不需要考虑它们来自于哪位员工**。将它们升序排列。  

   *为什么不需要考虑它们来自哪个员工呢？*   

   *因为我们只关注每个区间的**进入**和**退出**。比如两个区间 (1,4)+(2,3)，实际上和 (1,3)+(2,4) 是没有区别的。*   

   我们要做的，是给定这些区间的首尾值，判断最多有多少个区间重合。  

   遍历数组A，**每次找到 A[i]，相当于有一个区间开始**。我们还要查看这时有多少区间已经结束。因此需要在数组B中维护一个动态指针p（p表示当前有多少个区间已经结束）。如果当前p指向的结束时间小于 A[i]，说明**当前的区间已经结束**，需要不断将p右移。操作完成后，**p 和 i 的下标差加1即为当前区间的重合数**。  

   最后，每步中找到的区间重合数去一个最大值即为所求。  

```py3
T = int(input())
for _ in range(T):   #  T组测试数据
    n = int(input())
    A, B = [], []
    for __ in range(n):     # 每组数据n个员工
        a, b = [int(x) for x in input().split()]
        A.append(a)
        B.append(b)
    A.sort()
    B.sort()
    p = ans = 0
    for i in range(n):
        while p < n and A[i] > B[p]:
            p += 1
        ans = max(ans, i - p + 1)
    print(ans)
```

​    第三题：五进制    

​    设定一种五进制，其中 o, y, e, a, s 分别代表 0, 1, 2, 3, 4。例如五进制 ya 代表十进制 8。    

​    有 T 组测试数据。每组包含一个数字，或字母oyeas组成的字符串。实现进制的相互转换，并输出每个测试数据的转换结果。    

​    输入：正整数 T。之后 T 行，每行一个【五进制字母串】或【十进制数】    

​    输出： T 行，给定测试如果是五进制，则输出十进制数；给定测试如果是十进制，则输出五进制字符串    

​    
​     

​    压轴题反而是最简单的，跟二进制转化没啥区别。   

​    十进制转五进制，每次对5取模，得到最低位，然后将数字除以5，直到数字变为零；   

​    五进制转十进制，遍历字符串。长度为 n 的字符串，第 i 位是x，则它的贡献为 x * 5 ^ (n - i - 1)。循环求和即可   

```py3
import math
T = int(input())
for _ in range(T):
    ipt = input()
    if ipt.isdigit():
        if ipt == '0':
            print('o')
            continue
        ans = ''
        ipt = int(ipt)
        while ipt > 0:
            ans = 'oyeas'[ipt % 5] + ans
            ipt //= 5
        print(ans)
    else:
        ans = 0
        for i in range(len(ipt)):
            ans += 'oyeas'.index(ipt[i]) * math.pow(5, len(ipt) - i - 1)
        print(int(ans))
```



作者：觞乄默
链接：https://www.nowcoder.com/discuss/394966541228408832?sourceSSR=search
来源：牛客网



# 面试





面试有手撕



一面

1、自我介绍 

  2、手撕最小栈 

  3、map时间复杂度，自定义类能插入到红黑树吗 

  4、unordered_map的时间复杂度，自定义类能插入到哈希表吗（围绕map和unordered_map说了很多）  

  5、两个string类型的内容相同放到哈希表同一个位置吗


  6、归并时间复杂度？有没有时间复杂度小于O(n)的  

  7、排序的稳定性指的是什么？  

  8、拷贝构造函数和赋值运算符？如果是指针调用哪个  

  9、传入指针和传入对象哪个开销大？  

  10、默认构造函数是自带的吗  

  11、http用的什么传输层协议  

  12、TCP怎么保证可靠传输  

  13、UDP怎么保证可靠传输 

  14、Linux怎么查看进程状态 

  15、Linux怎么查看系统监控哪个端口 

  16、gdb调试，设置断点、逐行调试指令、如何查看堆栈信息 

  17、vim？怎么退出，怎么跳到最后一行，怎么查找字符 

  注：漏了挺多，拷贝构造那块问了挺多，map和unordered_map也问了挺多，其他有一些忘记了





1.简单介绍一下自己，包括说一下项目； 

  2.你这个创业项目最后上线了吗？ 

  3.JSON解析器里面如果遇到多层嵌套应该怎么解决的？比如对象里面嵌套对象数组（JSON解析器是我的项目） 

  4.C++智能指针 

  5.shared——pointer的应用场景 

  6.weak——pointer的应用场景 

  7.用过二叉树吗？写一个 

  8.找到二叉树的最小路径（从根节点到叶子节点的最小路径和，leetcode的老题了） 

  场景题： 

  9.给你一个字符串库，找出特定的字符串，你应该怎么去设计（我先答了哈希表，说内存要小，我就说前缀树） 

  10.什么是前缀树？ 

  11.如果是汉语句子呢？从中找出一个特定的句子（我说还是用前缀树，把汉语句子当中的汉字的首字母作为前缀树去存，在多个句子为同一节点上，可以用链表或者二叉树去存，遍历。面试官说这不是最好的，应该减少遍历，可以用汉字的编码，每四位为一个单位去进行前缀查找，深度虽然增加了，但还是logn的复杂度，更快） 

  12.你有什么想问我的吗？ 

补充问题:

1.vector底层扩容机制

2.pushback一定会引起扩容吗？

3.vector里面是字符串的话，如何存储的？



作者：美丽的迪恩希望被offer砸中
链接：https://www.nowcoder.com/discuss/402507420667310080?sourceSSR=search
来源：牛客网





![image-20230905114924195](E:\MarkDown\picture\image-20230905114924195.png)

