### 线程池初期的功能测试

> 此阶段的线程池，对于线程执行任务函数，是没有返回值的
>
> 如对于一个网络程序，主线程是IO线程，负责新用户链接，产生一个套接字给子线程，每个子线程都是一个epoll，此时子线程只需要去做已连接的用户的读写事件即可，此时不需要获取线程执行任务的返回值

#### threadpool.cpp

```cpp
// threadpool.cpp
#include"threadpool.h"

const int TASK_MAX_THRESHHOLD = 9;

ThreadPool::ThreadPool()
	: initThreadSize_(4)
	, taskSize_(0)
	, taskQueMaxThreshHold_(TASK_MAX_THRESHHOLD)
	, poolMode_(PoolMode::MODE_FIXED)
{}

ThreadPool::~ThreadPool() {

}

// 设置线程池工作模式
void ThreadPool::setMode(PoolMode mode) {
	poolMode_ = mode;
}

// 任务相关
// 设置task任务队列上限阈值
void ThreadPool::setTaskQueMaxThreshHold(int threshhold) {
	taskQueMaxThreshHold_ = threshhold;
}

// 开启线程池，并设置初始的线程数量
void ThreadPool::start(size_t initThreadSize) {
	initThreadSize_ = initThreadSize;

	// 创建线程对象
	for (size_t i = 0; i < initThreadSize_; i++) {
		// 创建thread线程对象的时候，需要把线程函数给到thread类
		// 这样在Thread::start中才能启动这个线程函数
		// 通过构造函数，将threadFunc放进去
		// 这里我们使用bind。对于类的成员函数，前面要取个地址
		// 且需要绑定一个类对象才能使用，这里绑定了this即当前对象
		// 这里使用智能指针创建线程对象，让其能自动析构
		auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::threadFunc, this));  // c++14
		// 使用move将左值转换为对应的右值引用类型
		threads_.emplace_back(std::move(ptr));
		// unique_ptr是不允许拷贝构造的，仅支持一个智能指针指向它
		// 因此 emplace_back(ptr) 的操作会报错
		// unique_ptr虽然关闭了左值引用的拷贝和赋值，但支持右值引用的操作！
	}

	// 启动所有线程
	for (size_t i = 0; i < initThreadSize_; i++) {
		// 注意，这里threads_[i]是指针
		// 调用了线程类里的start函数创建并启动线程
		threads_[i]->start();
	}
}

// 在线程池类中定义线程函数，由线程类执行
// 线程函数需要的那些锁和条件变量，都定义在线程池中
// 这里线程函数若是定义在Thread类中，则不方便访问ThreadPool里的那些私有的锁和条件变量
// 因此将线程函数定义在ThreadPool类中
void ThreadPool::threadFunc() {
	/*std::cout << "begin threadFunc tid:" << std::this_thread::get_id() << std::endl;
	std::cout << "end threadFunc tid:" << std::this_thread::get_id() << std::endl;*/
	for (;;) {
		// 注意，我们仅需要在取任务的时候获取锁，取到任务后释放锁，再执行任务
		std::shared_ptr<Task> task;
		{
			// 获取锁
			std::unique_lock<std::mutex> lock(taskQueMtx_);

			std::cout << "tid:" << std::this_thread::get_id()
				<< "尝试获取任务!" << std::endl;

			notEmpty_.wait(lock, [&]()->bool {return !taskQue_.empty(); });

			std::cout << "tid:" << std::this_thread::get_id()
				<< "成功获取任务!" << std::endl;

			task = taskQue_.front(); taskQue_.pop();
			taskSize_--;

			// 为什么用了两个条件变量呢，这便于进行更精细的操作
			// 如果任务队列仍有任务，则通知其他wait在notEmpty_的线程执行任务
			if (taskQue_.size() > 0) {
				notEmpty_.notify_all();
			}
			
			// 通知 wait在notFull_上的生产者，可以继续提交任务
			notFull_.notify_all();
		}  // 取完任务，释放锁
		if (task != nullptr) task->run();

		
	}

}



/////////////////////////////////// 线程方法实现
Thread::Thread(ThreadFunc func)
	: func_(func)
{}
Thread::~Thread() {

}
// 启动线程
void Thread::start() {
	// 创建线程
	// ThreadPool::start函数创建了thread，传入了func_
	// 因此创建线程的时候直接把func_放进去就行
	// 这里thread的构造函数通过完美转发将参数传递给线程函数
	
	std::thread t(func_);
	// 注意，若是将线程函数写到Thread类中，则应该写为
	// std::thread t(&Thread::threadFunc, &thread1);
	// thread1表示一个线程对象，相应的start函数也应该有形参：start(Thread& thread1)

	// 注意，这个线程对象t出了这个作用域就会自动销毁
	// 因此要设置为分离线程，使得此线程变为守护线程，驻留后台运行
	t.detach();

	// 执行一个线程函数
}
// 给线程池提交任务
// 生产者：获取锁，while(满) {wait}，提交任务，notify_all
void ThreadPool::submitTask(std::shared_ptr<Task> sp) {
	// 获取锁
	std::unique_lock<std::mutex> lock(taskQueMtx_);

	// 线程的通信 等待任务队列有空余
	// 没有空余才等待，因此需要等待notFull_
	// 这里使用了lambda表达式的隐式捕获的引用捕获，让编译器根据函数体中代码推断捕获列表
	//// notFull_.wait(lock, [&]()->bool {return taskQue_.size() < taskQueMaxThreshHold_; });
	// 与下面三行等价
	//while (taskQue_.size() == taskQueMaxThreshHold_) {
	//	notFull_.wait(lock);
	//}
	// 增加一个要求：用户提交任务，最长不能阻塞超过1s，否则判断提交任务失败，返回
	// wait()：一直等待到条件满足；wait_for()：等一段时间；wait_until()：等到一个时间点
	/*notFull_.wait_for(lock, std::chrono::seconds(1), [&]()->bool {return taskQue_.size() < taskQueMaxThreshHold_; });*/
	if (!notFull_.wait_for(lock, std::chrono::seconds(1), [&]()->bool {return taskQue_.size() < taskQueMaxThreshHold_; })) {
		// 等待1s，条件仍不满足
		std::cerr << "task queue is full, submit task fail." << std::endl;
		return;
	}

	// 有空余，将任务放入任务队列
	taskQue_.emplace(sp);
	taskSize_++;

	// 任务队列不空，通知notEmpty_
	notEmpty_.notify_all();
}
```

#### threadpool.h

```cpp
// threadpool.h
#ifndef THREADPOOL_H
#define THREADPOOL_H
// 使用 #ifndef 而非 #pragma once ，因为后者需要编译器支持，在linux下不支持
#include<iostream>
#include<vector>
#include<queue>
#include<memory>  // 智能指针
#include<atomic>  // 原子类型，实现线程互斥
#include<mutex>  // 锁
#include<condition_variable>  // 条件变量，实现线程通信
#include<functional>
#include<thread>

//////////////////////////////    任务抽象基类
class Task {
public:
	// 用户可以自定义任意任务类型，从Task继承，重写run方法，实现自定义任务处理
	virtual void run() = 0;
};


// 线程池支持的模式
// 这里使用了限定作用域的枚举类型
// 使用时必须显示的访问，PoolMode p = PoolMode::MODE_FIXED;
enum class PoolMode {
	MODE_FIXED,  // 固定数量的线程
	MODE_CACHED,  // 线程数量可动态增长
};


//////////////////////////////////   线程类型
class Thread {
public:
	// 线程函数对象类型，为function函数对象
	using ThreadFunc = std::function<void()>;

	Thread(ThreadFunc func);
	~Thread();
	void start();
private:
	ThreadFunc func_;
};


///////////////////////////////////   线程池类型
/*
example:
ThreadPool pool;
pool.start(4);

class MyTask : public Task
{
	public:
		void run() { // 线程代码... }
};

pool.submitTask(std::make_shared<MyTask>());
*/
class ThreadPool {
public:
	ThreadPool();
	~ThreadPool();
	// 禁止线程池的拷贝和复制
	ThreadPool(const ThreadPool&) = delete;
	ThreadPool& operator=(const ThreadPool&) = delete;

	// 设置线程池模式
	void setMode(PoolMode mode);

	// 开启线程池，并设置初始的线程数量
	void start(size_t initThreadSize = 4);

	// 任务相关
	// 设置task任务队列上限阈值
	void setTaskQueMaxThreshHold(int threshhold);
	// 给线程池提交任务
	void submitTask(std::shared_ptr<Task> sp);

private:
	// 定义线程函数
	void threadFunc();
private:
	
	// 线程相关
	// 线程列表。对于线程的创建，是在ThreadPool::start中new出来的，还需要delete
	// 因此直接使用智能指针。线程的话unique就行
	std::vector<std::unique_ptr<Thread>> threads_;
	size_t initThreadSize_;  // 初始的线程数量。size_t增强了可移植性，表示任何对象所能达到的最大长度
	// 需要使用基类的指针或引用才能实现多态
	// 而用户传入的通常会是临时的一个任务对象，出了submitTask语句后就析构了，用指针指向一个析构了的对象是没有意义的
	// 而我们是需要考虑来保持这个任务的生命周期的，当这个任务run执行以后在析构
	// 因此需要使用智能指针
	std::queue<std::shared_ptr<Task>> taskQue_;  // 任务队列
	std::atomic_uint taskSize_;  // 任务的数量。考虑到线程安全问题，使用轻量化的原子类型实现线程互斥
	size_t taskQueMaxThreshHold_;  // 任务队列数量的上限

	// 实现线程通信
	std::mutex taskQueMtx_;  // 保证任务队列的线程安全
	std::condition_variable notEmpty_;  // 任务队列不空
	std::condition_variable notFull_;  // 任务队列不满

	PoolMode poolMode_;  // 当前线程池的工作模式
};

#endif // !THREADPOOL_H

```

test.cpp

```cpp
#include"threadpool.h"
#include<chrono>

class MyTask : public Task
{
public:
	void run() {
		std::cout << "tid:" << std::this_thread::get_id()
			<< "begin!" << std::endl;
		std::this_thread::sleep_for(std::chrono::seconds(5));
		std::cout << "tid:" << std::this_thread::get_id()
			<< "end!" << std::endl;
	}
};

// 
// 此时线程池设置4个线程。每个任务执行5s，提交若干个任务后，会有一些任务提交失败（等待超过了1s）

int main() {
	ThreadPool pool;
	pool.start(4);
	pool.submitTask(std::make_shared<MyTask>());
	pool.submitTask(std::make_shared<MyTask>());
	pool.submitTask(std::make_shared<MyTask>());
	pool.submitTask(std::make_shared<MyTask>());
	pool.submitTask(std::make_shared<MyTask>());
	pool.submitTask(std::make_shared<MyTask>());
	pool.submitTask(std::make_shared<MyTask>());
	pool.submitTask(std::make_shared<MyTask>());
	pool.submitTask(std::make_shared<MyTask>());
	getchar();
}
```

const int TASK_MAX_THRESHHOLD = 4;

任务列表设为了最大四个任务

<img src="E:\MarkDown\picture\image-20230313121159346.png" alt="image-20230313121159346" style="zoom:80%;" />

const int TASK_MAX_THRESHHOLD = 9;

任务列表设为了最大9个任务

<img src="E:\MarkDown\picture\image-20230313121326128.png" alt="image-20230313121326128" style="zoom:80%;" />

### 阶段二

threadpool.cpp

```cpp
#include"threadpool.h"

const int TASK_MAX_THRESHHOLD = 9;

//////////////////////  Task方法实现
Task::Task(): result_(nullptr) {}
// 在task对应的result类进行构造的时候调用，将新创建的result绑定到当前的task上
// 即为task中指向Result的成员变量result_赋值，之后就可以通过这个指针，将task的结果存到Result对象中了
void Task::setResult(Result* res) {
	result_ = res;
}
void Task::exec() {
	// run，并将任务的返回值保存在Result类中
	if (result_ != nullptr) {
		result_->setVal(run());  // run在这里发生多态调用
	}
}

//////////////////////  线程池方法实现
ThreadPool::ThreadPool()
	: initThreadSize_(4)
	, taskSize_(0)
	, taskQueMaxThreshHold_(TASK_MAX_THRESHHOLD)
	, poolMode_(PoolMode::MODE_FIXED)
{}

ThreadPool::~ThreadPool() {}

// 设置线程池工作模式
void ThreadPool::setMode(PoolMode mode) {
	poolMode_ = mode;
}

// 任务相关
// 设置task任务队列上限阈值
void ThreadPool::setTaskQueMaxThreshHold(int threshhold) {
	taskQueMaxThreshHold_ = threshhold;
}

// 开启线程池，并设置初始的线程数量
void ThreadPool::start(size_t initThreadSize) {
	initThreadSize_ = initThreadSize;

	// 创建线程对象
	for (size_t i = 0; i < initThreadSize_; i++) {
		// 创建thread线程对象的时候，需要把线程函数给到thread类
		// 这样在Thread::start中才能启动这个线程函数
		// 通过构造函数，将threadFunc放进去
		// 这里我们使用bind。对于类的成员函数，前面要取个地址
		// 且需要绑定一个类对象才能使用，这里绑定了this即当前对象
		// 这里使用智能指针创建线程对象，让其能自动析构
		auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::threadFunc, this));  // c++14
		// 使用move将左值转换为对应的右值引用类型
		threads_.emplace_back(std::move(ptr));
		// unique_ptr是不允许拷贝构造的，仅支持一个智能指针指向它
		// 因此 emplace_back(ptr) 的操作会报错
		// unique_ptr虽然关闭了左值引用的拷贝和赋值，但支持右值引用的操作！
	}

	// 启动所有线程
	for (size_t i = 0; i < initThreadSize_; i++) {
		// 注意，这里threads_[i]是指针
		// 调用了线程类里的start函数创建并启动线程
		threads_[i]->start();
	}
}

// threadFunc负责在线程池中获取并执行任务
// 在线程池类中定义线程函数，由线程类执行
// 线程函数需要的那些锁和条件变量，都定义在线程池中
// 这里线程函数若是定义在Thread类中，则不方便访问ThreadPool里的那些私有的锁和条件变量
// 因此将线程函数定义在ThreadPool类中
void ThreadPool::threadFunc() {
	// 所有任务必须执行完成，线程池才可以回收所有线程资源
	// 相当于while(true)。线程执行threadFunc后便一直在此函数中尝试获取任务
	for (;;) {
		// 注意，我们仅需要在取任务的时候获取锁，取到任务后释放锁，再执行任务
		std::shared_ptr<Task> task;
		{
			// 获取锁
			std::unique_lock<std::mutex> lock(taskQueMtx_);

			std::cout << "tid:" << std::this_thread::get_id()
				<< "尝试获取任务!" << std::endl;

			notEmpty_.wait(lock, [&]()->bool {return !taskQue_.empty(); });

			std::cout << "tid:" << std::this_thread::get_id()
				<< "成功获取任务!" << std::endl;

			task = taskQue_.front(); taskQue_.pop();
			taskSize_--;

			// 为什么用了两个条件变量呢，这便于进行更精细的操作
			// 如果任务队列仍有任务，则通知其他wait在notEmpty_的线程执行任务
			if (taskQue_.size() > 0) {
				notEmpty_.notify_all();
			}
			
			// 通知 wait在notFull_上的生产者，可以继续提交任务
			notFull_.notify_all();
		}  // 取完任务，释放锁
		if (task != nullptr) {
			// 执行任务，并把任务的返回值setVal方法给到Result
			// task->run();
			// run是个需要重写的方法，我们不可能将增加的这部分功能写到run里面
			// 所以我们在Task类中增加了exec函数，在这个函数中执行run和新增加的功能
			task->exec();
		}
	}
}

// 给线程池提交任务
// 生产者：获取锁，while(满) {wait}，提交任务，notify_all
Result ThreadPool::submitTask(std::shared_ptr<Task> sp) {
	// 获取锁
	std::unique_lock<std::mutex> lock(taskQueMtx_);

	// 线程的通信 等待任务队列有空余
	// 没有空余才等待，因此需要等待notFull_
	// 这里使用了lambda表达式的隐式捕获的引用捕获，让编译器根据函数体中代码推断捕获列表
	//// notFull_.wait(lock, [&]()->bool {return taskQue_.size() < taskQueMaxThreshHold_; });
	// 与下面三行等价
	//while (taskQue_.size() == taskQueMaxThreshHold_) {
	//	notFull_.wait(lock);
	//}
	// 增加一个要求：用户提交任务，最长不能阻塞超过1s，否则判断提交任务失败，返回
	// wait()：一直等待到条件满足；wait_for()：等一段时间；wait_until()：等到一个时间点
	/*notFull_.wait_for(lock, std::chrono::seconds(1), [&]()->bool {return taskQue_.size() < taskQueMaxThreshHold_; });*/
	if (!notFull_.wait_for(lock, std::chrono::seconds(1), [&]()->bool {return taskQue_.size() < taskQueMaxThreshHold_; })) {
		// 等待1s，条件仍不满足
		std::cerr << "task queue is full, submit task fail." << std::endl;
		// 若任务提交失败，则
		return Result(sp, false);
	}

	// 有空余，将任务放入任务队列
	taskQue_.emplace(sp);
	taskSize_++;

	// 任务队列不空，通知notEmpty_
	notEmpty_.notify_all();
	// 对于Result，可以通过task类里面的函数返回，也可以用Result类进行封装
	// return task->getResult();  // 不行！task对象被线程取出来用完后就析构了，再想使用这个task对象是不行的
	// return Result(task);  // 因此通过Result来维持task的生命周期，保证我们想要task返回值的时候task对象还在
	return Result(sp);
}


/////////////////////////////////// 线程方法实现
Thread::Thread(ThreadFunc func)
	: func_(func)
{}
Thread::~Thread() {

}
// 启动线程
void Thread::start() {
	// 创建线程
	// ThreadPool::start函数创建了thread，传入了func_
	// 因此创建线程的时候直接把func_放进去就行
	// 这里thread的构造函数通过完美转发将参数传递给线程函数
	
	std::thread t(func_);
	// 注意，上面是将线程函数写到线程池类的写法
	// 若是将线程函数写到Thread类中，则应该写为
	// std::thread t(&Thread::threadFunc, &thread1);
	// thread1表示一个线程对象，相应的start函数也应该有形参：start(Thread& thread1)

	// 注意，这个线程对象t出了这个作用域就会自动销毁
	// 因此要设置为分离线程，使得此线程变为守护线程，驻留后台运行
	t.detach();
}



/////////////////////////////  Result的实现
Result::Result(std::shared_ptr<Task> task, bool isValid) 
	: task_(task), isValid_(isValid){
	// 顺便将result对象绑定到task上
	task_->setResult(this);
}

Any Result::get() {
	if (!isValid_) return "";  // 如果返回值无效，返回g个空
	sem_.wait();  // task任务如果没有执行完，则堵塞用户的线程
	return std::move(any_);

}

void Result::setVal(Any any) {
	// 存储task的返回值
	this->any_ = std::move(any);
	sem_.post();
}
```

threadpool.h

```cpp
#ifndef THREADPOOL_H
#define THREADPOOL_H
// 使用 #ifndef 而非 #pragma once ，因为后者需要编译器支持，在linux下不支持
#include<iostream>
#include<vector>
#include<queue>
#include<memory>  // 智能指针
#include<atomic>  // 原子类型，实现线程互斥
#include<mutex>  // 锁
#include<condition_variable>  // 条件变量，实现线程通信
#include<functional>
#include<thread>

// Any类型：可以接收任意数据的类型
// 将其作为函数返回值类型时，会看Any有没有一个合适的构造函数，来接收return返回的对象
class Any {
public:
	// 将任意类型的data包在派生类中，用基类指针指向
	template<typename T>
	Any(T data) : base_(std::make_unique<Derive<T>>(data)) {}

	// 定义一个方法，将Any对象存储的data_数据提取出来
	template<typename T>
	T cast_() {
		// 从base_指针中找到所指向的派生类对象，取出data_成员变量
		// 用智能指针提供的get方法取得裸指针，用 dynamic_cast 进行自动的类型转换至派生类指针
		Derive<T>* pd = dynamic_cast<Derive<T>*>(base_.get());
		if (pd == nullptr) {
			// dynamic_cast 转换失败，比如人家是int，你以为是long，就cast_<long>来调用，结果人家是Derive<int>，就转换失败了
			throw "type is unmatch";
		}
		return pd->data_;
	}
	Any() = default;
	~Any() = default;
	// Any类中的成员变量是unique_ptr类型的，对于这个智能指针，禁止了拷贝构造和赋值，仅支持移动构造
	// 因此Any类中也是这样的。这就是默认实现，不写也无所谓
	Any(const Any&) = delete;
	Any& operator=(const Any&) = delete;
	Any(Any&&) = default;
	Any& operator=(Any&&) = default;
private:
	// 基类类型
	class Base {
	public:
		// 对于多态用途的基类，需要虚析构函数
		// 若不是虚析构，在delete一个指向派生类的基类指针的时候，可能仅将派生类对象的基类部分西沟了，因此其结果将是未定义的
		// 定义为虚析构，才能确保delete基类指针时运行正确的析构函数版本
		virtual ~Base() = default;
	};
	// 派生类类型
	template<typename T>
	class Derive : public Base {
	public:
		Derive(T data) : data_(data) {};
		T data_;
	};
private:
	// 定义一个基类的指针
	std::unique_ptr<Base> base_;
};

// 实现一个信号量类，来实现Result类的线程通信
// 这个信号量默认的资源数为0
class Semaphore {
public:
	Semaphore(int count = 0) : resLimit_(count) {}
	// 获取一个信号量资源
	void wait() {
		std::unique_lock<std::mutex> lock(mtx_);
		// 等待信号量有资源
		cond_.wait(lock, [&]()->bool { return resLimit_ > 0; });
		resLimit_--;
	}
	// 增加一个信号量资源
	void post() {
		std::unique_lock<std::mutex> lock(mtx_);
		resLimit_++;
		cond_.notify_all();
	}
private:
	int resLimit_;
	std::mutex mtx_;
	std::condition_variable cond_;
};

class Task;  // Task对象的前置声明
// Result类：作为 submitTask 的返回值
// 实现接收提交到线程池的task任务执行完成后的返回值类型
// 主线程中的Result类通过get来获取任务线程的返回值，因此需要与任务线程进行线程通信
class Result {
public:
	Result(std::shared_ptr<Task> task, bool isValid = true);
	// 获取任务执行完的返回值，将task_ run()的返回值放到any_里
	void setVal(Any any);
	// 用户调用这个方法获取task的返回值
	Any get();

private:
	Any any_;  // 存储任务的返回值
	Semaphore sem_;  // 线程通信的信号量
	std::shared_ptr<Task> task_;  // 指向对应的需要获取返回值的task对象
	std::atomic_bool isValid_;  // 返回值是否有效
};


//////////////////////////////    任务抽象基类
class Task {
public:
	// 用户可以自定义任意任务类型，从 Task 继承，重写 run 方法，实现自定义任务处理
	Task();
	virtual Any run() = 0;
	void exec();
	void setResult(Result* res);
private:
	Result* result_;  // 这里用普通的指针就行，因为result的生命周期比task长
};


// 线程池支持的模式
// 这里使用了限定作用域的枚举类型
// 使用时必须显示的访问，PoolMode p = PoolMode::MODE_FIXED;
enum class PoolMode {
	MODE_FIXED,  // 固定数量的线程
	MODE_CACHED,  // 线程数量可动态增长
};


//////////////////////////////////   线程类型
class Thread {
public:
	// 线程函数对象类型，为function函数对象
	using ThreadFunc = std::function<void()>;

	Thread(ThreadFunc func);
	~Thread();
	void start();
private:
	ThreadFunc func_;
};


///////////////////////////////////   线程池类型
/*
example:
ThreadPool pool;
pool.start(4);

class MyTask : public Task
{
	public:
		void run() { // 线程代码... }
};

pool.submitTask(std::make_shared<MyTask>());
*/
class ThreadPool {
public:
	ThreadPool();
	~ThreadPool();
	// 禁止线程池的拷贝和复制
	ThreadPool(const ThreadPool&) = delete;
	ThreadPool& operator=(const ThreadPool&) = delete;

	// 设置线程池模式
	void setMode(PoolMode mode);

	// 开启线程池，并设置初始的线程数量
	void start(size_t initThreadSize = 4);

	// 任务相关
	// 设置task任务队列上限阈值
	void setTaskQueMaxThreshHold(int threshhold);
	// 给线程池提交任务
	Result submitTask(std::shared_ptr<Task> sp);

private:
	// 定义线程函数
	void threadFunc();
private:
	

	// 线程相关
	// 线程列表。对于线程的创建，是在ThreadPool::start中new出来的，还需要delete
	// 因此直接使用智能指针。线程的话unique就行
	std::vector<std::unique_ptr<Thread>> threads_;
	size_t initThreadSize_;  // 初始的线程数量。size_t增强了可移植性，表示任何对象所能达到的最大长度
	// 需要使用基类的指针或引用才能实现多态
	// 而用户传入的通常会是临时的一个任务对象，出了submitTask语句后就析构了，用指针指向一个析构了的对象是没有意义的
	// 而我们是需要考虑来保持这个任务的生命周期的，当这个任务run执行以后在析构
	// 因此需要使用智能指针
	std::queue<std::shared_ptr<Task>> taskQue_;  // 任务队列
	std::atomic_uint taskSize_;  // 任务的数量。考虑到线程安全问题，使用轻量化的原子类型实现线程互斥
	size_t taskQueMaxThreshHold_;  // 任务队列数量的上限

	// 实现线程通信
	std::mutex taskQueMtx_;  // 保证任务队列的线程安全
	std::condition_variable notEmpty_;  // 任务队列不空
	std::condition_variable notFull_;  // 任务队列不满

	PoolMode poolMode_;  // 当前线程池的工作模式
};


#endif // !THREADPOOL_H

```

test.cpp

```cpp
#include"threadpool.h"
#include<chrono>

class MyTask : public Task
{
public:
	MyTask(int begin, int end)
		: begin_(begin)
		, end_(end)
	{}
	Any run() {
		std::cout << "tid:" << std::this_thread::get_id()
			<< "begin!" << std::endl;
		std::this_thread::sleep_for(std::chrono::seconds(5));
		int sum = 0;
		for (int i = begin_; i <= end_; i++)
			sum += i;
		std::cout << "tid:" << std::this_thread::get_id()
			<< "end!" << std::endl;
		return sum;
	}
private:
	int begin_;
	int end_;
};

// const int TASK_MAX_THRESHHOLD = 4;，任务列表设为了最大四个任务
// 此时线程池设置4个线程。每个任务执行5s，提交若干个任务后，会有一些任务提交失败（等待超过了1s）

int main() {
	ThreadPool pool;
	pool.start(4);
	// Master - Slave线程模型
	// Master线程用来分解任务，然后给各个Slave线程分配任务
	// 等待各个Slave线程执行完任务，返回结果
	// Master线程合并各个任务结果，输出
	Result res1 = pool.submitTask(std::make_shared<MyTask>(1, 100));
	Result res2 = pool.submitTask(std::make_shared<MyTask>(101, 200));
	Result res3 = pool.submitTask(std::make_shared<MyTask>(201, 300));
	int sum = res1.get().cast_<int>() + res2.get().cast_<int>() + res3.get().cast_<int>();
	std::cout << sum << std::endl;
	int sum2 = 0;
	for (int i = 1; i <= 300; i++) {
		sum2 += i;
	}
	std::cout << "answer:" << sum2 << std::endl;
	getchar();
}
```

![image-20230313213503364](E:\MarkDown\picture\image-20230313213503364.png)

## 阶段三

**threadpool.cpp**

```cpp
#include"threadpool.h"

const int TASK_MAX_THRESHHOLD = 1024;
const int THREAD_MAX_THRESHHOLD = 100;
const int THREAD_MAX_IDLE_TIME = 10;  // 等待的时间，s
//////////////////////  Task方法实现
Task::Task(): result_(nullptr) {}
// 在task对应的result类进行构造的时候调用，将新创建的result绑定到当前的task上
// 即为task中指向Result的成员变量result_赋值，之后就可以通过这个指针，将task的结果存到Result对象中了
void Task::setResult(Result* res) {
	result_ = res;
}
void Task::exec() {
	// run，并将任务的返回值保存在Result类中
	if (result_ != nullptr) {
		result_->setVal(run());  // run在这里发生多态调用
	}
}

//////////////////////  线程池方法实现
ThreadPool::ThreadPool()
	: initThreadSize_(4)
	, taskSize_(0)
	, taskQueMaxThreshHold_(TASK_MAX_THRESHHOLD)
	, threadSizeThreshHold_(THREAD_MAX_THRESHHOLD)
	, poolMode_(PoolMode::MODE_FIXED)
	, isPoolRunning_(false)
	, curThreadSize_(0)
	, idleThreadSize_(0)
{}

ThreadPool::~ThreadPool() {}

// 设置cached模式下线程阈值
void ThreadPool::setThreadSizeThreshHold(int threshhold) {
	if (checkRunningState()) return;
	if (poolMode_ == PoolMode::MODE_CACHED) {
		threadSizeThreshHold_ = threshhold;
	}
}
// 设置线程池工作模式
void ThreadPool::setMode(PoolMode mode) {
	// 如果线程池已经启动了，则不能设置工作模式了
	if (checkRunningState()) return;
	poolMode_ = mode;
}

// 检查线程池的运行状态
bool ThreadPool::checkRunningState() const {
	return isPoolRunning_;
}

// 任务相关
// 设置task任务队列上限阈值
void ThreadPool::setTaskQueMaxThreshHold(int threshhold) {
	// 如果线程池已经启动了，则不能设置了
	if (checkRunningState()) return;
	taskQueMaxThreshHold_ = threshhold;
}

// 开启线程池，并设置初始的线程数量
void ThreadPool::start(size_t initThreadSize) {
	// 设置线程池的启动状态
	isPoolRunning_ = true;

	// 设置初始的线程数量
	initThreadSize_ = initThreadSize;
	// 记录线程总数
	curThreadSize_ = initThreadSize;

	// 创建线程对象
	for (size_t i = 0; i < initThreadSize_; i++) {
		// 创建thread线程对象的时候，需要把线程函数给到thread类
		// 这样在Thread::start中才能启动这个线程函数
		// 通过构造函数，将threadFunc放进去
		// 这里我们使用bind。对于类的成员函数，前面要取个地址
		// 且需要绑定一个类对象才能使用，这里绑定了this即当前对象
		// 这里使用智能指针创建线程对象，让其能自动析构
		auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::threadFunc, this, std::placeholders::_1));  // c++14
		// 使用move将左值转换为对应的右值引用类型
		int threadId = ptr->getId();
		threads_.emplace(threadId, std::move(ptr));
		// unique_ptr是不允许拷贝构造的，仅支持一个智能指针指向它
		// 因此 emplace_back(ptr) 的操作会报错
		// unique_ptr虽然关闭了左值引用的拷贝和赋值，但支持右值引用的操作！
	}

	// 启动所有线程
	for (size_t i = 0; i < initThreadSize_; i++) {
		// 注意，这里threads_[i]是指针
		// 调用了线程类里的start函数创建并启动线程
		threads_[i]->start();
		idleThreadSize_++;
	}
}

// threadFunc负责在线程池中获取并执行任务
// 在线程池类中定义线程函数，由线程类执行
// 线程函数需要的那些锁和条件变量，都定义在线程池中
// 这里线程函数若是定义在Thread类中，则不方便访问ThreadPool里的那些私有的锁和条件变量
// 因此将线程函数定义在ThreadPool类中
void ThreadPool::threadFunc(int threadid) {
	auto lastTime = std::chrono::high_resolution_clock().now();

	// 所有任务必须执行完成，线程池才可以回收所有线程资源
	// 相当于while(true)。线程执行threadFunc后便一直在此函数中尝试获取任务
	for (;;) {
		// 注意，我们仅需要在取任务的时候获取锁，取到任务后释放锁，再执行任务
		std::shared_ptr<Task> task;
		{
			// 获取锁
			std::unique_lock<std::mutex> lock(taskQueMtx_);

			std::cout << "tid:" << std::this_thread::get_id()
				<< "尝试获取任务!" << std::endl;

			// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s
			// 对于超过初始线程数量initThreadSize_的线程，需要看情况进行回收
			if (poolMode_ == PoolMode::MODE_CACHED) {
				// 每一秒返回一次
				// while来区分是超时返回还是有任务待执行返回
				// 任务队列有任务，就跳过while去消费，没任务才等待任务
				while (taskQue_.size() == 0) {
					// wait_for函数的返回值cv_status有两个状态，超时和不超时
					if (std::cv_status::timeout == 
						notEmpty_.wait_for(lock, std::chrono::seconds(1))) {
						auto now = std::chrono::high_resolution_clock().now();
						auto dur = std::chrono::duration_cast<std::chrono::seconds>(now - lastTime);
						if (dur.count() >= THREAD_MAX_IDLE_TIME
							&& curThreadSize_ > initThreadSize_) {
							// 回收线程
							// 记录线程数量的相关变量的值
							idleThreadSize_--;
							curThreadSize_--;

							// 将线程对象从线程列表中删除 但没法将threadFunc对应到thread对象
							// threadid => thread对象 => 删除
							threads_.erase(threadid);
							std::cout << "threadid:" << std::this_thread::get_id() << " exit!" << std::endl;
							return;

						}
					}
				}
			}
			else {  // fixed模式，正常执行
				notEmpty_.wait(lock, [&]()->bool {return !taskQue_.empty(); });
			}

			
			idleThreadSize_--;

			std::cout << "tid:" << std::this_thread::get_id()
				<< "成功获取任务!" << std::endl;

			task = taskQue_.front(); taskQue_.pop();
			taskSize_--;

			// 为什么用了两个条件变量呢，这便于进行更精细的操作
			// 如果任务队列仍有任务，则通知其他wait在notEmpty_的线程执行任务
			if (taskQue_.size() > 0) {
				notEmpty_.notify_all();
			}
			
			// 通知 wait在notFull_上的生产者，可以继续提交任务
			notFull_.notify_all();
		}  // 取完任务，释放锁
		if (task != nullptr) {
			// 执行任务，并把任务的返回值setVal方法给到Result
			// task->run();
			// run是个需要重写的方法，我们不可能将增加的这部分功能写到run里面
			// 所以我们在Task类中增加了exec函数，在这个函数中执行run和新增加的功能
			task->exec();
		}
		idleThreadSize_++;
		lastTime = std::chrono::high_resolution_clock().now();
	}
}

// 给线程池提交任务
// 生产者：获取锁，while(满) {wait}，提交任务，notify_all
Result ThreadPool::submitTask(std::shared_ptr<Task> sp) {
	// 获取锁
	std::unique_lock<std::mutex> lock(taskQueMtx_);

	// 线程的通信 等待任务队列有空余
	// 没有空余才等待，因此需要等待notFull_
	// 这里使用了lambda表达式的隐式捕获的引用捕获，让编译器根据函数体中代码推断捕获列表
	//// notFull_.wait(lock, [&]()->bool {return taskQue_.size() < taskQueMaxThreshHold_; });
	// 与下面三行等价
	//while (taskQue_.size() == taskQueMaxThreshHold_) {
	//	notFull_.wait(lock);
	//}
	// 增加一个要求：用户提交任务，最长不能阻塞超过1s，否则判断提交任务失败，返回
	// wait()：一直等待到条件满足；wait_for()：等一段时间；wait_until()：等到一个时间点
	/*notFull_.wait_for(lock, std::chrono::seconds(1), [&]()->bool {return taskQue_.size() < taskQueMaxThreshHold_; });*/
	if (!notFull_.wait_for(lock, std::chrono::seconds(1), [&]()->bool {return taskQue_.size() < taskQueMaxThreshHold_; })) {
		// 等待1s，条件仍不满足
		std::cerr << "task queue is full, submit task fail." << std::endl;
		// 若任务提交失败，则
		return Result(sp, false);
	}

	// 有空余，将任务放入任务队列
	taskQue_.emplace(sp);
	taskSize_++;

	// 任务队列不空，通知notEmpty_
	notEmpty_.notify_all();

	// cached模式需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程出来
	// 且需要当前线程总数小于我们设定的最大线程数
	if (poolMode_ == PoolMode::MODE_CACHED && taskSize_ > idleThreadSize_ && curThreadSize_ < threadSizeThreshHold_) {
		std::cout << "create new thread" << std::endl;
		// 创建新线程
		auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::threadFunc, this, std::placeholders::_1));  // c++14
		int threadId = ptr->getId();
		threads_.emplace(threadId, std::move(ptr));
		// 启动线程
		threads_[threadId]->start();
		// 修改线程个数相关的变量
		curThreadSize_++;
		idleThreadSize_++;
	}
	// 对于Result，可以通过task类里面的函数返回，也可以用Result类进行封装
	// return task->getResult();  // 不行！task对象被线程取出来用完后就析构了，再想使用这个task对象是不行的
	// return Result(task);  // 因此通过Result来维持task的生命周期，保证我们想要task返回值的时候task对象还在
	return Result(sp);
}


/////////////////////////////////// 线程方法实现
int Thread::generateId_ = 0;

Thread::Thread(ThreadFunc func)
	: func_(func)
	, threadId_(generateId_++)
{}

Thread::~Thread() {

}

int Thread::getId() const {
	return threadId_;
}

// 启动线程
void Thread::start() {
	// 创建线程
	// ThreadPool::start函数创建了thread，传入了func_
	// 因此创建线程的时候直接把func_放进去就行
	// 这里thread的构造函数通过完美转发将参数传递给线程函数
	
	std::thread t(func_, threadId_);
	// 注意，上面是将线程函数写到线程池类的写法
	// 若是将线程函数写到Thread类中，则应该写为
	// std::thread t(&Thread::threadFunc, &thread1);
	// thread1表示一个线程对象，相应的start函数也应该有形参：start(Thread& thread1)

	// 注意，这个线程对象t出了这个作用域就会自动销毁
	// 因此要设置为分离线程，使得此线程变为守护线程，驻留后台运行
	t.detach();
}



/////////////////////////////  Result的实现
Result::Result(std::shared_ptr<Task> task, bool isValid) 
	: task_(task), isValid_(isValid){
	// 顺便将result对象绑定到task上
	task_->setResult(this);
}

Any Result::get() {
	if (!isValid_) return "";  // 如果返回值无效，返回g个空
	sem_.wait();  // task任务如果没有执行完，则堵塞用户的线程
	return std::move(any_);

}

void Result::setVal(Any any) {
	// 存储task的返回值
	this->any_ = std::move(any);
	sem_.post();
}
```

**threadpool.h**

```cpp
#ifndef THREADPOOL_H
#define THREADPOOL_H
// 使用 #ifndef 而非 #pragma once ，因为后者需要编译器支持，在linux下不支持
#include<iostream>
#include<vector>
#include<queue>
#include<memory>  // 智能指针
#include<atomic>  // 原子类型，实现线程互斥
#include<mutex>  // 锁
#include<condition_variable>  // 条件变量，实现线程通信
#include<functional>
#include<thread>
#include<unordered_map>

// Any类型：可以接收任意数据的类型
// 将其作为函数返回值类型时，会看Any有没有一个合适的构造函数，来接收return返回的对象
class Any {
public:
	// 将任意类型的data包在派生类中，用基类指针指向
	template<typename T>
	Any(T data) : base_(std::make_unique<Derive<T>>(data)) {}

	// 定义一个方法，将Any对象存储的data_数据提取出来
	template<typename T>
	T cast_() {
		// 从base_指针中找到所指向的派生类对象，取出data_成员变量
		// 用智能指针提供的get方法取得裸指针，用 dynamic_cast 进行自动的类型转换至派生类指针
		Derive<T>* pd = dynamic_cast<Derive<T>*>(base_.get());
		if (pd == nullptr) {
			// dynamic_cast 转换失败，比如人家是int，你以为是long，就cast_<long>来调用，结果人家是Derive<int>，就转换失败了
			throw "type is unmatch";
		}
		return pd->data_;
	}
	Any() = default;
	~Any() = default;
	// Any类中的成员变量是unique_ptr类型的，对于这个智能指针，禁止了拷贝构造和赋值，仅支持移动构造
	// 因此Any类中也是这样的。这就是默认实现，不写也无所谓
	Any(const Any&) = delete;
	Any& operator=(const Any&) = delete;
	Any(Any&&) = default;
	Any& operator=(Any&&) = default;
private:
	// 基类类型
	class Base {
	public:
		// 对于多态用途的基类，需要虚析构函数
		// 若不是虚析构，在delete一个指向派生类的基类指针的时候，可能仅将派生类对象的基类部分西沟了，因此其结果将是未定义的
		// 定义为虚析构，才能确保delete基类指针时运行正确的析构函数版本
		virtual ~Base() = default;
	};
	// 派生类类型
	template<typename T>
	class Derive : public Base {
	public:
		Derive(T data) : data_(data) {};
		T data_;
	};
private:
	// 定义一个基类的指针
	std::unique_ptr<Base> base_;
};

// 实现一个信号量类，来实现Result类的线程通信
// 这个信号量默认的资源数为0
class Semaphore {
public:
	Semaphore(int count = 0) : resLimit_(count) {}
	// 获取一个信号量资源
	void wait() {
		std::unique_lock<std::mutex> lock(mtx_);
		// 等待信号量有资源
		cond_.wait(lock, [&]()->bool { return resLimit_ > 0; });
		resLimit_--;
	}
	// 增加一个信号量资源
	void post() {
		std::unique_lock<std::mutex> lock(mtx_);
		resLimit_++;
		cond_.notify_all();
	}
private:
	int resLimit_;
	std::mutex mtx_;
	std::condition_variable cond_;
};

class Task;  // Task对象的前置声明
// Result类：作为 submitTask 的返回值
// 实现接收提交到线程池的task任务执行完成后的返回值类型
// 主线程中的Result类通过get来获取任务线程的返回值，因此需要与任务线程进行线程通信
class Result {
public:
	Result(std::shared_ptr<Task> task, bool isValid = true);
	// 获取任务执行完的返回值，将task_ run()的返回值放到any_里
	void setVal(Any any);
	// 用户调用这个方法获取task的返回值
	Any get();

private:
	Any any_;  // 存储任务的返回值
	Semaphore sem_;  // 线程通信的信号量
	std::shared_ptr<Task> task_;  // 指向对应的需要获取返回值的task对象
	std::atomic_bool isValid_;  // 返回值是否有效
};


//////////////////////////////    任务抽象基类
class Task {
public:
	// 用户可以自定义任意任务类型，从 Task 继承，重写 run 方法，实现自定义任务处理
	Task();
	virtual Any run() = 0;
	void exec();
	void setResult(Result* res);
private:
	Result* result_;  // 这里用普通的指针就行，因为result的生命周期比task长
};


// 线程池支持的模式
// 这里使用了限定作用域的枚举类型
// 使用时必须显示的访问，PoolMode p = PoolMode::MODE_FIXED;
enum class PoolMode {
	MODE_FIXED,  // 固定数量的线程
	MODE_CACHED,  // 线程数量可动态增长
};


//////////////////////////////////   线程类型
class Thread {
public:
	// 线程函数对象类型，为function函数对象
	using ThreadFunc = std::function<void(int)>;

	Thread(ThreadFunc func);
	~Thread();
	void start();

	// 获取线程id
	int getId() const;
private:
	ThreadFunc func_;
	static int generateId_;  // 类的所有对象共享静态成员变量，通过它来得到变化的threadId_
	int threadId_;  // 保存线程ID
};


///////////////////////////////////   线程池类型
/*
example:
ThreadPool pool;
pool.start(4);

class MyTask : public Task
{
	public:
		void run() { // 线程代码... }
};

pool.submitTask(std::make_shared<MyTask>());
*/
class ThreadPool {
public:
	ThreadPool();
	~ThreadPool();
	// 禁止线程池的拷贝和复制
	ThreadPool(const ThreadPool&) = delete;
	ThreadPool& operator=(const ThreadPool&) = delete;

	// 设置线程池模式
	void setMode(PoolMode mode);

	// 开启线程池，并设置初始的线程数量
	void start(size_t initThreadSize = 4);

	// 设置cached模式下线程阈值
	void setThreadSizeThreshHold(int threshhold);
	// 任务相关
	// 设置task任务队列上限阈值
	void setTaskQueMaxThreshHold(int threshhold);
	// 给线程池提交任务
	Result submitTask(std::shared_ptr<Task> sp);

private:
	// 定义线程函数
	void threadFunc(int threadid);

	// 检查线程池的运行状态
	bool checkRunningState() const;
private:
	

	// 线程相关
	// 线程列表。对于线程的创建，是在ThreadPool::start中new出来的，还需要delete
	// 因此直接使用智能指针。线程的话unique就行
	// std::vector<std::unique_ptr<Thread>> threads_;
	// 为了实现通过threadId_查询到对应的线程，这里最后使用了map
	std::unordered_map<int, std::unique_ptr<Thread>> threads_;

	size_t threadSizeThreshHold_;  // 线程数量的上限
	// 为什么新增一个变量而不是用threads_.size()呢，因为vector不是线程安全的
	std::atomic_int curThreadSize_;  // 记录当前线程池里面线程的总数量
	std::atomic_int idleThreadSize_;  // 记录空闲线程的数量
	int initThreadSize_;  // 初始的线程数量。size_t增强了可移植性，表示任何对象所能达到的最大长度
	
	// 需要使用基类的指针或引用才能实现多态
	// 而用户传入的通常会是临时的一个任务对象，出了submitTask语句后就析构了，用指针指向一个析构了的对象是没有意义的
	// 而我们是需要考虑来保持这个任务的生命周期的，当这个任务run执行以后在析构
	// 因此需要使用智能指针
	std::queue<std::shared_ptr<Task>> taskQue_;  // 任务队列
	std::atomic_uint taskSize_;  // 任务的数量。考虑到线程安全问题，使用轻量化的原子类型实现线程互斥
	size_t taskQueMaxThreshHold_;  // 任务队列数量的上限

	// 实现线程通信
	std::mutex taskQueMtx_;  // 保证任务队列的线程安全
	std::condition_variable notEmpty_;  // 任务队列不空
	std::condition_variable notFull_;  // 任务队列不满

	PoolMode poolMode_;  // 当前线程池的工作模式

	std::atomic_bool isPoolRunning_;  // 表示当前线程池的启动状态
	
};


#endif // !THREADPOOL_H

```

test.cpp

```cpp
#include"threadpool.h"
#include<chrono>

class MyTask : public Task
{
public:
	MyTask(int begin, int end)
		: begin_(begin)
		, end_(end)
	{}
	Any run() {
		std::cout << "tid:" << std::this_thread::get_id()
			<< "begin!" << std::endl;
		std::this_thread::sleep_for(std::chrono::seconds(5));
		int sum = 0;
		for (int i = begin_; i <= end_; i++)
			sum += i;
		std::cout << "tid:" << std::this_thread::get_id()
			<< "end!" << std::endl;
		return sum;
	}
private:
	int begin_;
	int end_;
};

// const int TASK_MAX_THRESHHOLD = 4;，任务列表设为了最大四个任务
// 此时线程池设置4个线程。每个任务执行5s，提交若干个任务后，会有一些任务提交失败（等待超过了1s）

int main() {
	ThreadPool pool;
	// 用户自己设置线程池的工作模式
	pool.setMode(PoolMode::MODE_CACHED);
	// 启动线程池
	pool.start(2);
	// Master - Slave线程模型
	// Master线程用来分解任务，然后给各个Slave线程分配任务
	// 等待各个Slave线程执行完任务，返回结果
	// Master线程合并各个任务结果，输出
	Result res1 = pool.submitTask(std::make_shared<MyTask>(1, 100));
	Result res2 = pool.submitTask(std::make_shared<MyTask>(101, 200));
	Result res3 = pool.submitTask(std::make_shared<MyTask>(201, 300));
	int sum = res1.get().cast_<int>() + res2.get().cast_<int>() + res3.get().cast_<int>();
	std::cout << sum << std::endl;
	int sum2 = 0;
	for (int i = 1; i <= 300; i++) {
		sum2 += i;
	}
	std::cout << "answer:" << sum2 << std::endl;
	getchar();
}
```



![image-20230314181257812](E:\MarkDown\picture\image-20230314181257812.png)

