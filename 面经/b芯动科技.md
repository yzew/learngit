> 了解CPU（x86/ARM/MIPS/RISC-V）体系结构；
> 熟悉C/C++编程语言，编程功底扎实；
> 熟悉Linux设备驱动开发；
> 熟悉中断机制，I/O控制和常见外设（UART、SPI、IIC、USB、SD/MMC等）；
> 有良好的硬件原理图阅读能力和硬件调试能力，会使用万用表、示波器、逻辑分析仪等调试设备；
> 对软件工程概念及开发测试流程有一定了解；



一面面试官说二面主要考察深度



>   熟悉中断机制，i/o控制和常见外设（uart、spi、iic、usb、sd/mmc等）



>   1. I/O控制（Input/Output Control）： I/O控制是指通过输入/输出设备与外部世界进行数据交互的过程。嵌入式系统中的I/O控制包括读取传感器数据、驱动外部设备（例如LED、LCD、继电器等），或与其他设备进行通信。通常，嵌入式系统通过寄存器、端口或专用接口与外设进行通信控制。
>
>   2. 常见外设： 
>
>      a. UART（Universal Asynchronous Receiver/Transmitter）： UART是一种常见的串行通信接口协议，用于实现异步串行通信。它通常用于与其他设备（如计算机、传感器、蓝牙模块等）进行数据传输。
>
>      b. SPI（Serial Peripheral Interface）： SPI是一种同步串行通信接口，用于连接主控制器与外部设备，如存储器、传感器、显示屏等。SPI通信可以使用多个从设备（slave）与一个主设备（master）的架构。
>
>      c. I2C（Inter-Integrated Circuit）： I2C是一种双线制串行通信协议，用于连接多个设备，例如传感器、显示器、EEPROM等。I2C协议使用两根线（SDA和SCL）进行数据传输。
>
>      d. USB（Universal Serial Bus）： USB是一种通用的外部总线接口，用于连接计算机与各种外部设备，例如打印机、键盘、鼠标、摄像头等。
>
>      e. SD/MMC（Secure Digital / Multimedia Card）： SD/MMC是一种常用的存储卡接口标准，用于扩展嵌入式系统的存储容量，如相机、手机、嵌入式控制器等。
>
>   Linux设备驱动开发

> Linux常用命令、VIM学习、Linux的Shell编程、Gcc编译、Makefile等。

> 二、驱动篇
> 1.学习内容：该部分主要学习：内核模块编译原理、字符设备驱动框架、平台设备驱动、设备树、Pinctrl子系统、I2C子系统、中断子系统、块设备驱动框架、Bootloader等
> 2.学习建议：对于驱动学习，重要在于明白“如何在Linux环境下编写驱动程序”，驱动的底层原理还是那样，加了一层层的框架，需要我们去熟悉。
> 3.学习资料：对于驱动开发，推荐《Linux设备驱动开发详解》，Linux内核源码详解等。

> 三、内核篇
> 1.学习内容：该部分主要学习：系统调用、存储管理、进程管理、内存管理、文件管理等。
> 2.学习建议：对于内核学习，上述也是系统的几大核心特色，重点在于"如何使Linux性能最优"
> 3.学习资料：对于内核学习，推荐《Linux Shell脚本攻略》、《深入理解Linux内核》等。

> 四、应用篇
> 1.学习内容：该部分主要学习：QT编程、TCP/IP协议、HTTP协议等。
> 2.学习建议：对于应用学习，上述的几个方面也是基础，重点还在于开发什么应用，去学习哪方面的知识，没有固定方法因人而易。
> 3.学习资料：对于应用开发，推荐《嵌入式Linux应用开发完全手册》、《Unix网络编程》等。



> **FreeRTOS**
>
> 开源性质：FreeRTOS是一个开源的RTOS，可以免费获取并在商业和非商业项目中使用。它具有广泛的用户社区和支持。
>
> 架构和内核：FreeRTOS采用基于优先级的抢占式内核架构，支持多任务处理、时间片轮转调度和中断服务机制。它提供了一套轻量级的内核函数和任务管理机制。
>
> 资源占用：FreeRTOS的内核非常小巧，具有低的存储器占用和快速的上下文切换速度，适用于资源有限的嵌入式系统。
>
> 硬件平台支持：FreeRTOS在多种处理器架构上都有支持，包括ARM、MIPS、x86等，因此它适用于广泛的硬件平台。
>
> **在RTOS中，二值信号量和互斥量的区别？**
>
> ​	二值信号量是一种计数器，只有两种状态：0和1。当一个任务试图获取一个已经被获取的二值信号量时，该任务会被挂起，直到该信号量被释放为止。二值信号量通常用于同步任务的开始或者结束，或者是保护共享资源的读写等。由于二值信号量不具有优先级继承功能，当高优先级任务等待低优先级任务释放二值信号量时，低优先级任务可能会优先执行，导致任务调度出现问题。
>
> ​	互斥量也是一种计数器，但它具有更多的状态。当一个任务获取一个已经被获取的互斥量时，该任务会被挂起，并且该互斥量的计数器会减一。只有当计数器归零时，该互斥量才会被释放。互斥量通常用于保护共享资源的读写等，它具有优先级继承功能，可以避免高优先级任务因为等待低优先级任务释放互斥量而被阻塞的问题。

面试流程，主要分为四个部分：C语言基础，数据结构，操作系统和网络以及协议，项目

自我介绍

\--------------------------------------------------

死锁的情况；

项目中使用锁的情况；

GDB调试命令；

GPU所需技术；

项目背景，以及里面的设计细节(15min)  

线程间同步的方式有哪些？  

互斥锁和自旋锁的区别？谁的开销更大？为什么？  

uboot的作用，以及流程讲讲  

如何完成一个自己设定的目标？  

1.先谈一谈static的作用

2.大端，小端，怎么判断大端小端，大端小端怎么转换

3.强制类型转换会遇到什么问题（因为我在回答大小端转换时用到了强制类型转换）

4.volatile的作用以及应用场景

5.多任务情况下会遇到的问题

6.你常用的数据结构有哪些（数组，链表，栈，队列，树）

7.你怎么实现栈以及队列，说一下具体流程？

8.你了解linux驱动开发吗？设备树中一个设备怎么存储？

9.你在linux中实现过多进程与多线程吗？怎么实现？（pthread）

10.进程间的通信方式

11.poll，epoll与select

12.谈一谈SPI协议，什么时候通信开始？什么时候采集数据？若两个设备采用不同的spi模式会出现什么问题？

13.谈一谈IIC协议，什么时候开始与结束，结束后应答信号是什么？IIC什么时候读取数据？

14.你有实现过SPI与IIC吗？具体怎么实现的

15.项目中用了stm32，你说一下stm32常用寄存器以及stm32的体系架构

16.stm32中中断怎么实现？

17.询问项目其他细节，看你做过这个项目吗？



> linux驱动开发问的比较多


c语言内存分区
数据结构:链表的各种操作
操作系统:多线程多进程区别
自旋锁互斥锁区别
Linux驱动:中断上下文
字符设备驱动输入子系统驱动



简历上写了用过gdb和git随口问了我几个gdb和git的用法。然后是提问

Q1:Arm汇编中bl的意思

A:抱歉，arm汇编我没深入研究过，我用的平台指令集是TI自研的，但我研究过X86的汇编我推测一下。B是跳转的意思,bl的意思可能是小于跳转等于X86汇编的jl，可也能是类似x86的long jump。

这个题答案是小于跳转，没答出来但是面试官说还可以。

Q2:static 修饰的C语言变量存放在哪里，有什么作用

A：存放在data段，不会被重复初始化。

Q3:C语言变量有几种储存方式

A:存放在stack data heap bss

Q4：变量未初始化值是多少

A:stack是垃圾值，不确定，全局变量未初始化是0.

Q5: 什么是野指针

A:我认为是存放了一个不应该访问地址的指针，比如free之后的指针再次访问，访问了一个未进行初始化的指针，访问了一个函数返回的指向局部变量的指针。

Q6：外设和处理器交互的方式

A：中断，DMA，普遍嵌入式设备的外设会被映射到地址空间中，所以可以直接通过读写被映射的地址进行交互。

Q7:使用gcc编译一个hello.c的程序使用什么指令

A:gcc hello.c -o hello.out

**反问环节**

Q:工作中会比较多的使用gdb吗？

A:调试会用到，看你写了所以问你一下

Q:还有有几轮面试

A:一般就两轮，特别优秀的三轮。

**二面**



Q3 简历上写了解决了cache一致性维护讲讲这个

A:实验室用的DSP是八核的一款DSP，测试读写的时候发现自读自写没有问题，但是0核写1核读读取不到正确的数据，查阅芯片手册发现可能是cache的原因，写没有写入下一级的内存，读没有无效化cache。去论坛看了一下相关的帖子，然后解决了这个问题。主要通过官方提供的两条指令cache_invalid cache_writeback。读的核需要无效化cache,写的核需要writeback写到下一级。

Q4:你还写了解决了多核同步问题，怎么解决的

A:我用的芯片没有像X86提供原子指令，转而提供了一种原子外设，官方叫做硬件信号量，访问这个外设的时候是原子的，我模拟实现了一把spinlock 访问临界区的时候上锁。

Q5:了解linux吗

A:了解，增加模仿linux写过一个简易版本的操作系统内核。

Q6:我看你简历上没写啊，讲讲你这个内核吧，跑在什么平台上的，都实现了什么功能

A:跑在i386平台，用qemu模拟器模拟的。可以实现内存管理、进程创建、Sytemcall、进程调度还有一个简易版本的内核调度

Q7:从Boot开始吧，讲讲你的内核启动过程和你实现的功能。

A：i386自导bios在启动之后会从0x7c80读取第一条指令执行，所以内核需要使用链接器来修改镜像的地址。启动后会跳转到镜像entry处的地址，这是一个初始化函数，首先会进行内存的初始化，探测剩余的内存大小，申请一块地址作为page directory,然后对剩余内存按照4kb进行分割，使用链表连接，实现内存池。需要时向内核申请。我的进程创建时模仿linux fork实现的，利用的是写时拷贝技术，只创建一个新的栈，拷贝父进程的page directory的映射，但是标记页表为只读不写，如果写会触发缺页中断，然后进行相应的拷贝。调度是就是在可以准备运行的进程中挑选一个可以准备运行的进程，简单的round-robin算法，后来加入了优先级调度，利用hash-map寻找优先级最高的进程。

Q8:在内存初始化中，怎么探测剩余内存的。

A:镜像在bss段的最后会创建的一个标记叫做end,可以探测一个cmos管知道总共的内存大小，可以间接知道剩余内存的大小。

Q9:为什么对内存进行4kb分割，如何对页表做标记

A:这是i386的MMU要求的吧，因为页表是4kb对齐的所以低12位是零每一个比特位都可以携带信息。

Q10:描述一下fork中你提到的缺页中断的执行步骤

A:首先当写一个标记为不能写的地址时，会触发缺页错误，处理器读取idt获取相应中断向量的地址，中断向量是一段汇编指令主要是储存现在寄存器的内容，跳转到isr中。此时错误地址存放在cr2中。跳转到相应的isr，检测缺页错误是否是fork标记的写时拷贝标志。如果是申请一个新的页，拷贝原来的内容然后返回错误处的地址。

Q11:返回错误处的地址具体是哪个地址，是错误的那条指令还是下一条

A:看保存的eip地址，缺页中断保存的是错误的指令地址，其他的一些systemcall是下一条指令地址

**然后面试官建议我更新一下简历，把这个项目写上，还是非常感谢芯动的，面试官都很不错，尤其这位面试官给了我非常关键的建议。反问就问了工作内容，具体做什么。**