嵌入式：

https://www.nowcoder.com/issue/tutorial?zhuanlanId=jvN8gj&uuid=d670a77f3799456ea5efb0c67f78b2e7

https://www.nowcoder.com/feed/main/detail/d83fab620cac4906b80d2567dc40e434?sourceSSR=users

https://www.nowcoder.com/issue/tutorial?zhuanlanId=3m2ONj&uuid=5db02cff5d50428b9efd8d2f851a8c70





聊了四十多分钟，感觉聊了很多东西，项目细节，八股，现场写代码。还聊了研究生的一些课题相关和生活。

TCP和UPD三次握手的八股文没答上来，问了**tasklet**，不太熟没答全



中断可分为两部分，

Tasklet机制是一种较为特殊的软中断。

有写内核任务需要延后执行，因此才有的下半部，进而实现了三种实现下半部的方法。这就是本文要讨论的**软中断**、**tasklet**和**工作队列**。





笔试：选择、填空、简答、编程

C语言知识、逻辑推理

## ACM

```c
#include <stdio.h>
int main() {
    int a, b;
    while (scanf("%d %d", &a, &b) != EOF) {
        // 64 位输出请用 printf("%lld") to 
        printf("%d\n", a + b);
        float a=12; // 声明变量 
   		printf("%.2f",a); // 保留两位数小数
        const char* a="hello world";//声明变量 
   		printf("%s*",a);
    }
    return 0;
}

#include <stdio.h>
int main() {
    int a = 0;
    int sum = 0;
    while (scanf("%d", &a) != EOF) {
        sum += a;
        if (getchar() == '\n') {
            printf("%d\n", sum);
            sum = 0;
        }
        
    }
}


// 字符串排序
// 输入:
// 5
// c d a bb e
#include <stdio.h>
int main() {
    int num;
    scanf("%d", &num);
    char str[num][100];
    for (int i = 0; i < num; i++) {
        scanf("%s", str[i]);
    }
    qsort(str[0], num, sizeof(str)/num, strcmp);
      
    for(int i=0; i<num; i++)
    {
        printf("%s ",str[i]);
    }
    return 0;
}

// 空格隔开
#include"stdio.h"
int main() {
    char tmp[100];
    while (scanf("%s", &tmp) != EOF) {
        char str[100][100];
        int i = 0;
        strcpy(str[i], tmp);
        while (getchar() == ' ') {
            scanf("%s", &tmp);
            strcpy(str[++i], tmp);
        }
        qsort(str[0], i + 1, sizeof(str) / 100, strcmp);
        for (int j = 0; j < i; j++) {
            printf("%s ",str[j]);
        }
        printf("%s\n", str[i]);
    }
}

// 对于每组用例输出一行排序后的字符串，用','隔开，无结尾空格
// 输入格式：
// a,c,bb
// f,dddd
#include <stdio.h>
#include <string.h>
 
int main()
{
    char str[10][100];
    char temp[100];
    while(scanf("%s",temp)!=EOF)
    {
        // 可以记下来，固定格式
        char* p=strtok(temp,",");
        int i=0;
        while(p)
        {
           strcpy(str[i++],p);
           p=strtok(NULL,",");
        }
        
        qsort(str[0],i,sizeof(str)/10,strcmp);
        
        for(int j=0; j<i-1; j++)
        {
            printf("%s,",str[j]);
        }
        printf("%s\n",str[i-1]);
    }
    return 0;
}
```

## 编程题

### 回文

```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

bool is_palindrome(char* s){
    if (NULL == s){
        return true;
    }
    char* head = s;
    char* tail = s + strlen(s) - 1;
    while (tail > head){
        if (!isalnum(*head)){
            head++;
            continue;
        }
        if (!isalnum(*tail)){
            tail--;
            continue;
        }
        if (*head != *tail){
            return false;
        }
        head++;
        tail--;
    }
    return true;
}

int main(void){
    bool result = false;
    char src[] = "bookoob";
    result = is_palindrome(src);
    if (result){
        printf("string is palindrome!\n");
    } else {
        printf("String is not palindrome!\n");
    }
    return 0;
}
```

### 快排

https://leetcode.cn/problems/sort-an-array/solution/912-pai-xu-shu-zu-by-duanyutian-j7c3/

```c
void swap (int* a, int * b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
void quicksort(int nums[], int left, int right) {
    if (left >= right) return;
    swap(&nums[right], &nums[rand() % (right - left + 1) + left]);
    int pivot = nums[right];
    int lt = left - 1, rt = right, cur = left;
    while (cur < rt) {
        if (nums[cur] < pivot) swap(&nums[++lt], &nums[cur++]);
        else if (nums[cur] > pivot) swap(&nums[--rt], &nums[cur]);
        else cur++;
    }
    swap(&nums[right], &nums[rt]);
    quicksort(nums, left, lt);
    quicksort(nums, rt, right);
}
int* sortArray(int* nums, int numsSize, int* returnSize){
    // 升序
    quicksort(nums, 0, numsSize - 1);
    *returnSize = numsSize;
    return nums;
}
```

### 翻转链表

请用C语言程序完成此题。

Typedef struct node

{

int data;

struct node *next;

}pnode;

由上述结构体构成的链表list，请将list反转过来，如A->B->C->D变为D->C->B->A，并返回链表头。pnode reverse list(pnode list);

```c
#include<stdio.h>
#include <stdlib.h>
#include <math.h>
typedef struct node {
	int data;
	struct node* next;
}pNode;

// 输入并创建链表
pNode* InputList(void)
{
	int val;
	pNode* pHead = (pNode*)malloc(sizeof(pNode));
	pNode* cur = pHead;
	int num[100];
	int n = 0;
	printf("输入链表值，以空格分隔：");
	while (scanf("%d", &val) != EOF) {
		num[n++] = val;
		if (getchar() == '\n') {
			break;
		}
	}
	for (int i = 0; i < n; i++)
	{
		if (i == 0)
		{
			cur->data = num[i];
			cur->next = NULL;
		}
		else
		{
			pNode* newNode = (pNode*)malloc(sizeof(pNode));
			newNode->data = num[i];
			newNode->next = NULL;
			cur->next = newNode;
			cur = newNode;
		}
	}
	return pHead;
}

void PrintList(pNode* head)//打印链表
{
	while (head)
	{
		printf("%d",head->data);
		if (head->next)
			printf(" -> ");
		head = head->next;
	}
	printf("\n");
}

// 反转链表
pNode* reverseList(pNode* head) {
	// struct node* next;
	pNode* next, *pre = NULL, *cur = head;
	while (cur) {
		next = cur->next;
		cur->next = pre;
		pre = cur;
		cur = next;
	}
	return pre;
}

	
int main()
{
	pNode* head = InputList();
	printf("输入格式：\n");
	PrintList(head);
 
	head = reverseList(head);
	printf("反转后格式：\n");
	PrintList(head);
 
	system("pause");
 
	return 0;
	
}

```



### 循环链表删除节点



删除链表的节点

输入
N1 N2 N3 N4 N5
N1

输出
N2 N3 N4 N5

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct tagNode {
    char* val;
    struct tagNode *next;
} Node;

int main() {
	char str[10][100];
    char temp[100];
	scanf("%s",temp);
    // 可以记下来，固定格式
    char* p=strtok(temp,",");
    int i=0;
    while(p)
    {
        strcpy(str[i++],p);
        p=strtok(NULL,",");
    }
    Node *head = (Node*)malloc(sizeof(Node));
    Node *tmp = head;
    for(int j=0; j<i; j++)
    {
		Node *node = (Node*)malloc(sizeof(Node));
		node->val = str[j];
		tmp->next = node;
		tmp = node;
    }
    /////////// 找那个结点 ///////////
    Node* tmp2 = 
    scanf("%s",temp);
    
    tmp->next = NULL;
    
    Node* slow = head;
    Node* fast = head->next;
    Node* pre;
    while (fast && fast->next) {
		if (slow == fast) {
			pre->next = slow->next;
		}
		pre = slow;
        slow = slow->next;
        fast = fast->next->next;
    }
    // 找循环链表的头结点
    
    return 0;
}
```



### 底层函数strncpy编写

**char \*strncpy(char \*dest, const char \*src, size_t n)** 把 **src** 所指向的字符串复制到 **dest**，最多复制 **n** 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充。

```c
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

char *Test_strncpy(char *dest, const char *src, size_t count)
{
	assert(dest != NULL);//保证dest非空
	assert(src != NULL); //保证src非空
    char *tmp = dest;
    while (count) {
		*tmp = *src;
        src++;
        tmp++;
        count--;
    }
    return dest;
}
```



## 简答

### 宏定义的展开

C语言中，宏是在预编译时用宏体内容“文本替换”代码中的宏名的。

**宏定义可以嵌套**



**#define <宏名/标识符> <字符串>**

* 一个较长的宏定义可以分成若干行，这需要在待续的行末尾加上一个反斜杠符”\”
* 一般的展开规律像函数的参数一样：先展开参数，再分析函数，即由内向外展开

“#”是将宏参数转换为字符串。不管该参数宏什么，即“原貌”用字符串显示出来。 即**将宏参数用双引号“”包裹起来形成一个字符串**。例如

```cpp
#define T(x) #x
int temp = 10;
cout<<T(temp)<<endl;//输出 temp 而不是 10
// T(temp) -> "temp"  (将宏参数用双引号包含起来形成一个字符串)
```

“##”被称为连接符（concatenation），把宏参数与之前的token(参数／字符串空格等)连接起来。例如

```text
#define T(x) x##[2]
int a[5] = {1,2,3,4,5};
cout<<T(a)<<endl; //输出 3 即 a[2]
```





### 结构体的声明

```c
/*图书的结构体类型声明*/
struct Book
{
	int a;
};
/*结构体变量定义*/
struct Book book1;  //book1 为结构体变量

    
/*图书的结构体类型声明*/
struct Book  
{
	char ISBN[20];  //图书的ISBN码
	char name[50];  //图书名称
	float price;  //价格
}book2;


typedef struct Book  
{
	char ISBN[20];  //图书的ISBN码
	char name[50];  //图书名称
	float price;  //价格
}strBook;  //strBook为结构体类型
strBook book6;  //book6 为结构体变量
```



### open函数

int open( const char * pathname,int flags, mode_t mode);

文件路径、flag、mode

flag:

***O_RDONLY*** 以只读方式打开文件
**O_WRONLY** 以只写方式打开文件
**O_RDWR** 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合.

mode:

**mode，只有在建立新文件时才会生效**

返回值：成功则返回文件描述符，否则返回 -1

```c
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <fcntl.h> // 头文件
int main() {
	int fd1, fd2;
	char c;
	fd1 = open("foobar.txt",O_RDONLY,0);  // foobar
	fd2 = open("foobar.txt",O_RDONLY,0);
	read(fd1,&c,1);
	read(fd2,&c,1);
	printf("c= %c \n",c);  // 输出f
}
```

### **vector和list的底层数据结构**
vector底层数据结构是一个连续的动态数组，它在内存中是一段连续的空间，可以通过指针进行随机访问。当vector的元素数量超过了它的容量时，vector会重新分配一块更大的内存空间，并将原来的元素复制到新的内存空间中。因此，vector的插入和删除操作可能会导致内存重新分配和元素复制，效率较低。

list底层数据结构是一个双向链表，每个节点包含了元素的值和指向前一个节点和后一个节点的指针。由于list是一个链表，所以它的插入和删除操作非常高效，不需要进行内存重新分配和元素复制。但是，由于list的元素在内存中不是连续的，所以无法进行随机访问，只能通过遍历链表来访问元素，效率较低。

因此，如果需要进行随机访问操作，应该选择vector；如果需要进行频繁的插入和删除操作，应该选择list。





### 移码



正数移码 = 正数原码符号取反
负数移码 = 原码全部取反后 + 1 = 补码的符号位取反

移码转换通常指将一个数值从原码表示转换为补码表示，或者从补码表示转换为原码表示。

原码表示是最基本的表示方法，即将一个数值的符号位和数值位分开表示，符号位为0表示正数，符号位为1表示负数，数值位表示数值的大小。例如，十进制数-5的原码表示为10000101。

补码表示是为了解决原码表示中0的表示问题而引入的一种表示方法。在补码表示中，正数的补码与原码相同，负数的补码为其绝对值的原码按位取反再加1。例如，十进制数-5的补码表示为11111011。

在C语言中，可以使用位运算符来进行移码转换。例如，将一个数值从原码转换为补码，可以使用以下代码：

```
int original = -5; // 原码表示
int complement = ~original + 1; // 补码表示
```

将一个数值从补码转换为原码，可以使用以下代码：

```
int complement = 0b11111011; // 补码表示
int original = ~complement + 1; // 原码表示
```

移码是指将一个数的二进制表示向左或向右移动指定的位数。移动时，高位或低位的空位用0填充。

移码有两种操作：左移和右移。

左移操作（<<）将一个数的二进制表示向左移动指定的位数，相当于将这个数乘以2的移动位数次方。例如，将数值10左移2位，得到的结果是40（10 * 2^2 = 40）。

右移操作（>>）将一个数的二进制表示向右移动指定的位数，相当于将这个数除以2的移动位数次方。例如，将数值10右移2位，得到的结果是2（10 / 2^2 = 2）。







请写出float x 与“零值”比较的if 语句：
const float EPSINON = 0.00001;
if ((x >= - EPSINON) && (x <= EPSINON)



求n是否2的幂次方、判断n的最高8位不为0、类的构造析构时机









在C语言中，将函数指针作为函数入参的正确写法如下：

```c++
void function_name(int (*function_pointer)(int, int)) {
    // 函数体
}
```







前面的有不定项选择 单选（里面还有智商逻辑题） 填空题（代码改错题 代码补全) 涉及到微机原理？操作系统 少量c++概念性知识 然后剩下的就是c语言挺多的 总体来看 难度不大 （个人感觉操作系统要多熟悉）





联发科笔试中几乎每年都会出现的一个开放性的题目：**请描述一下你在学校完成的项目的架构和自己负责的部分，在项目中有什么收获等等**，**这个题是大家现在就可以提前准备好的，选取1个自己最拿得出手的项目去写就ok了，想好怎么去描述自己的项目，如果能画出来系统架构图、系统结构框图之类的，然后结合简短的描述就很ok了。**

纯多选题（类似牛客C语言题库）
填空题（类似输出结果，代码补全）
编程题（C语言，15分占比很小）

