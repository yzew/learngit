# HR

> 看过哪些技术书籍

C++ Primer

effective STL effective C++

STL源码剖析

深度探索C++对象模型（主要看了多态相关内容

> 实习的收获

一个是参与了软开项目从提需求、沟通需求、实现、发版，再到给操作人员使用的一个完整的流程。认识到了沟通的重要性，有效的沟通后才能明确需求，知道自己需要补充什么功能，实现什么样的效果

另一个是负责了一个OCR检测识别的需求的落地，认识到工业项目和研究的一个差距，更偏向于数据的清洗，以及选择比较成熟的方法来应用到我们的需求上去

最后是让我感受到了工作的氛围，大部分同事都专注于自己的工作，效率都非常高，像是在学校，没那么清晰的deadline，就不会有那种忙碌的紧张感。

> 实习上有没有碰到什么沟通问题

​	一开始是有的，就是让我搞二次开发的时候，是因为一个软件不再提供支持了，leader是想让我去对标这个软件来实现一些功能，但他不知道我根本没装也不知道这个软件，就只是提了一些比较抽象的需求，然后我当时也没想到我是还能装这个软件的，因此也没问，就导致最后做出来的效果和他预想的不一样，然后他拿那个软件给我展示的时候我才知道这原来是还能用的。

> 如何用c++进行深度学习模型部署

windows下的静态库和动态库是lib和dll，linux下的是a和so

​	这个刚好我搞了一部分。用C++部署一是因为C++在性能计算上优于Python，二是因为我们这是打算在C#里去调用他，所以采用了编译为dll的方式。对于这个Paddle的话，他是有提供C++的推理库的。我在训练出检测、识别模型，再将其转换为推理模型后，就不需要再去使用他那个有大量冗余功能的PaddleOCR，而是可以去下载对应的推理库，比如我下载的就是Windows版本的，然后根据自己的需求在里面添加一些函数，然后用cmake编译为dll，这样就可以在C#程序里面调用我们这个功能。

​	当然也可以编译为exe文件进行调用



在C++中封装为一个dll，其中使用 _declspec(dllexport) 关键字从 DLL 中导出数据、函数、类或类成员函数。

在C#项目中使用DllImport特性导入这个dll，并调用其中的函数

```
[DllImport("MyLib.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern int addition(int a, int b);
```



> 对 CAD 软件以及中望的了解

​	美国的Autodesk

**CAD**—计算机辅助设计（Computer Aided Design,CAD）

​	涉及用电脑建模、绘图等领域。可以用来进行机械制图等。我在本科上过工程制图课，记得要画各种螺纹之类的，就都是用尺子和那个T型的大尺子画图，非常不方便，像这种CAD就可以实现在电脑上绘图，更精准且易于保存图纸。

​	下载中望的ZWCAD软件，试用30天看了看，感觉提供的功能还是很齐全的，界面看着也比较高级。

**CAE**——计算机辅助工程（Computer Aided Engineering,CAE）



德国西门子集团宣布终止与中国防务公司Transemic的商业合作

> 对cad领域未来发展的看法
>
> cad就业面窄，有啥看法

​	感觉还是比较有前景的，一方面有国家的支持如减免税收，一方面有很多企业也都在用中望的这个软件，也是有赢利点的。看了看财报，感觉在研发投入上也很重视，投资上也还是“买入”评级，感觉起码干个几年没啥问题，等到时候在中望的工作也稳定下来了。

​	但感觉就业面确实是有点窄的，就大概率只能搞CAD CAE相关了。但其实只要公司稳定盈利，能一直留在公司也挺好的，肯定都比较喜欢安稳嘛。



职业规划，技术栈规划  

cad软件用过吗

> 你有啥缺点、周围人怎么评价你的

缺点的话，我朋友会评价我比较卷吧，就是闲不下来。但我感觉我一直在忙，是因为事情确实多，平时要搞实验室的项目和实验，又得搞软件开发的技术栈，闲下来又想去看看一些技术博客，我都感觉我的时间太少，要深度学习软开两手抓，没空专心的提升技术。但我每周的休息时间也是有规划的，周五周六周日会休息一个晚上加两个半天，出去转一转吃个饭打打游戏之类的。只能说我现在的情况不允许我有太多的休息时间，等毕业论文搞定，我只专心于提升软开的技术的时候，那时候就会有更多的空余时间去休息了。



空闲时间怎么安排的

高考成绩

手上的offer

未来规划

> 认为相比其他面试者 优势在哪

1、基础扎实，学习态度好。我的学习生涯的话，高考稳定发挥，大学保送，研究生也有很多产出，实习也有一些成果，可以表明我的学习态度是很认真的，不会有那种撂担子、自暴自弃等现象，智商也是正常的，可以说比较稳定吧，然后奖学金也有很多，可以说是有一定的进取心的。

2、性格比较温和，不吵架不骂人，比较理性。之后工作与人沟通的时候起码不会和人大吼大叫的骂起来。我之前实习的时候，旁边那个团队就比较凶，和leader聊的时候leader就说他们团队就是有几个比较能吵的。我感觉这种老吵架，是会降低工作效率的。

3、稳定性强。老家在山东临沂，没啥比较合适的企业。然后是武汉本地的学校，比较倾向于留在武汉

4、有技术追求。我还是比较倾向于保持在中上游水平的，因此如果我觉得我的技术有待提高，是会去积极寻求技术突破的，不是那种比较摆烂的。



> 最大的优点和缺点是什么

优点：各方面都很稳定。学习上能稳定在前列，工作上也能稳定的完成实验室项目、实习的项目等

缺点就是比较有规划性，体现在我手头有任务时会规划好完成他的步骤和时间，如果有任务加塞，会有些不开心，也会打乱我原来的节奏，我会以原先的任务为主。就是说有点单线程，不能同时搞多个事情。

> 怎么看待工业软件的发展，和互联网相比呢

盈利上看是没互联网好的，优点是比互联网稳定，工作年限更久



> 为什么选中望

钱多事少，我的期望工作地是武汉，所以也可以加上一个离家近



自己经历过的压力最大的事情是什么

最近主要是怎么提升自己的

学习有计划么

做过windows相关开发么？能否接受

> 领导给你个工作，但时间不够怎么办

会先跟领导沟通一下，说一下工作量以及预计完成的时间，需要加几个人才能按时完成。如果不加人搞的话我就能完成多少就做多少，因为也提前跟领导沟通过了，实在不能按时完成也没办法。

> 领导让你干活, 没给你提具体的需求怎么办

找领导问具体的需求。
如果他答复说自由发挥，尽量做好的话，我会去了解一下有没有类似的需求参照一下。
如果都没有的话就先快速搞一个初版出来，然后跟领导对一下，没有问题就继续优化。

> 团队任务中，其他人不配合怎么办

* 沟通，问下是为什么不配合，尝试解决矛盾
* 沟通无效，找上层领导换人

> toB还是toC有什么看法, 工业软件, 互联网, 金融软件怎么看

* 对ToB产品来说，面对的是客户（Business），客户是各种企业，组织机构。
* 对ToC产品来说，面对的是用户（customer），用户是普通大众，是消费者。
* 对ToB产品来说，决策权主要集中在企业管理层，由管理层做最终决定，但实际使用者可能是公司职员或特定人群。一般需要经过培训学习使用。由于企业是花钱购买，成本比较大，且员工也熟悉了如何使用，因此企业一旦采购，更换的意愿就会比较低。就比如实习的时候，写C#一般用的是VS，结果因为制裁，不能用了，更换了Rider，整个就很难受，所以一般ToB产品都比较稳定，企业用了后就很少会去更换了，因为存在开发者的使用成本问题，所以我觉得搞ToB还是挺好的 
* 对ToC产品来说，决策权和使用权都在用户手中。用户会根据自己的喜好选择产品使用，比如购物APP，有人喜欢用淘宝，有人喜欢用京东，有人喜欢用唯品会等等。由于几乎没有更换成本，用户一旦发现更能满足自己的需求的产品，更换的意愿会比较高。所以迭代会比较快。感觉也更赚钱

> 平时做笔记总结的内容    



> 选择一家公司，从哪些因素考虑    

> 硕士期间最佩服的人    

> 自己三个最大的优点  







# 笔试



## 计算多边形面积

> 叉积：结果是一个向量，大小等于两向量围成的平行四边形面积

鞋带定理：使用叉积计算多边形的面积是一种常用的方法。这种方法基于向量的性质，通过将多边形分割成多个三角形，然后计算每个三角形的面积，最后将所有三角形的面积相加得到多边形的总面积。

假设我们有一个多边形的顶点坐标存储在一个向量（或数组）中，按照顺时针或逆时针顺序排列。为了计算多边形的面积，我们需要遍历每个顶点，并计算它与相邻两个顶点形成的向量的叉积。具体的步骤如下：

1. 遍历多边形的每个顶点，计算当前顶点与下一个顶点形成的向量，然后计算这个向量与下一个向量的叉积。注意，最后一个顶点与第一个顶点形成的向量也要考虑在内。
2. 将所有三角形的面积相加得到多边形的总面积。

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct Point {
	double x, y;
};

double polygonarea(vector<Point>& polygon)
{
	int n = polygon.size();
    int i, j;
    double area = 0;
    for (i = 0; i < n; i++) {
        j = (i + 1) % n;
        area += polygon[i].x * polygon[j].y;
        area -= polygon[i].y * polygon[j].x;
    }
    area /= 2;
    return(area < 0 ? -area : area);
}

int main(){
    int n;
    cin >> n;
    vector<Point> polygon(n);
    for (int i = 0; i < n; i++) {
		double x, y;
        cin >> x >> y;
        polygon[i].x = x;
        polygon[i].y = y;
    }
    cout << polygonarea(polygon) << endl;
    return 0;
}
```



## 判断点是否在多边形内部

> 仅适用于简单多边形

要判断一个点是否在多边形内部，可以使用射线法。

这个算法的基本思想是从该点引一条射线，然后统计这条射线与多边形各边的交点个数，如果交点个数是奇数，则说明该点在多边形内部；如果交点个数是偶数，则说明该点在多边形外部。

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct Point {
    double x, y;
};

bool inside(Point point, vector<Point> polygon) {
    int n = polygon.size();
    if (n < 3) return false;

    int count = 0;
    for (int i = 0; i < n; ++i) {
        int j = (i + 1) % n;
		// 如果在两个点范围内
        if ((polygon[i].y <= point.y && point.y < polygon[j].y) ||
            (polygon[j].y <= point.y && point.y < polygon[i].y)) {
            // intersectionX为该边与点的水平线的交点
            // (point.y - polygon[i].y) 是y
            // (polygon[j].x - polygon[i].x) / (polygon[j].y - polygon[i].y)是斜率
            // 相乘就是point和线间的x
            double intersectionX = (point.y - polygon[i].y) * (polygon[j].x - polygon[i].x) / (polygon[j].y - polygon[i].y) + polygon[i].x;
            // 如果交点在点的右侧
            if (point.x < intersectionX) count++;
        }
    }
	// 奇数个交点则在内部
    return (count % 2 == 1);
}

int main() {
    int n;
    cin >> n;

    vector<Point> polygon(n);
    for (int i = 0; i < n; ++i) {
        cin >> polygon[i].x >> polygon[i].y;
    }

    Point point;
    cin >> point.x >> point.y;

    cout << inside(point, polygon);

    return 0;
}
```



## 最长回文子串

最长回文子串(https://leetcode.cn/problems/longest-palindromic-substring/)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        string tmp = "";
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {  // j >= i
                if (s[i] == s[j]) {
                    if (j - i <= 1 || dp[i + 1][j - 1]) {
                        dp[i][j] = true;
                        if (j - i + 1 > tmp.size()) tmp = s.substr(i, j - i + 1);
                    }
                }
            }
        }
        return tmp;
    }
};
```



[面试题 17.10. 主要元素](https://leetcode.cn/problems/find-majority-element-lcci/)

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int pre = nums[0];
        int count = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] == pre) count++;
            else count--;
            if (count == 0) {
                count = 1;
                pre = nums[++i];
            }
        }
        // 判断一下这个元素是不是最大元素
        count = 0;
        for (auto i : nums) {
            if (i == pre) count++;
        }
        if (count > nums.size() / 2) return pre;
        else return -1;
    }
};
```



## 环形链表找入口

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast -> next -> next;
            slow = slow -> next;
            if (fast == slow) {
                // 找到了第一次相遇的交点
                // 这里可以创建两个新指针分别指向head和交点，这里就直接用fast和slow了，但要注意他们的含义已经变了
                fast = head;
                while (fast != slow) {
                    fast = fast -> next;
                    slow = slow -> next;
                }
                return fast;
            }
        }
        return NULL;
    }
};
```









