## hr

​	面试官好，我是王皓。很高兴能参加此次芯原的面试，下面我将对我的教育经历、项目经历、实习经历等进行一个简要的介绍。

​	我是一个山东人，因此本科选择了山东大学自动化专业。本科阶段专业排名第7，并多次获得山东大学一等奖学金。研究生阶段想去外省体验一下，刚好我姐姐在华农读书，因此保送时选择了华中科技大学人工智能与自动化学院。研究生期间曾获华中科技大学一等硕士学业奖、新生奖学金等。

​	个人技术上，擅长C++软件开发方向，做过一些相关的项目如分布式网络通信框架、WebServer等；其次擅长深度学习方向，做过一些校企合作的项目。

​	实习方面选择了武汉的华为，在海思实习了两个月，期间独立完成了视觉软件开发和OCR检测识别两项任务，均交付使用。



​	Hello, interviewer. I'm Wang Hao. I'm delighted to be invited to this interview. I will provide a concise /kənˈsaɪs/ overview of my educational background, project involvements, and internship experiences.

​	Being a native of Shandong, I made the decision to pursue a degree in automation at Shandong University for my undergraduate studies. Throughout my undergraduate journey, I achieved the 7th rank within my major and was honored with the first prize of the Academic Scholarship several times.

​	Upon entering graduate school, I aspired to gain experience in a different province. Coincidentally [kəʊˌɪnsɪ'dentəlɪ] , my sister was enrolled at Huanong, prompting me to select the School of Huazhong University of Science and Technology. Throughout my graduate journey, I was honored with the first prize of the Academic Scholarship and the freshman scholarship. 

​	In terms of personal technology, I excel in the realm of C++ software development. I've undertaken various related projects, including a distributed network communication framework and a WebServer. Additionally, I'm good at the direction of deep learning, and have actively engaged in school-enterprise cooperation projects.

​	For my internship, I chose Huawei in Wuhan and worked at Hesse for a duration of two months. During this period, I autonomously two assignments independently: visual software development and OCR detection and recognition. 

​	That concludes my introduction. Thank you.

## 精简版

​	Hello, interviewer. I'm Wang Hao. I'm delighted to be invited to this interview. I will provide a concise /kənˈsaɪs/ overview of my educational background, project involvements, and internship experiences.

​	Being a native of Shandong, I made the decision to pursue a degree in automation at Shandong University for my undergraduate studies. Throughout my undergraduate journey, I achieved the 7th rank within my major and was honored with the first prize of the Academic Scholarship several times.

​	Upon entering graduate school, I select the School of Huazhong University of Science and Technology. Throughout my graduate journey, I was honored with the first prize of the Academic Scholarship and the freshman scholarship. 

​	In terms of personal technology, I excel in the field of C++ software development. I've undertaken various related projects, including a distributed network communication framework and a WebServer. Additionally, I'm good at the direction of deep learning, and have actively engaged in school-enterprise cooperation projects.

​	For my internship, I chose Huawei in Wuhan and worked at Hesse for a duration of two months. During this period, I achieved two assignments independently: visual software development and OCR detection and recognition. 

​	That concludes my introduction. Thank you.





## 最爱的城市

​	My favorite city is my hometown of Linyi, located in Shandong Province. 

​	Although Linyi is not very famous, there are a lot of scenery there, including Yimeng Mountain and the former residence of Wang Xizhi

​	Additionally, Linyi also has a lot of special snacks, such as Linyi Fried Chicken, 糁 and so on!

​	Most importantly, my parents and good friends are in Linyi. Linyi is my hometown and my favorite city!

## 优缺点

​	One of my strength is that I plan a task before I do it, so I always get it done on time!

​	In addition, I am very responsible

​	My weakness is that I'm not good at making quick decisions

## 家乡在哪

​	My hometown is Linyi, located in Shandong Province.
​	It was called Langya in ancient times. 
​	Although Linyi is not very famous, there are a lot of scenery there, including Yimeng Mountain and the former residence of Wang Xizhi
​	Additionally, Linyi also has a lot of special snacks, such as Linyi Fried Chicken, 糁 and so on!

## 定居地选哪里

​	If I have a chance to choose a place to live, I will choose ChengDu. 
​	ChengDu is a beautiful and well-developed city. And there are many famous companies in Chengdu, so it is more suitable for employment.
​	Most importantly, my girlfriend is in Chengdu

## 爱好

​	I have many hobbies. First of all, in terms of sports, I like playing table tennis and badminton. In terms of entertainment, I like listening to music, playing games and reading novels。



## 最喜欢的水果

My favorite fruit is watermelon. In a hot summer, eating an iced watermelon can quench my thirst and relieve the heat. At the same time, watermelon is good in quality and cheap in price, and will not be as expensive as other fruits,

## 其他



商业模式：

​	**公司专注于芯片定制和半导体 IP 授权服务。** **芯原是一家依托自主半导体 IP，为客户提供平台化、全方位、一站式芯片定制服务和半导体 IP 授权服务的企业。**



成都：oppo、联发科、帆软、深信服、29、绵阳九院、天翼云

芯原的企业文化是：公正（Fair）、关爱（Care）、分享（Share）、快乐（Cheer）。

芯原成立于 2001 年，总部位于中国上海，在中国和美国设有 7 个设计研发中心，全球共有 11 个销售和客户支持办事处，目前员工已超过 1,400 人。

芯原：芯片设计平台即服务



二面（hr面）
1.英文自我介绍
2.就是常见的家里基本条件，为什么想来这里，为什么选择这个城市（常见的hr面试问题）

反问：

什么时候出hr面结果

啥时候ceo面？

要到学校发三方了芯原这边才会出录用结果么么？

加班情况？保证双休么







#### 介绍一下你尊敬的人，详细描述/崇拜的人

The person I respect the most is my high school teacher. He is a very dedicated teacher. He teaches very carefully and explains every knowledge point in detail. And he also cares about our lives. When he finds that we have difficulties in life, he always contributes money and effort for us without hesitation.



#### 6、介绍一下你最好的朋友，怎么认识的，详细描述。

My best friend's name isXXX. He was my high school classmate and also my bottom bunk。It's strange that I don't remember the reason why we became best friends at all. It may be that we have the same personality and are naturally close, as if we had always been best friends.



#### 1、你上一个春节是怎么度过的

In the last Spring Festival, first my family and I got together and had a New Year's Eve dinner, and then we watched the Spring Festival Gala together. Finally, I keep the year old with my family.

#### 3大学时遇到过什么紧急的事情，如何解决的？

The most urgent thing I met in college was that one of my roommates suddenly fainted in my bedroom, which scared us all. We rushed him to the hospital, and finally found out that he only had a cold and a fever

#### 7、你享受困难的工作吗？

I like challenging work, and I like to overcome difficulties and discuss problems with my team. Difficult work can arouse my desire for challenge. At the same time, it will greatly improve my ability to cope with difficulties

#### 8、介绍

#### 10、介绍你的专业。

My major is electronic information engineering，It is the information industry and the important foundation for one of the pillars. It covers many research fields, such as digital circuits, analog circuits, signal transmission, image processing and so on。

#### 11、和他人交流有困难时如何解决？

First, listen to others patiently. Then express my thoughts clearly. For different opinions, there is no need to argue, they can be shelved for the time being, seek common ground while reserving differences, and finally reach an agreement

## 笔试

天府软件园C区十栋

![image-20230826104223422](E:\MarkDown\picture\image-20230826104223422.png)



1、芯原商业模式SiPaaS中第二个S指的是（） A. Solution B. Silicon C. Series **D. Service**

2、芯原的企业文化是（） A. 公正、友爱、分享、快乐| **B.** 公正、关爱、分享、快乐 C. 平等、关爱、分享、快乐 D. 诚信、关爱、分享、快乐





操作系统和C/C++的题



> 缓存替换的策略：

* LRU最近最少使用：替换最长时间未被访问的内存块
* FIFO先进先出：按添加到缓存中的顺序替换缓存块
* Random Replacement随机替换
* 等等



> pipeline和passage time

pipeline允许多个指令在同一时间在处理器上执行

passage time通道时间是指从一个指令进入pipeline到完成并且结果可用的时间



> 系统调用

是用户进程和操作系统内核之间的标准接口



> **fork**

* 在父进程中调用fork函数。fork函数会创建一个新的子进程，并返回两次。在父进程中，fork函数的返回值是子进程的进程ID（PID），而在**子进程中，返回值为0**。
* 在子进程中，**执行从fork函数之后开始的代码**。由于子进程是从父进程复制过来的，因此它会复制父进程中的所有数据和资源，包括代码、数据、堆栈、文件描述符等。
* 在父进程中，可以根据fork函数的返回值判断是否成功地创建了子进程。如果返回值为负数，则表示出现了错误；如果返回值为正数，则表示当前处于父进程中，在这种情况下可以使用waitpid函数等待子进程退出并获取其状态信息。
* 子进程在执行完毕后，可以通过调用exit函数来退出，并将退出状态传递给父进程。



> 字节序

```c++
int a = 0x11223344; // 四个字节，分别是44 33 22 11
char* b = (char*)&a;
printf("0x%x",*(b + 2)); // 0x22，因为是小端，从左数
```

0x12345678

<img src="E:\MarkDown\picture\image-20230827154302453.png" alt="image-20230827154302453" style="zoom:47%;" />

智力题：

* 中间的数字是前后两个字母之间间隔字母的个数再加一。如：R-T,中间含有1个**S**，所以就是2.
* 给一串数字找规律：第三个等于前两个之和除以2
* 给前俩图像，求第三个：从左到右三个图，有相同图案就消去，没有则保留

![image-20230826203344770](E:\MarkDown\picture\image-20230826203344770.png)

40



![image-20230826212314026](E:\MarkDown\picture\image-20230826212314026.png)

(1+1) / (1/300+1/450) = 360



<img src="E:\MarkDown\picture\image-20230826212445475.png" alt="image-20230826212445475" style="zoom:57%;" />

E



![image-20230826212535395](E:\MarkDown\picture\image-20230826212535395.png)

解析：A
有同样黑色就保留









<img src="E:\MarkDown\picture\image-20230826213101308.png" alt="image-20230826213101308" style="zoom:57%;" />

A. 14 B. 12 C. 9 D. 8 E. 6

[[40, 0, 20, 25], [40, 0, 35, 10], [50, 0, 20, 15], [0, 45, 25, 15],
[50, 35, 0, 0], [40, 45, 0, 0]，
[20, 35, 15, 15], [20, 45, 15, 5], [35, 25, 15, 10]]，9种







英文面：最爱的城市并介绍原因，或者**英文自我介绍**

算法编程题、项目经历、Linux、操作系统、编译相关的问题。



## 面试



进程线程怎么换

**进程切换：**

1. **保存当前进程上下文：** 当操作系统决定切换到另一个进程时，它首先会保存当前运行进程的上下文信息，包括寄存器、程序计数器、堆栈指针等。
2. **加载新进程上下文：** 操作系统从就绪队列中选择一个新的进程，然后加载其上下文信息，将寄存器、程序计数器、堆栈指针等更新为新进程的值。
3. **切换到新进程执行：** 操作系统将控制权交给新进程，使其开始执行。此时，新进程从上次中断的地方继续执行。

**线程切换：**线程切换的过程与进程切换类似，但由于线程共享同一个进程的地址空间，所以切换过程中不需要切换地址空间。





### const

**const**

const用来声明变量、成员函数等为不可修改的。

**const常量**

​	C 语言中，const用来限制一个变量，表示这个变量不能被修改，定义的const将重新分配一个内存空间，C语言对 const 的处理和普通变量一样，会到内存中读取数据。

​	C++ 中，编译器对const做了特殊处理，将const常量放到**符号表**中，少了读取内存的过程，直接从符号表中读取。优点是提高了程序执行效率，缺点是**不能反映内存的变化，一旦 const 变量被修改，C++ 就不能取得最新的值**。（const在c++中是可以修改的。

**const函数**

> const可以用来修饰返回值、形参和成员函数
>
> * const int& fun(int& a); //修饰返回值
>   a.fun(2)=3;
>
>   多是引用类型的情况下，为了避免返回值被修改的情况
>
> * 通常会选择引用传递，这样可以节省内存，有的时候我们并不希望改变实参的值，就要加上const关键字

​	常函数的作用就是不改变对象成员的值，常函数内**不可以修改成员属性**；成员属性声明时加关键字==mutable==后，变为**可变数据成员**，在常函数中依然可以修改。

**常量折叠、符号表/常量表**

​	**常量折叠**，即将const常量放在符号表中，给其分配内存，但实际读取时类似宏替换。或者说const变量（即常量）值放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化。

​	**符号表/常量表/Symbol Table**是分配给函数和变量的名称与其在内存中的地址的映射，包括类型、范围和大小等元数据。最终由编译器使用。编译后的目标文件中有一个称为符号表的数据结构，它将目标文件中的不同项目映射到链接器可以理解的名称

​	而对于const常量，在g++和dev c++编译器中可以通过加上==volatile==关键字进行修改，在VC++6.0编译器中不支持

```cpp
#include<stdio.h>
int main() {
    const volatile int i = 10;
    int* pi = (int*)(&i);  
    *pi = 100;  
    printf("*pi: %d\n",*pi);  // 100
    printf("i: %d\n",i);  // 100
    printf("pi: %p\n",pi);  // 0xbfd97228
    printf("&i: %p\n", &i);  // 0xbfd97228
    return 0; 
}
```

通过gdb查看其**汇编代码**（gdb，然后输入：disass main）可以发现，加上volatile后输入*pi 和 i 时均是从堆栈（即内存）中取数的。

![image-20230301115837236](E:\MarkDown\picture\image-20230301115837236.png)

而在去掉volatile后，pi和i的地址还是相同，但const 变量 i 的值是没有改变的。查看其汇编代码可以发现，输出 i 的值时直接将 0xa（10）值从符号表输出，即此处编译器进行了优化，没有从内存中读。而在此基础上加上volatile修改符，即告诉编译器该变量属于易变的，不要对此句进行优化，每次计算时要去内存中取数。

![image-20230301120045051](E:\MarkDown\picture\image-20230301120045051.png)

### const成员函数构成重载

因为函数签名不同，const成员函数会在函数名后加上const关键字，表示该函数不会修改对象的状态。

### 函数参数加const

值传递，即aa(const int a)不构成重载，这是顶层const，作为形参时会忽略

指针、引用作为参数加const构成重载，因为传进去是一个真实有效的值，它把a或者b直接传到函数中，这个const是有效的，因为他会影响到底传进去的这个参数能不能被修改。成员函数传递this指针 所以构成

### volatile

​	用于告诉编译器该变量的值可能会在程序执行期间被改变，因此需要在每次使用时从内存读取最新的值，而不是使用缓存中的旧值

​	直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制；例如，程序可能包含一个由系统时钟定时更新的变量；当对象的值可能在程序的控制或者检测之外被改变时，应该将该对象声明为 volatile；关键字 volatile 就是**告诉编译器不应对这样的对象进行优化(编译器的优化操作通常会将变量优化到寄存器chche中，若是不对变量进行改变，就直接读取寄存器中的值)，而是从内存中读取数据**，从而可提供特殊地址的稳定访问；

​	主要用于以下两种情况：

* **多线程环境下的共享变量：**在多线程环境中，如果一个变量被多个线程共享并且可能在一个线程中被修改，在另一个线程中被读取，可以保证对变量的访问不会被优化，从而保证线程之间的正确同步。
* **禁止编译器优化**





### 用户态和内核态的区别

​	用户态和内核态是计算机操作系统中两种不同的特权级别，用于控制程序的执行和访问硬件资源。它们之间的主要区别在于对系统资源的**访问权限**和**操作级别**。

1. **权限级别：**
   - **用户态：**运行用户程序。在用户态下运行的程序只能访问有限的资源，例如它们自己的内存空间（用户态的虚拟空间地址）和一些用户级别的资源。用户态下的程序不能直接访问硬件设备、执行特权指令或者操作操作系统的核心部分。

   - **内核态：**运行操作系统程序，操作硬件。内核态具有更高的权限，**可以访问全部的虚拟空间地址，允许程序访问所有硬件资源、执行特权指令以及调用操作系统的核心功能。**内核态下的程序能够执行敏感的操作，例如管理内存、文件系统、设备驱动等。

2. **系统调用：**

   - 在用户态下，当一个程序需要访问内核态的资源或执行特权操作时，它必须通过系统调用（System Call）来请求操作系统执行相应的操作。系统调用是从用户态切换到内核态的一种机制，操作系统会在内核态中执行请求的操作，然后将结果返回到用户态。

3. **切换开销：**

   - 从用户态切换到内核态会涉及上下文切换，这需要保存当前用户态程序的状态并加载内核态的状态。这种切换开销相对较大，因为涉及到寄存器的保存和恢复、内存的切换等操作。因此，频繁的用户态到内核态的切换会导致性能下降。

4. **安全性和稳定性：**

   - 用户态的程序受限于操作系统所提供的资源和接口，这种限制增加了系统的安全性和稳定性。即使用户态程序出现错误或崩溃，也不会影响操作系统的核心部分。

总之，用户态和内核态的区别在于权限、资源访问、系统调用等方面。操作系统通过这种权限分离机制，实现了对系统资源的控制和保护，确保了系统的稳定性、安全性和性能。







### 指针和引用的区别

* 引用是变量的一个别名，本身不是一种数据类型，因此引用本身不占用内存空间；而指针是通过一个指针变量指向变量的地址，需要占用内存空间，四字节或八字节
* 作为函数形参，引用只需要在被调函数中使用"&"操作符，引用的实参和形参是同一地址，对引用的操作与对变量直接操作效果完全相同；而指针在主调函数中需要使用"&"取地址操作符传递参数，在被调函数中需要使用"*"操作符来解引用
* 引用一旦声明就必须同时对其进行初始化，使其指向一个已经存在的对象；而指针可以指向为空；
* 引用初始化后就不能再指向其他对象；而指针则可以被重新赋值以指向其他变量
* 指针可以有多级，引用只有一级
* sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小 
* 场景：
  * 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
  * 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式  



### 进程间通信方式和优缺点

​	每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。

* 管道：
  * 遵循**先进先出**原则。
  * 管道传输数据是单向的，想要相互传输数据，需要创建两个管道实现通信。
  * 创建管道就是创建文件描述符，管道的本质是操作方式为文件的内存缓冲区。
  * 分为匿名管道和命名管道。
  * **对于匿名管道，它的通信范围是存在父子关系的进程**，通过fork复制父进程的文件描述符进行通信；**对于命名管道，它的通信范围是任意的进程**。
  * 优势是管道提供了进程之间的逻辑隔离，每个进程可以独立运行，从而降低了耦合度。
  * 适用场景：
    * **数据流处理：**当需要对数据进行串行处理，将一个进程的输出传递给另一个进程进行处理时，管道是一个有用的工具。
    * **简单通信：**对于简单的进程间通信需求，尤其是在命令行环境下，使用管道可以非常方便。
  * pipe函数建立的管道是半双工(只能一个方向上进行数据传输)的，socketpair函数建立的管道直接就可以实现全双工(数据可以在两个方向上进行数据传输)。

* 消息队列：
  * **消息队列是保存在内核中的消息链表**。
  * 信息处理不及时、内核区和用户区频繁的拷贝
* 共享内存shmget
  * 共享内存的机制，就是要通信的进程拿出一块虚拟地址空间来，映射到相同的物理内存中
  * 需要通过信号量实现进程安全
  * 优势
    * **高效：**共享内存是一种高效的进程间通信方式，因为数据直接存储在内存中，而不需要像管道那样进行数据复制和传递。
    * **实时性：**共享内存允许多个进程实时地访问和更新共享的数据，适用于需要快速数据传递的场景。
    * **适用于大数据量：**如果需要传递大量数据，共享内存可能比管道更高效，因为数据不需要复制，而是在进程之间共享。
* 信号
  * **对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**
  * 信号是进程间通信机制中**唯一的异步通信机制**
  * 有kill命令发送 SIGKILL 信号
* socket
  * 跨网络与不同主机上的进程之间通信



### gdb

gdb可以对可执行文件进行调试，在编译时需要打开调试选项(-g)

```shell
# -g 将调试信息写入到可执行程序中
gcc -g args.c -o app

# 正常编译时不添加 -g 参数
gcc args.c -o app1  

# 查看生成的两个可执行程序的大小
ll # 相当于 ls -l

#################################################################
-rwxrwxr-x  1 robin robin 9816 Apr 19 09:25 app*	# 可以用于gdb调试
-rwxrwxr-x  1 robin robin 8608 Apr 19 09:25 app1*	# 不能用于gdb调试
```



```shell
# 启动gdb
gdb app

# 如果是 int main(int argc, char* argv[]) 这种形式，需要传参的话：
# 设置的时机: 启动gdb之后, 在应用程序启动之前
set args 参数1 参数2 .... ...
# 查看设置的命令行参数
show args


# gdb 中启动程序，可以使用run或start
# run: 可以缩写为 r, 如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完了
# start: 启动程序，最终会阻塞在 main 函数的第一行，等待输入后续其它 gdb 指令
run
start

# 如果想让程序 start 之后继续运行，或者在断点处继续运行，可以使用 continue 命令，可以简写为 c
continue


# 设置断点：break / b
# 在当前文件的某一行上设置断点
b 行号
b 函数名		# 停止在函数的第一行
# 在非当前文件的某一行上设置断点
b 文件名:行号
b 文件名:函数名		# 停止在函数的第一行

# 删除断点
# delete == del == d
# 需要 info b 查看断点的信息, 第一列就是编号
d 断点的编号1 [断点编号2 ...]
# 举例: 
d 1          # 删除第1个断点
d 2 4 6      # 删除第2,4,6个断点

# 删除一个范围, 断点编号 num1 - numN 是一个连续区间
(gdb) d num1-numN
# 举例, 删除第1到第5个断点
(gdb) d 1-5

# 打印变量名
print 变量名
p 变量名

# 在断点上单步调试
# 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。
step
s

# 设置变量值
# 可以在循环中使用, 直接设置循环因子的值
# 假设某个变量的值在程序中==90的概率是5%, 这时候可以直接通过命令将这个变量值设置为90
set var 变量名=值

# 退出gdb
quit
q
```







使用gdb attach PID可以调试运行中的程序，如a.out进程，命令如下：

gdb attach 338821

进入gdb调试命令行以后，打印所有线程的调用栈信息，信息如下：
thread apply all bt命令查看所用线程堆栈信息

![image-20230411162959010](E:\MarkDown\picture\image-20230411162959010.png)
![image-20230411163033066](E:\MarkDown\picture\image-20230411163033066.png)

从上面的线程调用栈信息可以看到，当前进程有三个线程，分别是**Thread1是main线程，Thread2是taskA线程，Thread3是taskB线程**。

从调用栈信息可以看到，Thread3线程进入S阻塞状态的原因是因为它最后在#0 __lll_lock_wait () at，也就是它在等待获取一把锁(lock_wait)，而且堆栈信息打印的很清晰，#1  0x00007f9ca3cffb09 in pthread_mutex_lock () from /lib64/libpthread.so.0，Thread3在获取而获取不到，因此进入阻塞状态了。
Thread2同理。



### 结构体和类的区别

> struct和class的区别

* 默认的访问权限不同。class类中的成员默认是private属性的；struct结构体中的成员默认是 public 属性的；
* class继承默认是private继承，而struct继承默认是public继承；
* class以使用**模板**，struct不能使用模板。



**在 C 语言中：**

* struct只能包含成员变量，不能包含成员函数。
* C 中的结构体没有构造函数、析构函数、继承、访问控制等类似面向对象编程的特性。

**在 C++ 中：**

* 在 C++ 中，你可以使用 `struct` 来定义类，拥有封装、继承、多态等面向对象编程的特性。
* 结构体的定义也可以放在函数内部，使得结构体作用范围局限于函数内部。
* 可以在 `struct` 内部定义构造函数、析构函数，以及其他成员函数。



附：struct初始化方式

C语言里面的struct的初始化只有一种方式

```c++
struct stuinfo {
   char *name;
   int age;
};
struct stuinfo students[2] = {{"xiaowang",12}, {"xiaoli",22}};
```

C++里面的struct初始化有两种方式

方法一：按照C里面的方式     方法二：利用构造函数

```c++
struct stuinfo {
   std::string name;
   int age;
   stuinfo() {}
   stuinfo(std::string m_name, int age) : name(m_name), age(m_age) {}
};
stuinfo students[2] = {{"xiaowang", 12}, stuinfo("xiaoli", 22)}；
```





### C和C++区别

**1.面向对象编程：**

* C 语言是一种过程式编程语言，主要关注于过程和函数的编写，不支持面向对象编程。
* C++ 引入了类和对象的概念，支持面向对象编程，包括封装、继承和多态等特性。

**2.类和对象：**

* C 没有类和对象的概念，代码组织相对较简单。C是分为数据和函数，而函数可以处理Data产生的所有的数据，这些数据没有关键字的约束，是全局的，各个函数都可以去处理他
* C++ 允许定义类和对象，可以将数据和方法封装成一个整体，提供更好的抽象和封装。

**3.函数重载、运算符重载：**

* C 不支持函数重载和运算符重载。

**4.标准模板库（STL）：**

* C 没有标准模板库（STL），需要手动实现常用的数据结构和算法。
* C++ 提供了 STL，它包含了各种容器、算法和函数对象，可以大大简化和加速程序开发。

**6.异常处理：**

* C 不支持内置的异常处理机制，错误处理通常使用错误码或返回值。
* C++ 引入了异常处理机制，可以更好地处理运行时错误，增强代码的健壮性。

**7.命名空间：**

* C 没有命名空间的概念，容易引起命名冲突。
* C++ 引入了命名空间，可以将代码分组，避免命名冲突。

**8.内存管理：**

* C 使用 `malloc` 和 `free` 来动态分配和释放内存。
* C++ 使用 `new` 和 `delete` 运算符来动态分配和释放内存，还提供了 RAII（资源获取即初始化）的概念。

**9.扩展性：**

* C++ 可以与 C 语言代码兼容，可以使用 C 语言库，从而方便地与现有 C 代码进行交互。



### C++、C#、Python的区别

* Python 是解释型语言，C 和 C# 需要编译为二进制代码才能运行
* C++ 需要手动管理内存，C# 和 Python 都有垃圾回收机制
* C++ 和 C# 都是静态类型语言，需要在编译时明确定义变量的数据类型；Python 是动态类型语言，不需要在变量声明时指定数据类型，类型检查发生在运行时。



* 与 C++ 相比，C# 不支持多重继承（**当 B 类从 A 类派生，C 类从 B 类派生**），只能单一继承；
* C# 的接口与单一继承，承载着处理逻辑；
* C# 编程可用于创建控制台应用程序，Windows 应用程序，移动应用程序等。Windows 之外很少使用。



**应用领域：**

* C++ 通常用于系统编程、游戏开发、嵌入式系统和高性能应用。
* C# 主要用于 Windows 开发，包括桌面应用、Web 开发和游戏。
* Python 用于各种应用领域，包括 Web 开发、数据科学、机器学习、自动化脚本等。



### 虚拟内存的作用

* 虚拟地址是**操作系统提供的一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。**
* 为了在多进程环境下，使得**进程之间的内存地址不受影响，相互隔离**，比如使一个程序出错不会影响另一个程序，于是操作系统就为每个进程独立分配一套虚拟地址空间，每个程序只关心自己的虚拟地址，不用关心物理地址的事情。操作系统（内存管理单元MMU）将虚拟地址转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这就解决了**多进程之间地址冲突**的问题。
* 虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，操作系统会通过**内存交换**技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）
* 页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。



内存分段：段根据实际需求分配内存，所以有多少需求就分配多大的段，所以不会出现内部内存碎片。但可能会产生多个不连续的小段，会出现外部内存碎片

内存分页：一页的大小为 4KB。页与页之间紧密排列，没有外部碎片问题。但分配内存的最小单位是一页，因此有内部碎片问题。



### cmake

> ​	cmake可以更加简单的生成makefile文件给make用，根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。
>
> ​	补充：CMake是一个跨平台工具，因为在windows上没有Makefile，所以就需要一个同时适用于linux和windows的自动编译脚本，所以有了CMakelists.txt，这个文件是linux和windows通用的，利用cmake，可以根据CMakelist.txt在不同的操作系统上产生不同的自动编译脚本文件。

​	这里使用了cmake，因为文件比较多。在项目目录中写好CMakeLists.txt后，之后有源文件的改动，只需要更改CMakeLists.txt中的几行即可

* 1、写好CMakeLists.txt文件

* 2、创建build文件夹，在build目录中cmake

  ```shell
  mkdir build
  cd build
  cmake -G"MinGW Makefiles" ..
  # .. 表示 CMakeLists.txt 在上一级目录。
  # Windows 下，CMake 默认使用微软的 MSVC 作为编译器，我想使用 MinGW 编译器，可以通过 -G 参数来进行指定，只有第一次构建项目时需要指定。
  ```

* 此时在 build 目录下会生成 Makefile 文件，然后调用编译器来实际编译和链接项目：`cmake`


makefile编译，保存在了build文件夹下，编译为libevent.so动态库和libevent.a静态库，供给其他程序作为网络库使用

通常系统在编译时会在./usr/lib和/usr/local/lib这两个文件夹下找.a(静态库) .so(动态库)文件，在/usr/include和/usr/local/include文件夹下找.h文件。当然，这个.h文件也可以放在项目下，反正保证`#include "xx.h"能找到就行`

make中通过install把.so库放到了/usr/local/lib文件夹下，把threadpool.h放到了/usr/local/include/文件夹下

[cmake教程](https://zhuanlan.zhihu.com/p/500002865)





当然也可以使用如下命令，将当前目录下所有文件都参与编译

```cpp
aux_source_directory(. SRC_LIST)
```

但增加新文件后，makefile还是原来的，需要右键cmakelists.txt文件夹，选择clean reconfigure all projects，然后重新cmake出makefile，再rebuild就行了。但还是有点麻烦，不如直接`set(SRC_LIST xxx.cc)`，每次写上新的.cc文件就多写一个set



```makefile
cmake_minimum_required(VERSION 3.0) # 设置cmake的最低版本
project(myrpc) # 项目名称

# 生成debug版本，可以进行gdb调试
set(CMAKE_BUILD_TYPE "Debug")

# 设置项目可执行文件输出的路径
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
# 设置项目库文件输出的路径
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

# 设置项目编译头文件搜索路径 -I
# 将指定目录添加到编译器的头文件搜索路径之下
include_directories(${PROJECT_SOURCE_DIR}/src/include)
include_directories(${PROJECT_SOURCE_DIR}/example)
# 设置项目库文件搜索路径 -L
link_directories(${PROJECT_SOURCE_DIR}/lib)

# src包含了mprpc框架所有的相关代码
# 添加一个子目录并构建该子目录
# 子目录也要写个makefile，将子目录下源文件编译为库文件
add_subdirectory(src)
# example包含了mprpc框架使用的示例代码
add_subdirectory(example)
```



src中的CMakeLists

```makefile
#aux_source_directory(. SRC_LIST)
set(SRC_LIST 
    myrpcapplication.cc 
    myrpcconfig.cc 
    rpcheader.pb.cc 
    rpcprovider.cc 
    myrpcchannel.cc
    myrpccontroller.cc
    logger.cc
    zookeeperutil.cc)
add_library(myrpc ${SRC_LIST}) # 生成myrpc库
target_link_libraries(myrpc muduo_net muduo_base pthread zookeeper_mt)
```





多线程使用和多进程使用的区别

多进程编程

并发的锁机制

虚拟内存和管道的选用

多态的底层原理

虚拟地址：在虚拟内存系统中使用的地址，分为栈、堆...

软中断了解吗

并发并行：并发不一定是同时执行，通过分配时间片交替执行来模拟多个程序同时运行，通常在单核处理器上实现

析构函数为什么要是虚函数

IO多路复用

水平触发和边缘触发

工厂模式的理解与运用 

* 工厂模式如果在c中想要实现怎么运用？函数指针

继承、多态

虚函数，纯虚函数，虚函数表

UDP怎么保证数据接受的完整性（**没看**

介绍做的最久的项目：华为项目



