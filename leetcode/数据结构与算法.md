

## 一、线性表

多项式相加，将视频中(系数，指数)调换位置，然后用map实现

```c++
#include<iostream>
using namespace std;
#include<map>

int main() {
	map<int, int> m1;
	m1.insert(make_pair(0, 7));
	m1.insert(make_pair(1, 3));
	m1.insert(make_pair(8, 9));
	m1.insert(make_pair(17, 5));

	map<int, int> m;
	m.insert(make_pair(1, 8));
	m.insert(make_pair(7, 22));
	m.insert(make_pair(8, -9));

	for (map<int, int>::iterator it = m.begin(); it != m.end(); it++) {
		map<int, int>::iterator pos = m1.find(it->first);
		if (pos!=m1.end()) {//有相同的指数
			pos->second = pos->second + it->second;
			if (pos->second == 0) {//将系数为0的删除
				m1.erase(pos);
			}
		}
		else {
			m1.insert(make_pair(it->first, it->second));
		}
	}
	for (map<int, int>::iterator it = m1.begin(); it != m1.end(); it++) {
		cout << it->first << " " << it->second << endl;
	}

	return 0;
}
```



### 2.4线性表的顺序表示和实现

```c++
#include<iostream>
using namespace std;
#include<stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
typedef int Status;
typedef char ElemType;

#define list_size 5

class SqList {
public:
	//T elem[list_size];
	ElemType* elem;//一样的，elem为数组名，是地址，*elem解引用，也相当于一个数组。数组的长度在后面会告诉怎么写
	int length;  // 数组当前长度
};

// 初始化线性表
Status InitList_Sq(SqList& L) {
	L.elem = new ElemType[list_size];
	if (!L.elem) exit(OVERFLOW);//如果空，分配失败，则退出程序并返回-2给系统
	L.length = 0;
	return OK;
}

//销毁
void DestroyList(SqList& L) {
	if (L.elem) delete[] L.elem;
}

//清空
void ClearList(SqList& L) {
	L.length = 0;
}

//求线性表长度
int GetLength(SqList L) {
	return L.length;
}

//判断是否为空
int IsEmpty(SqList L) {
	if (L.length == 0) return 1;
	else return 0;
}

//得到i位置的值
int GetElem(SqList L, int i, ElemType& e) {
	if (i<1 || i>L.length) return ERROR;
	e = L.elem[i - 1];//第I-1个单元存储着第i个数据
	return OK;
}

//查找
int LocateElem(SqList L, ElemType e) {
	for (int i = 0; i < L.length; i++) {
		if (L.elem[i] == e) return i + 1;
		return 0;
	}
}

//添加,O(n)
int Insert(SqList &L,int i, ElemType e) {
	//这里i为位置
	if (i<1 || i>L.length+1) return ERROR;
	if(L.length==list_size) return ERROR;
	//这里j为下标
	for (int j = L.length-1; j >= i-1; j--) {
		L.elem[j+1] = L.elem[j];
	}
	L.elem[i-1] = e;
	L.length += 1;
	return OK;
}

//删除
int ListDelete(SqList& L, int i, ElemType& e) {
	if (i<1 || i>L.length + 1) return ERROR;
	if (L.length == 0) return ERROR;//例子里没有
	e=L.elem[i-1];
	for (int j = i ; j <= L.length -1; j++) {
		L.elem[j-1] = L.elem[j];
	}
	
	L.length -= 1;
	return OK;
}

void test() {
	SqList L;
	InitList_Sq(L);
	Insert(L, 1, 'A');
	char e;
	GetElem(L, 1, e);
	cout << e << endl;
	char a;
	ListDelete(L, 1, a);
	cout << a << endl;
	cout << L.length << endl;

}

int main() {
	test();
}
```



### 2.5线性表的链式表示和实现

物理位置任意，逻辑次序和物理次序不一定相同

每个结点包括数据域和指针域

#### 2.5.1单链表

结点只有一个指针域的链表

##### 例程c实现

```c++
//例程c实现
#include<iostream>
using namespace std;
#include<stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
typedef int Status;
typedef char ElemType;

#define list_size 5


//定义链表一般用LinkList L;定义结点指针一般用Lnode* p;
typedef struct Lnode {
	ElemType data;//结点的数据域
	struct Lnode* next;//结点的指针域
}Lnode, * LinkList;

//初始化
int InitList(LinkList& L) {
	L = new Lnode;//L为指针，指向Lnode结点
	L->next = NULL;//将指向的结点的指针域制空
	return OK;
}

//判断链表是否为空
int ListEmpty(LinkList L) {
	if (L->next) return 0;
	else return 1;
}

//销毁链表：从头指针开始，依次释放所有结点
int destroyL(LinkList& L) {
	Lnode* p;
	while(L) {//L != NULL
		p = L;//先让p也指向头节点
		L = L->next;//然后把L往后挪
		delete p;//然后就可以把p指向的结点删除了，删除的是p指向的空间，就是把整个结点直接删了
	}
	return OK;
}

//自写清空链表，链表无元素，仅有头指针和头结点
int qk(LinkList& L) {
	Lnode* p;
	p = L;//p指向头结点，存起来
	L = L->next;
	Lnode* p0;
	while (L) {//L != NULL
		p0 = L;
		L = L->next;
		delete p0;//把p指向的结点删除了，删除的是p指向的空间，就是把整个结点直接删了
	}
	L = p;
	return OK;
}
//例程清空链表
//和自写区别：这里是用p指向下一个结点，然后将其当作L，和q配合删除后面所有的，最后再把头结点指针域置空
int ClearList(LinkList& L) {
	Lnode* p,*q;
	p = L->next;
	while (p) {
		q = p->next;
		delete p;
		p = q;
	}
	L->next = NULL;
	return OK;
}

//求表长，从首元结点开始，依次计数所有结点
int ListLength(LinkList L) {
	Lnode* p;
	int count=0;
	p = L->next;//L指向头结点，P指向首元结点
	while (p) {
		p = p->next;
		count++;
	}
	return count;
}

//取值，第i个元素
//自写。问题：因为需要返回状态，所以最好不这么写；没有考虑p为空，即已经指向最后一个元素了的状态
ElemType Get(LinkList L,int i) {
	Lnode* p;
	p = L->next;//L指向头结点，P指向首元结点
	for (int j = 0; j < i-1; j++) {
		p = p->next;
	}
	return p->data;
}
// 例程
int GetElem(LinkList L, int i, ElemType& e) {
	Lnode* p;
	p = L->next;
	int j = 1;
	while (p && j < i) {//向后扫描，直到p指向第i个元素或p为空
		p = p->next;
		j++;
	}
	if (!p || j > i) return ERROR;//第I个元素不存在，比如第o个元素
	e = p->data;
	return OK;
}

//查找，分为查找地址和查找位置序号
Lnode* LocateElem(LinkList L, ElemType e) {
	Lnode* p;
	p = L->next;
	while (p && p->data != e) //p不为空且没查到，就一直循环
		p=p->next;
	return p;
}
//查找序号
int LocateElem1(LinkList L, ElemType e) {
	Lnode* p;
	p = L->next;
	int j = 1;
	while (p && p->data != e) { //p不为空且没查到，就一直循环
		p = p->next;
		j++;
	}
	if (p) return j;
	else return 0;
}

//插入，在第i个结点前,需要从头查找前驱节点，因此为O(n)
int ListInsert(LinkList& L, int i, ElemType e) {
	Lnode* p;
	p = L->next;
	int j = 1;
	while (p && j<i-1) { //p不为空且没查到，就一直循环
		p = p->next;//p指向第i-1个结点
		j++;
	}
	if (!p||j>i-1) return ERROR;//如果p指向NULL即i大于表长+1，或者i小于1

	Lnode* s;
	s = new Lnode;
	s->data = e;
	s->next = p->next;//新结点的指针域指向原来的i
	p->next = s;//i-1位置的结点，指针域进行更新，指向新结点
	return OK;
}

//删除第i个结点
int ListDelete(LinkList& L, int i) {
	Lnode* p;
	p = L->next;
	int j = 1;
	while (p && j < i - 1) { //p不为空且没查到，就一直循环
		p = p->next;//p指向第i-1个结点,p的指针域指向i
		j++;
	}
	if (!p || j > i - 1) return ERROR;//如果p指向NULL即i大于表长+1，或者i小于1
	//第i-1个结点指向
	Lnode* q;
	q = p->next;//q指向第i个结点，q的指针域指向i+1
	p->next = q->next;//让p的指针域更新为指向i+1
	delete q;
	return OK;
}

//单链表的建立
//头插法
//从一个空表开始，重复读入数据；生成新结点，将读入数据存放到新结点的数据域中；从最后一个结点开始，依次将各结点插入到链表的前端
int tc(LinkList& L,int n) {
	L = new Lnode;//L为指针，指向Lnode结点
	L->next = NULL;//将指向的结点的指针域制空

	Lnode* p;

	for (int i =n; i >0; i--) {
		p = new Lnode;
		cin >> p->data;
		p->next = L->next;  //L->next本来指向空，就是p->next = NULL;这里是将原来头结点L->next指向的赋给p
		L->next = p;//头插法，就是每次接到头结点的后面
	}
	return OK;
}
//尾插法
int tc2(LinkList& L, int n) {
	L = new Lnode;//L为指针，指向Lnode结点
	L->next = NULL;//将指向的结点的指针域制空

	Lnode* p, * r;

	for (int i = 0; i < n; i++) {
		p = new Lnode;
		cin >> p->data;
		p->next = NULL; 
		r->next = p;
		r = p;		
	}
	return OK;
}

void test1()
{
	Lnode L;
	LinkList Li;
	tc(Li, 5);
	cout << Get(Li, 1) << endl;
	cout << Get(Li, 2) << endl;
	cout << Get(Li, 3) << endl;
	cout << Get(Li, 4) << endl;
	cout << Get(Li, 5) << endl;
	/*char e;
	GetElem(Li, 1, e);
	cout << e << endl;*/
}

int main() {
	test1();
}
```

##### c++实现，待补充，有大体思路就行

[可参考这个](https://blog.csdn.net/Bob______/article/details/110581129)

```c++
//c++实现，待补充
#include<iostream>
using namespace std;
#include<stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0

#define  ElemType char
#define list_size 5

//c++实现
class Lnode {
public:
	ElemType data;//结点的数据域
	Lnode* next;//结点的指针域，后继指针
};

//构建一个单链表类
class LinkList
{
public:
	LinkList();					  //初始化一个单链表;
	~LinkList();                  //销毁一个单链表;
	void CreateLinkList(int n);   //创建一个单链表
	void TravalLinkList();        //遍历线性表
	int GetLength();              //获取线性表长度
	bool IsEmpty();               //判断单链表是否为空
	ElemType* Find(ElemType data); //查找节点
	void InsertElemAtEnd(ElemType data);            //在尾部插入指定的元素
	void InsertElemAtIndex(ElemType data, int n);    //在指定位置插入指定元素
	void InsertElemAtHead(ElemType data);           //在头部插入指定元素
	void DeleteElemAtEnd();       //在尾部删除元素
	void DeleteAll();             //删除所有数据
	void DeleteElemAtPoint(ElemType data);     //删除指定的数据
	void DeleteElemAtHead();      //在头部删除节点
private:
	Lnode * head;              //头结点
};


//判断链表是否为空
bool LinkList::IsEmpty() {
	if (this->head->next) return 0;
	else return 1;
}
```





#### 2.5.2循环链表

首尾相接的链表，即原来单链表指向NULL的指针域指向了头结点

循环链表空表，头结点的指针域指向了自己

终止条件由p!=NULL变为p!=L;L表示头指针

![image-20211015230704193](E:\MarkDown\picture\image-20211015230704193.png)

![image-20211015230712649](E:\MarkDown\picture\image-20211015230712649.png)



#### 2.5.3双向链表

结点有两个指针域

```c++
typedef struct DuLNode{
    ElemType data;
    struct DulNode *prior,*next;
}DuLNode,*DuLinkList;
```

双向循环链表

![image-20211015233248809](E:\MarkDown\picture\image-20211015233248809.png)

![image-20211015233255804](E:\MarkDown\picture\image-20211015233255804.png)

![image-20211016102934630](E:\MarkDown\picture\image-20211016102934630.png)



三行一列，R->NEXT->NEXT

![image-20211016102943085](E:\MarkDown\picture\image-20211016102943085.png)



### 2.7 线性表应用

#### 2.7.1线性表的合并

![image-20211016135149797](E:\MarkDown\picture\image-20211016135149797.png)

```c++
//时间复杂度O(n^3)，这是算入了insert。
//线性表的合并
void union(LinkList& L1, LinkList& L2) {
	//取出L2数据域中每一个值，在L1中find，若没找到，就在L1后添加
	int len = ListLength(L1);
	for (int i = 1; i <= ListLength(L2); i++) {
		int e;
		GetElem(L2, i, e);
		if (!LocateElem1(L1, e)) {
			ListInsert(L1, ++len, e);//插入到第i+1前，即代替了i+1，所以这里需要++len。
		}
	}
}
```

```c++
//使用演示
#include<iostream>
using namespace std;
#include<stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
typedef int Status;
typedef int ElemType;

#define list_size 5
typedef struct Lnode {
	ElemType data;//结点的数据域
	struct Lnode* next;//结点的指针域
}Lnode, * LinkList;
//判断b中的元素a有没有，有的话不管，没有的话加到后面
//单链表就可实现

//插入，在第i个结点前
int LocateElem1(LinkList& L, int i, ElemType e) {
	Lnode* p;
	p = L->next;
	int j = 1;
	while (p && j < i - 1) { //p不为空且没查到，就一直循环
		p = p->next;//p指向第i-1个结点
		j++;
	}
	if (!p || j > i - 1) return ERROR;//如果p指向NULL即i大于表长+1，或者i小于1

	Lnode* s;
	s = new Lnode;
	s->data = e;
	s->next = p->next;//新结点的指针域指向原来的i
	p->next = s;//i-1位置的结点，指针域进行更新，指向新结点
	return OK;
}

int ListLength(LinkList L) {
	Lnode* p;
	int count = 0;
	p = L->next;//L指向头结点，P指向首元结点
	while (p) {
		p = p->next;
		count++;
	}
	return count;
}

//初始化
int InitList(LinkList& L) {
	L = new Lnode;//L为指针，指向Lnode结点
	L->next = NULL;//将指向的结点的指针域制空
	return OK;
}

//查找序号
int LocateElem1(LinkList L, ElemType e) {
	Lnode* p;
	p = L->next;
	int j = 1;
	while (p && p->data != e) { //p不为空且没查到，就一直循环
		p = p->next;
		j++;
	}
	if (p) return j;
	else return 0;
}

// 取第i个值
int GetElem(LinkList L, int i, ElemType& e) {
	Lnode* p;
	p = L->next;
	int j = 1;
	while (p && j < i) {//向后扫描，直到p指向第i个元素或p为空
		p = p->next;
		j++;
	}
	if (!p || j > i) return ERROR;//第i个元素不存在，比如第o个元素
	e = p->data;
	return OK;
}

int ListInsert(LinkList& L, int i, ElemType e) {
	Lnode* p;
	p = L->next;
	int j = 1;
	while (p && j < i - 1) { //p不为空且没查到，就一直循环
		p = p->next;//p指向第i-1个结点
		j++;
	}
	if (!p || j > i - 1) return ERROR;//如果p指向NULL即i大于表长+1，或者i小于1

	Lnode* s;
	s = new Lnode;
	s->data = e;
	s->next = p->next;//新结点的指针域指向原来的i
	p->next = s;//i-1位置的结点，指针域进行更新，指向新结点
	return OK;
}

//算法
void hebing(LinkList& L1, LinkList& L2) {
	//取出L2数据域中每一个值，在L1中find，若没找到，就在L1后添加
	int len = ListLength(L1);
	for (int i = 1; i <= ListLength(L2); i++) {
		int e;
		GetElem(L2, i, e);
		if (!LocateElem1(L1, e)) {
			ListInsert(L1, ++len, e);//插入到第i+1前，即代替了i+1，所以这里需要++len。
		}
	}
}

void test() {

	// 创建要求的线性表
	Lnode* p, * q;
	InitList(p);
	InitList(q);
	Lnode* s;
	s = new Lnode;
	s->data =7;
	s->next = p->next;//新结点的指针域指向原来的i
	p->next = s;//i-1位置的结点，指针域进行更新，指向新结点
	//LocateElem1(p, 1, 7);
	LocateElem1(p, 2, 5);
	LocateElem1(p, 3, 3);
	LocateElem1(p, 4, 11);
	cout << ListLength(p) << endl;
	Lnode* s1;
	s1 = new Lnode;
	s1->data = 7;
	s1->next = q->next;//新结点的指针域指向原来的i
	q->next = s1;//i-1位置的结点，指针域进行更新，指向新结点
	LocateElem1(q, 1, 2);
	LocateElem1(q, 2, 6);
	LocateElem1(q, 3, 3);
	cout << ListLength(q) << endl;
	hebing(p, q);
	cout << ListLength(p) << endl;
}


int main() {
	test();
}
```

![image-20211016135149797](E:\MarkDown\picture\image-20211016135149797.png)

#### 2.7.2有序表的合并

![image-20211016152804227](E:\MarkDown\picture\image-20211016152804227.png)

这里用了归并排序的迭代法

![image-20211016150627921](E:\MarkDown\picture\image-20211016150627921.png)



```c++
//有序表的合并
//自己的想法：找最长的表作为基表，遍历短表的每个元素，与基表的第一个元素开始比较，若是大于第i个元素，就放在第i个元素的后面。 然后表的第二个元素，从第i+1开始再次比较。时间复杂度应该为O(n^2)
//例程：归并排序。先比较两个表的第一个元素，把小的放到新的表中，然后拿大的和小的表的第二个再比，再将小的放入
//为什么例程更好？进行时间复杂度和空间复杂度的比较看看
```

##### 顺序存储结构实现

时间复杂度和空间复杂度都为O(length(La)+length(Lb))

![image-20211016161116346](E:\MarkDown\picture\image-20211016161116346.png)

![image-20211016161125333](E:\MarkDown\picture\image-20211016161125333.png)

##### 链式存储结构实现

时间复杂度为O(length(La)+length(Lb))

空间复杂度为O(1)，不需要额外空间

![image-20211016161902278](E:\MarkDown\picture\image-20211016161902278.png)

![image-20211016162120836](E:\MarkDown\picture\image-20211016162120836.png)



### 2.8案例分析与实现(重写)

![image-20211016191033331](E:\MarkDown\picture\image-20211016191033331.png)

```c++
#include<iostream>
using namespace std;
#include<stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
typedef int Status;
typedef int ElemType;

#define list_size 7

class SqList {
public:
	//T elem[list_size];
	ElemType* elem;//一样的，elem为数组名，是地址，*elem解引用，也相当于一个数组。数组的长度在后面会告诉怎么写
	int length;  // 数组当前长度
};

// 初始化线性表
Status InitList_Sq(SqList& L) {
	L.elem = new ElemType[list_size];
	if (!L.elem) exit(OVERFLOW);//如果空，分配失败，则退出程序并返回-2给系统
	L.length = 0;
	return OK;
}
void test() {
	SqList L1,L2,L3;
	int a[5] = { 10,5,-4,3,2 };
	L1.elem = a;
	L1.length = 5;
	int b[7] = { -3,8,4,0,-5,7,-2 };
	L2.elem = b;
	L2.length = 7;
	InitList_Sq(L3);
	for (int i = 0; i < 5; i++) {
		L3.elem[i] = L1.elem[i] + L2.elem[i];
	}
	for (int j = 5; j < 7; j++) {
		L3.elem[j] = L2.elem[j];
	}
	for (int i = 0; i < 7; i++) {
		cout << L3.elem[i] << endl;
	}
}

int main() {
	test();
}
```



![image-20211016193634363](E:\MarkDown\picture\image-20211016193634363.png)

应该按有序表的**顺序存储结构**实现

```c++
//自写程序。问题：运行后，因为提前设置开辟数据为7，而填充的数据一般不会有7个，因此后面总会有几个乱码的，不知道怎么去除

#include<iostream>
using namespace std;
#include<stdlib.h>

#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
typedef int Status;


#define list_size 7

class elems {
public:
	elems(){}
	elems(int i,int j) {
		xishu = i;
		zhishu = j;
	}
	int zhishu;
	int xishu;
};

class SqList {
public:
	//T elem[list_size];
	elems* elem;//一样的，elem为数组名，是地址，*elem解引用，也相当于一个数组。数组的长度在后面会告诉怎么写
	int length;  // 数组当前长度
};

void test() {
	SqList A;
	A.elem = new elems[4];
	A.length = 4;
	A.elem[0] = elems(7, 0);
	A.elem[1] = elems(3, 1);
	A.elem[2] = elems(9, 8);
	A.elem[3] = elems(5, 17);
	SqList B;
	B.elem = new elems[3];
	B.length = 3;
	B.elem[0] = elems(8, 1);
	B.elem[1] = elems(22, 7);
	B.elem[2] = elems(-9, 8);
	SqList C;
	C.elem = new elems[7];
	C.length = 0;
	int i = 0,j = 0,c=0;
	while((i<4) && (j<3)) {
		if (A.elem[i].zhishu == B.elem[j].zhishu) {
			C.elem[c].zhishu = A.elem[i].zhishu;
			C.elem[c].xishu = A.elem[i].xishu + B.elem[j].xishu;
			if(C.elem[c].xishu) c++;
			j++; i++; 
		}
		else if (A.elem[i].zhishu > B.elem[j].zhishu) {
			C.elem[c].zhishu = B.elem[j].zhishu;
			C.elem[c].xishu = B.elem[j].xishu;
			j++; c++;
		}
		else {
			C.elem[c].zhishu = A.elem[i].zhishu;
			C.elem[c].xishu = A.elem[i].xishu;
			i++; c++;
		}
		if (j == 3){
			for (int m = i; m < 4; m++) {
				C.elem[c].zhishu = A.elem[m].zhishu;
				C.elem[c].xishu = A.elem[m].xishu;
				c++;
			}
		}
		if (i == 4) {
			for (int m = j; m < 3; m++) {
				C.elem[c].zhishu = B.elem[m].zhishu;
				C.elem[c].xishu = B.elem[m].xishu;
				c++;
			}
		}
	}
	
	for (int i = 0; i < 7; i++) {
		cout << C.elem[i].zhishu << "  " << C.elem[i].xishu << endl;
	}
}

int main() {
	test();
}
```



![image-20211016195520405](E:\MarkDown\picture\image-20211016195520405.png)

应该按有序表的链式存储结构实现

![image-20211016201652196](E:\MarkDown\picture\image-20211016201652196.png)

![image-20211016201658294](E:\MarkDown\picture\image-20211016201658294.png)

![image-20211016201706546](E:\MarkDown\picture\image-20211016201706546.png)

![image-20211016201713183](E:\MarkDown\picture\image-20211016201713183.png)



## 二、栈

### 2.1栈的顺序存储结构

#### 作业一：实现顺序栈 ok

与王卓的不一样，王卓设了top和base

```c++
//stack.h
#pragma once
#include<iostream>
using namespace std;
//条款2：尽量用const、enum、inline替换掉#define
const int Max_SIZE = 100;//比 #define Max_SIZE 100 要好，define有可能会不被编译器看到，而常量是肯定会被编译器看到的
typedef int SElemType;//比用#define SElemType int更好

class Stack {
private:
	SElemType* data;//指向数组的指针
	//SElemType data[MAXSIZE];也可以，但缺点是栈占的空间固定为了MAXSIZE，因此还是用指针方便些
	int size;//数组的大小
	int top;//栈顶
public:
	Stack();//构造函数，初始化栈
	Stack(int size);//有参构造函数，初始化栈的大小为size，若设置的size大于了Max_size，则设为Max_size 
	~Stack();

	void push(SElemType ch);//入栈
	SElemType pop();//出栈并返回栈顶元素
	SElemType getTop();//获得栈顶元素但不出栈
	bool isEmpty();//空
	bool isFull();//满
	void setNull();//设置栈为空
};
```

```c++
//stack.cpp
#include"stack.h"

Stack::Stack() {
	size = Max_SIZE;
	top = -1;
	data = new SElemType[Max_SIZE];
}

Stack::Stack(int size)
{
	if (Max_SIZE >= size)
	{
		data = new SElemType[size];
		this->size = size;
		top = -1;
	}
	else
	{
		cout << "栈容量最大为" << Max_SIZE << endl;
		data = new SElemType[Max_SIZE];
		this->size = Max_SIZE;
		top = -1;
	}
}

Stack::~Stack() {
	delete[] data;
}

// 一个子程序完成的是压入的功能，而不是压入和输出，最好让子程序有单一的功能。
// 因此这里不要写如果为空，cout<<等。但要是不写，如何知道是否压入成功呢？
// 这里的判断通过异常捕获来实现
void Stack::push(SElemType ch) {//入栈
	if (!isFull()) data[++top] = ch;
}

SElemType Stack::pop() {//出栈并返回栈顶元素
	if(!isEmpty()) return data[top--];
}

SElemType Stack::getTop() {//获得栈顶元素但不出栈
	if (!isEmpty()) return data[top];
}

bool Stack::isEmpty() {//空
	if (top == -1) return true;
	else return false;
}

bool Stack::isFull() {//满
	if (top >= size - 1) return true;
	else return false;
}

void Stack::setNull() {//设置栈为空
	top = -1;
}
```

#### 作业二 待

<img src="E:\MarkDown\picture\image-20211017222501545.png" alt="image-20211017222501545" style="zoom: 25%;" /><img src="E:\MarkDown\picture\image-20211017222507983.png" alt="image-20211017222507983" style="zoom:20%;" /><img src="E:\MarkDown\picture\image-20211017222513302.png" alt="image-20211017222513302" style="zoom: 20%;" />



#### 作业三 待

<img src="E:\MarkDown\picture\image-20211017222648879.png" alt="image-20211017222648879" style="zoom:25%;" />



#### 用异常捕获优化顺序栈

一个子程序完成的是压入的功能，而不是压入和输出，最好让子程序有单一的功能。否则会不符合类的重用的特征，比如下次会要求输出其他的提示信息，就需要对类进行修改等
因此这里不要写如果为空，cout<<等，所有的输入输出功能应该在类专有的display函数或main函数中实现。但要是不写，如何知道是否压入成功呢？这里的判断通过异常捕获来实现

<img src="E:\MarkDown\picture\image-20211017223852632.png" alt="image-20211017223852632" style="zoom: 33%;" />

若没有捕获到异常，则catch块会被跳过，有异常则执行相应catch，若catch没能捕获，则程序终止报错

<img src="E:\MarkDown\picture\image-20211017232606972.png" alt="image-20211017232606972" style="zoom:33%;" />

对顺序栈的实现进行优化，其中class定义在栈类中，throw添加在成员函数语句中，try捕获异常添加到main函数中。这样的好处就是把输入输出语句都放在了main函数中，以后用类的重用会更方便

```c++
//main.cpp
#include<iostream>
using namespace std;
#include"stack.h"

int main() {
	Stack s(2);
	try {
		s.push(5);
		s.push(5);
		s.push(4);
	}
	catch (Stack::Full) {
		cout << "Stack Full!" << endl;
	}
	cout << s.isFull() << endl;
	cout << s.getTop() << endl;
	try {
		cout << s.pop() << endl;
		cout << s.pop() << endl;
		cout << s.pop() << endl;
	}
	catch (Stack::Empty) {
		cout << "Stack Empty!" << endl;
	}
	cout << s.isEmpty() << endl;
}
```

```c++
//stack.h
#pragma once
#include<iostream>
using namespace std;
//条款2：尽量用const、enum、inline替换掉#define
const int Max_SIZE = 100;//比 #define Max_SIZE 100 要好，define有可能会不被编译器看到，而常量是肯定会被编译器看到的
typedef int SElemType;//比用#define SElemType int更好

class Stack {
private:
	SElemType* data;//指向数组的指针
	//SElemType data[MAXSIZE];也可以，但缺点是栈占的空间固定为了MAXSIZE，因此还是用指针方便些
	int size;//数组的大小
	int top;//栈顶
public:
	Stack();//构造函数，初始化栈
	Stack(int size);//有参构造函数，初始化栈的大小为size，若设置的size大于了Max_size，则设为Max_size
	~Stack();

	void push(SElemType ch);//入栈
	SElemType pop();//出栈并返回栈顶元素
	SElemType getTop();//获得栈顶元素但不出栈
	bool isEmpty();//空
	bool isFull();//满
	void setNull();//设置栈为空

	class Full{};
	class Empty{};
};

```

```c++
//stack.cpp
#include"stack.h"

Stack::Stack() {
	size = Max_SIZE;
	top = -1;
	data = new SElemType[Max_SIZE];
}

Stack::Stack(int size)
{
	if (Max_SIZE >= size)
	{
		data = new SElemType[size];
		this->size = size;
		top = -1;
	}
	else
	{
		cout << "栈容量最大为" << Max_SIZE << endl;
		data = new SElemType[Max_SIZE];
		this->size = Max_SIZE;
		top = -1;
	}
}

Stack::~Stack() {
	delete[] data;
}

// 一个子程序完成的是压入的功能，而不是压入和输出，最好让子程序有单一的功能。
// 因此这里不要写如果为空，cout<<等。但要是不写，如何知道是否压入成功呢？
// 这里的判断通过异常捕获来实现
void Stack::push(SElemType ch) {//入栈
	if (isFull()) throw Full();
	else  data[++top] = ch;
}

SElemType Stack::pop() {//出栈并返回栈顶元素
	if (isEmpty()) throw Empty();
	else return data[top--];
}

SElemType Stack::getTop() {//获得栈顶元素但不出栈
	if (isEmpty()) throw Empty();
	else return data[top];
}

bool Stack::isEmpty() {//空
	if (top == -1) return true;
	else return false;
}

bool Stack::isFull() {//满
	if (top >= size - 1) return true;
	else return false;
}

void Stack::setNull() {//设置栈为空
	top = -1;
}
```

#### 用类模板实现顺序栈

比用typedef int SElemType;灵活性更强

好处：在表达式求值等经典应用中，可以设置两个栈分别处理不同数据类型的数据

```c++
//main.cpp
#include<iostream>
using namespace std;
#include"stack.cpp"

int main() {
	Stack<int> s(2);
	try {
		s.push(5);
		s.push(5);
		s.push(4);
	}
	catch (Stack<int>::Full) {
		cout << "Stack Full!" << endl;
	}
	cout << s.isFull() << endl;
	cout << s.getTop() << endl;
	try {
		cout << s.pop() << endl;
		cout << s.pop() << endl;
		cout << s.pop() << endl;
	}
	catch (Stack<int>::Empty) {
		cout << "Stack Empty!" << endl;
	}
	cout << s.isEmpty() << endl;
}
```



```c++
//stack.h
#pragma once
#include<iostream>
using namespace std;
//条款2：尽量用const、enum、inline替换掉#define
const int Max_SIZE = 100;//比 #define Max_SIZE 100 要好，define有可能会不被编译器看到，而常量是肯定会被编译器看到的

template<class SElemType>
class Stack {
private:
	SElemType* data;//指向数组的指针
	//SElemType data[MAXSIZE];也可以，但缺点是栈占的空间固定为了MAXSIZE，因此还是用指针方便些
	int size;//数组的大小
	int top;//栈顶
public:
	Stack();//构造函数，初始化栈
	Stack(int size);//有参构造函数，初始化栈的大小为size，若设置的size大于了Max_size，则设为Max_size
	~Stack();

	void push(SElemType ch);//入栈
	SElemType pop();//出栈并返回栈顶元素
	SElemType getTop();//获得栈顶元素但不出栈
	bool isEmpty();//空
	bool isFull();//满
	void setNull();//设置栈为空

	class Full{};
	class Empty{};
};
```



```c++
//stack.cpp
#include"stack.h"

template<class SElemType>
Stack<SElemType>::Stack() {
	size = Max_SIZE;
	top = -1;
	data = new SElemType[Max_SIZE];
}

template<class SElemType>
Stack<SElemType>::Stack(int size)
{
	if (Max_SIZE >= size)
	{
		data = new SElemType[size];
		this->size = size;
		top = -1;
	}
	else
	{
		cout << "栈容量最大为" << Max_SIZE << endl;
		data = new SElemType[Max_SIZE];
		this->size = Max_SIZE;
		top = -1;
	}
}

template<class SElemType>
Stack<SElemType>::~Stack() {
	delete[] data;
}

// 一个子程序完成的是压入的功能，而不是压入和输出，最好让子程序有单一的功能。
// 因此这里不要写如果为空，cout<<等。但要是不写，如何知道是否压入成功呢？
// 这里的判断通过异常捕获来实现

template<class SElemType>
void Stack<SElemType>::push(SElemType ch) {//入栈
	if (isFull()) throw  Stack<SElemType>::Full();
	else  data[++top] = ch;
}

template<class SElemType>
SElemType Stack<SElemType>::pop() {//出栈并返回栈顶元素
	if (isEmpty()) throw  Stack<SElemType>::Empty();
	else return data[top--];
}

template<class SElemType>
SElemType Stack<SElemType>::getTop() {//获得栈顶元素但不出栈
	if (isEmpty()) throw  Stack<SElemType>::Empty();
	else return data[top];
}

template<class SElemType>
bool Stack<SElemType>::isEmpty() {//空
	if (top == -1) return true;
	else return false;
}

template<class SElemType>
bool Stack<SElemType>::isFull() {//满
	if (top >= size - 1) return true;
	else return false;
}

template<class SElemType>
void Stack<SElemType>::setNull() {//设置栈为空
	top = -1;
}
```



#### 两栈共享空间

在数组的两端，向中间靠拢

应用场景：两个栈的空间需求有相反关系时，如一个栈在增长时另一个栈在缩短的情况

<img src="E:\MarkDown\picture\image-20211018164115257.png" alt="image-20211018164115257" style="zoom:33%;" />

```c++
typedef int DataType;
const int STACK_SIZE = 100;

class BothStack {
private:
	DataType data[STACK_SIZE];
	int top1;//栈1栈顶位置
	int top2;//栈2栈顶位置
public:
	BothStack();
	~BothStack();
	void push(int num, DataType x);
	DataType pop(int num);
	DataType getTop(int num);
	bool isEmpty(int num);
	bool isFull(int num);

	class Full{};
	class Empty{};
};

bool BothStack::isEmpty(int num) {
	if (num == 1) {
		if (top1 == -1) return true;
		else return false;
	}
	else if (num == 2) {
		if (top2 == STACK_SIZE) return true;
		else return false;
	}
}

void BothStack::push(int num, DataType x) {
	if (top1 + 1 == top2) throw Full();
	else {
		if ( num == 1) data[++top1] = x;
		else data[--top2] = x;
	}
}

DataType BothStack::pop(int num) {
	if (num == 1) {
		if (isEmpty(1)) throw Empty();
		else return data[top1--];
	}
	else if (num == 2) {
		if (isEmpty(2)) throw Empty();
		else return data[top2++];
	}
}
```



### 2.2链栈

时间性能与顺序栈相同，都为O(1)

<img src="E:\MarkDown\picture\image-20211018170710363.png" alt="image-20211018170710363" style="zoom:33%;" />

一般用第二种，指针方向为

```c++
#pragma once
#include<iostream>
using namespace std;

typedef int DataType;

class StackNode {//链表结点
public:
    DataType data;
    StackNode* next;
};

class LinkStack {
private:
    StackNode* top;//指向链表结点的指针，即top
public:
    LinkStack();//top赋值NULL
    ~LinkStack();//根据top找到所有结点并delete
    void push(DataType x);//链栈可以无限存入，不需要判断栈满
    DataType pop();

    class Empty {};
};

void LinkStack::push(DataType x) {
    StackNode* p;
    p = new StackNode;
    p->data = x;
    p->next = top;
    top = p;

}

DataType LinkStack::pop() {
    if (top == NULL) throw Empty();
    else {
        StackNode* p;
        DataType x = top->data;
        p = top;
        top = top->next;
        delete p;
        return x;
    }
}
```



```c++
//另一种写法，麻烦点，有头结点的。一般不用
typedef int SElemType;
#define MAXSIZE 5
using namespace std;
#include<stdio.h>

//链表
class StackNode {
public:
    SElemType data;
    StackNode* next;
};

class LinkStackPtr {
public:
    StackNode* head;//头结点
};

//链栈
class LinkStack {
public:
    int push(SElemType e);
    int pop(SElemType& e);
    LinkStackPtr top;//这里top为一个对象，top.head才为指针
    int count;
};

int LinkStack::push(SElemType e) {
    LinkStackPtr s;
    s.head = new StackNode;
    s.head->data = e;
    s.head->next = this->top.head;
    this->top = s;
    this->count++;
    return 1;
}

int LinkStack::pop(SElemType& e) {
    LinkStackPtr p;
    //若栈为空，报错
    if (this->top.head == NULL) return -1;
    e = this->top.head->data;
    p.head = this->top.head;
    this->top.head = this->top.head->next;
    delete p.head;
    this->count--;
    return 1;
}


void test() {}

int main() {
	test();
}
```



### 2.3栈的应用

#### 四则运算表达式求值P104

见CSDN，已发布

#### 表达式求值 ok

讲解：BV1yE411p7fD

[配套文档](https://www.bilibili.com/read/cv4759669)

<img src="E:\MarkDown\picture\image-20211018210324772.png" alt="image-20211018210324772" style="zoom:33%;" />

![image-20211018210644449](E:\MarkDown\picture\image-20211018210644449.png)

![image-20211018210347499](E:\MarkDown\picture\image-20211018210347499.png)

1、case'>'时没有读入字符ch，因此ch还是之前的)，然后与栈顶的(比较，触发case '='，再把(弹出

2、之后ch读入#时，while循环条件的左半边为假，但右半边为真，因此循环会再继续进行一次

3、precede函数





**编程需要思考的几个问题**

1.优先级表如何存储并查找？（precede函数）

2.如何判断输入的字符是数字还是运算符？（isOpnd，isOptr函数）

3.根据举例手动跟踪代码，看看能否理解栈的变化情况。

4.如何实现operate函数？

5.目前的算法是在**假定表达式正确**的情况下进行的，要求大家先这样假定，（1）只对1位整数进行四则运算，采用跟踪调试的方法检验程序的运行。当程序运行正确后，再根据自己的能力情况考虑增加：（2）是否要对空格过滤？（3）是否要对多位整数进行运算？（4）是否需要检查表达式格式是否正确？按照提示的（2）（3）（4）顺序逐步增加功能，每增加一个检查后，用多个范例验证过关后，再进入下一个步骤，不要一次把所有的检查功能都加上去，这样会增加调试难度。

即使只完成（1）的功能也算程序完成，但一定要做到能够想明白程序是如何执行的，堆栈是如何变化的。



**测试范例**

说明：蓝色字体表示输入，黑色字体是说明，不是运行结果的一部分。基本要求完成（1）的效果，如果完全正确完成（1）可以评90。后续其他范例可选，还有其他范例，可以自己思考和检查。

**（1）1位整数的表达式**

请输入一个正整数表达式（可以输入的字符包括+-*/()#0123456789）：

2+3*4*(5-2)+6#

计算结果是：44

**（2）包含空格**

请输入一个正整数表达式（可以输入的字符包括+-*/()#0123456789）：

2  +3 *9 #

计算结果是：29

**（3）识别多位整数**

请输入一个正整数表达式（可以输入的字符包括+-*/()#0123456789）：

23*(2+5)+62/3#

计算结果是：181.667

**（4）数字中包含空格**

请输入一个正整数表达式（可以输入的字符包括+-*/()#0123456789）：

23 *4 5+2#

计算结果是：1037

**（5）检查表达式格式是否正确**

请输入一个正整数表达式（可以输入的字符包括+-*/()#0123456789）：

@345+6#

输入错误，请输入一个正确的表达式（可以输入的字符包括+-*/()#0123456789）。

计算结果是：-1

**（6）检查表达式格式是否正确**

请输入一个正整数表达式（可以输入的字符包括+-*/()#0123456789）：

\#34/3#

输入错误，表达式前面不能以#开头。

计算结果是：-1





#### 迷宫问题(堆栈实现) ok

<img src="E:\MarkDown\picture\image-20211018225344342.png" alt="image-20211018225344342" style="zoom: 33%;" />

<img src="E:\MarkDown\picture\image-20211018230744664.png" alt="image-20211018230744664" style="zoom:33%;" />

<img src="E:\MarkDown\picture\image-20211018230756788.png" alt="image-20211018230756788" style="zoom:33%;" />

<img src="E:\MarkDown\picture\image-20211018232318933.png" alt="image-20211018232318933" style="zoom:33%;" />

<img src="E:\MarkDown\picture\image-20211018232328417.png" alt="image-20211018232328417" style="zoom:33%;" />

迷宫算法有很多种写法。
如果采用堆栈进行迷宫探测，则称之为深度优先搜索（DFS），它和递归的探测思路是基本一致的，可以看成是递归方式的非递归版本；
如果采用队列进行迷宫探测，则是广度优先搜索（BFS），广度优先搜索法利用队列的特点，一层层向外扩展查找可走的方块，直到找到出口为止，最先找到的这个答案就必然是最短的。
如果打比喻来说，DFS更适合模拟机器人走迷宫的方式，看到一个方向是通的，就一直走下去，遇到死胡同就退回；BFS则好比一个人站在迷宫入口处，拿出一堆小探测器，每个小探测器帮他搜索一个可能的路径去寻找，第一个找到出口的探测器发出了反馈，那么这个人就按照这个小探测器找到的路径走迷宫就行了。

![image-20211019095548842](E:\MarkDown\picture\image-20211019095548842.png)

大循环中s.pop()起回退作用，小循环中当发现更新的新位置为通路，就将原位置保存，再是通路，再把上次更新的位置保存，因此就可以保存原始路径

再做出可视化的程序，或者直接打出输出路径

**问题**：prints函数输出时会触发中断。但输出的结果没啥问题

![image-20211019231559692](E:\MarkDown\picture\image-20211019231559692.png)



原因：还是熟悉的深浅拷贝问题，如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题，因此需要重载拷贝构造函数

但是没写出来

```c++
template<class SElemType>
Stack<SElemType>::Stack(Stack<SElemType>& s) {
	size = s.size;
	top = s.top;
	data = new SElemType[Max_SIZE];//这里不知道怎么写
}
```

解决方法：将void printt(Stack<Box> s)改为void printt(Stack<Box>& s)就好了

```c++
//main.cpp
#include<iostream>
using namespace std;
#include"stack.cpp"

class Direction {//方向，0-3分别为右下左上
public:
	/*Direction(int a,int b) {
		incX = a;
		incY = b;
	}*/
	int incX, incY;
};

class Box {
public:
	Box(){};
	Box(int a, int b, int c=0) {
		x = a;
		y = b;
		di = c;
	}
	int x, y;//当前访问的迷宫格子的横纵坐标
	int di;//当前方向
};

const int M = 8;
const int N = 8;
bool suanfa(int maze[M+2][N+2], Direction direct[4], Stack<Box>& s)
{
	int x = 1; int y = 1; int di = -1;
	int line, col;
	maze[1][1] = -1;
	Box b(x, y, di);
	s.push(b);
	while (!s.isEmpty()) {//外层循环，判断是否为空。
		b = s.pop();
		x = b.x; y = b.y; di = b.di + 1;
		while (di < 4) {//内层循环，尝试的方向
			line = x + direct[di].incX;
			col = y + direct[di].incY;
			if (maze[line][col] == 0) {
				b.x = x; b.y = y; b.di = di;
				s.push(b);
				x = line; y = col; maze[line][col] = -1;
				if (x == M && y == N) { b.x = M; b.y = N; s.push(b); return true; }  // 增加这三句来输出迷宫的最后一个点
				else di = 0;
			}
			else di++;
		}
	}
	cout << "no path" << endl;
	return false;
}

void printt(Stack<Box>& s) {
	while (!s.isEmpty()) {
		Box temp;
		try {
			temp = s.pop();
			cout << '(' << temp.x << ',' << temp.y << ')' << endl;
		}
		catch (Stack<Box>::Empty) {
			cout << "Stack Empty!" << endl;
		}
	}
}

int main() {
	Direction direct[4] = { 0,1,1,0,0,-1,-1,0 };
	Stack<Box> s;
	int maze[10][10] = {1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1};
	suanfa(maze,direct,s);
	printt(s);	
}
```

### 2.4 栈与递归

#### 汉诺塔游戏

递归函数的原理和栈是相同的，都是往下执行时不断存档（入栈），执行后出栈

对于递归问题，需要将其分解为多个子问题。可以先套个特殊的如执行一次等。

<img src="E:\MarkDown\picture\image-20211023203849851.png" alt="image-20211023203849851" style="zoom: 67%;" />



[汉诺塔游戏演示](https://zhangxiaoleiwk.gitee.io/h.html)



<img src="E:\MarkDown\picture\image-20211023205224621.png" alt="image-20211023205224621" style="zoom: 33%;" />

<img src="E:\MarkDown\picture\image-20211023204912435.png" alt="image-20211023204912435" style="zoom: 23%;" /><img src="E:\MarkDown\picture\image-20211023205630833.png" alt="image-20211023205630833" style="zoom: 53%;" />



![image-20211023210537418](E:\MarkDown\picture\image-20211023210537418.png)



```c++
#include<iostream>
using namespace std;

void move(char a, char b) {
	cout << a << "->" << b << endl;
}

void hanoi(int n,char x,char y,char z) {
	if (n == 1) move(x, z);
	else {
		hanoi(n - 1, x, z, y);
		move(x, z);
		hanoi(n - 1, y, x, z);
	}
}

int main() {
	hanoi(3,'a', 'b', 'c');
}
```

<img src="E:\MarkDown\picture\image-20211023212232803.png" alt="image-20211023212232803" style="zoom:50%;" />



#### 八皇后问题

![image-20211023213253158](E:\MarkDown\picture\image-20211023213253158.png)

<img src="E:\MarkDown\picture\image-20211023215010553.png" alt="image-20211023215010553" style="zoom:67%;" />

<img src="E:\MarkDown\picture\image-20211023215232953.png" alt="image-20211023215232953" style="zoom:67%;" />

<img src="E:\MarkDown\picture\image-20211023220635611.png" alt="image-20211023220635611" style="zoom: 80%;" />

![image-20211023220834236](E:\MarkDown\picture\image-20211023220834236.png)

![image-20211023220907246](E:\MarkDown\picture\image-20211023220907246.png)

![image-20211023220938425](E:\MarkDown\picture\image-20211023220938425.png)

<img src="E:\MarkDown\picture\image-20211023221024164.png" alt="image-20211023221024164" style="zoom:67%;" />

<img src="E:\MarkDown\picture\image-20211023221404056.png" alt="image-20211023221404056" style="zoom:67%;" />

n,col n行col列
for(i=0到n){

随机来个col，if([i ] [col ]!=1)

flag

flag[col];

标记对角线

}

![image-20211023221741417](E:\MarkDown\picture\image-20211023221741417.png)

![image-20211023221514521](E:\MarkDown\picture\image-20211023221514521.png)

![image-20211023221618462](E:\MarkDown\picture\image-20211023221618462.png)

![image-20211023221714759](E:\MarkDown\picture\image-20211023221714759.png)

### 2.5 队列

循环队列较为常用，采用front指向对头第一个元素，rear指向队尾的下一个元素，与大话数据结构保持同步，与懒猫视频不同。

和王卓视频里一样，是少用一个元素空间来区分队空和队满

#### 循环队列

```c++
#pragma once
#include<iostream>
using namespace std;
const int QUEUESIZE = 100;

template<class DataType>
class CirQueue {
private:
	DataType* data;  // 指向队列存储空间
	int front;  // 队首下标
	int rear;  // 队尾下标
	int mSize;  // 存放队列的数组大小
public:
	CirQueue();  
	CirQueue(int size);
	~CirQueue();  // 清空队列，释放内存
	bool enQueue(DataType item);  // 入队
	bool deQueue(DataType& item);  // 出队
	bool getFront(DataType& item);  // 读取队头元素但不删除
	bool isEmpty();
	bool isFull();
	void clearQueue();
	void displayQueue();  // 显示队列内容
	int queueLength();  // 获取队列元素个数
};

template<class DataType>
CirQueue<DataType>::CirQueue() {
	mSize = QUEUESIZE;
	data = new DataType[mSize];
	front = 0;  // 赋初值为0
	rear = 0;
}

template<class DataType>
CirQueue<DataType>::CirQueue(int size) {
	mSize = size;
	data = new DataType[mSize];
	front = 0;  // 赋初值为0
	rear = 0;
}

template<class DataType>
CirQueue<DataType>::~CirQueue() {
	front = 0; 
	rear = 0;
	mSize = 0;
	delete[] data;
}


template<class DataType>
bool CirQueue<DataType>::isFull() {
	if ((rear + 1) % QUEUESIZE == front) return true; // 尽管只差一个位置时就是满的情况，但也可能相差整整一圈
	else return false;
}

template<class DataType>
bool CirQueue<DataType>::isEmpty() {
	if (front==rear) return true; 
	else return false;
}

template<class DataType>
int CirQueue<DataType>::queueLength() {
	return (rear - front + QUEUESIZE) % QUEUESIZE;
}

template<class DataType>
bool CirQueue<DataType>::enQueue(DataType item) {
	if (isFull()) return false;
	data[rear] = item;
	rear = (rear + 1) % QUEUESIZE;
	return true;
}

template<class DataType>
bool CirQueue<DataType>::deQueue(DataType& item) {
	if (isEmpty()) return false;
	item = data[front];
	front = (front + 1) % QUEUESIZE;
	return true;
}

template<class DataType>
bool CirQueue<DataType>::getFront(DataType& item) {
	if (isEmpty()) return false;
	item = data[front];
	return true;
}

template<class DataType>
void CirQueue<DataType>::displayQueue() {
	int head = front;
	for (int i = 0; i < queueLength(); i++) {
		cout << data[head] << endl;
		head++;
	}
	cout << "输出完毕" << endl;
}

template<class DataType>
void CirQueue<DataType>::clearQueue() {
	front = 0;
	rear = 0;
	mSize = 0;
}

int main() {
	CirQueue<int> c;
	c.enQueue(5);
	c.enQueue(4);
	c.enQueue(3);
	int m;
	c.deQueue(m);
	cout << "出栈元素为：" << m << endl;
	c.displayQueue();
	c.clearQueue();
	c.displayQueue();
}
```

#### 链队列

将队头指针指向链队列的头结点（不存数据），队尾指针指向终端结点

空队列时，front和rear都指向头结点

```c++
#pragma once
#include<iostream>
using namespace std;

template<class DataType>
class Node {//链表结点
public:
	DataType data;
	Node* next;
};

template<class DataType>
class LinkQueue {
private:
	Node<DataType>* front,*rear;
	int mSize;  // 存放队列的数组大小
public:
	LinkQueue();  // 建立头结点，初始化属性
	~LinkQueue();  // 释放内存
	void enQueue(DataType item);  // 入队
	bool deQueue(DataType& item);  // 出队,即头结点的后继结点出队
	bool getFront(DataType& item);  // 读取队头元素但不删除
	bool isEmpty();
	void clearQueue();
	void displayQueue();  // 显示队列内容
	int queueLength();  // 获取队列元素个数
};

template<class DataType>
LinkQueue<DataType>::LinkQueue() {
	front = new Node<DataType>;
	front->next = NULL;
	rear = front;
	mSize = 0;
}

// 自写的析构函数
template<class DataType>
LinkQueue<DataType>::~LinkQueue() {
	Node<DataType>* m;
	while (front->next != NULL) {
		m = front->next;
		front->next = m->next;
		delete m;
	}
	delete front;//这里和王卓的不一样，王卓是从头结点开始释放，而这里是类似出队，然后最后释放头结点
	front = NULL;// 防止野指针
	rear = NULL;
}

template<class DataType>
void LinkQueue<DataType>::enQueue(DataType item) {
	Node<DataType>* m;
	m = new Node<DataType>;
	m->data = item;
	m->next = NULL;
	// 队列有头节点
	rear->next = m;
	rear = m;
	mSize++;
	// 若没有头结点
	// rear = m;
	// front = m;
}

template<class DataType>
bool LinkQueue<DataType>::deQueue(DataType& item) {
	if (isEmpty()) return false;
	Node<DataType>* m;
	m = front->next;
	item = m->data;
	front->next = m->next;
	if (m->next = NULL) rear = front;
	delete m;
	mSize--;
	return true;

}

template<class DataType>
bool LinkQueue<DataType>::isEmpty() {
	if (rear = front) return true;
	return false;
}
```

#### 离散事件模拟/银行排队模拟



