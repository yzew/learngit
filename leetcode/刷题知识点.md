[toc]



## 计算多边形面积

> 叉积：结果是一个向量，大小等于两向量围成的平行四边形面积

鞋带定理：使用叉积计算多边形的面积是一种常用的方法。这种方法基于向量的性质，通过将多边形分割成多个三角形，然后计算每个三角形的面积，最后将所有三角形的面积相加得到多边形的总面积。

假设我们有一个多边形的顶点坐标存储在一个向量（或数组）中，按照顺时针或逆时针顺序排列。为了计算多边形的面积，我们需要遍历每个顶点，并计算它与相邻两个顶点形成的向量的叉积。具体的步骤如下：

1. 遍历多边形的每个顶点，计算当前顶点与下一个顶点形成的向量，然后计算这个向量与下一个向量的叉积。注意，最后一个顶点与第一个顶点形成的向量也要考虑在内。
2. 将所有三角形的面积相加得到多边形的总面积。

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct Point {
	double x, y;
};

double polygonarea(vector<Point>& polygon)
{
	int n = polygon.size();
    int i, j;
    double area = 0;
    for (i = 0; i < n; i++) {
        j = (i + 1) % n;
        area += polygon[i].x * polygon[j].y;
        area -= polygon[i].y * polygon[j].x;
    }
    area /= 2;
    return(area < 0 ? -area : area);
}

int main(){
    int n;
    cin >> n;
    vector<Point> polygon(n);
    for (int i = 0; i < n; i++) {
		double x, y;
        cin >> x >> y;
        polygon[i].x = x;
        polygon[i].y = y;
    }
    cout << polygonarea(polygon) << endl;
    return 0;
}
```



## 判断点是否在多边形内部

> 仅适用于简单多边形

要判断一个点是否在多边形内部，可以使用射线法。

这个算法的基本思想是从该点引一条射线，然后统计这条射线与多边形各边的交点个数，如果交点个数是奇数，则说明该点在多边形内部；如果交点个数是偶数，则说明该点在多边形外部。

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct Point {
    double x, y;
};

bool inside(Point point, vector<Point> polygon) {
    int n = polygon.size();
    if (n < 3) return false;

    int count = 0;
    for (int i = 0; i < n; ++i) {
        int j = (i + 1) % n;
		// 如果在两个点范围内
        if ((polygon[i].y <= point.y && point.y < polygon[j].y) ||
            (polygon[j].y <= point.y && point.y < polygon[i].y)) {
            // intersectionX为该边与点的水平线的交点
            // (point.y - polygon[i].y) 是y
            // (polygon[j].x - polygon[i].x) / (polygon[j].y - polygon[i].y)是斜率
            // 相乘就是point和线间的x
            double intersectionX = (point.y - polygon[i].y) * (polygon[j].x - polygon[i].x) / (polygon[j].y - polygon[i].y) + polygon[i].x;
            // 如果交点在点的右侧
            if (point.x < intersectionX) count++;
        }
    }
	// 奇数个交点则在内部
    return (count % 2 == 1);
}

int main() {
    int n;
    cin >> n;

    vector<Point> polygon(n);
    for (int i = 0; i < n; ++i) {
        cin >> polygon[i].x >> polygon[i].y;
    }

    Point point;
    cin >> point.x >> point.y;

    cout << inside(point, polygon);

    return 0;
}
```



## sql

```sql
-- 去除重复行
#注意，distinct是对后面 所有列名 的组合进行去重
select distinct id, salary
from employees
order by salary -- 默认升序ASC，也可以设置降序 order by salary desc;
LIMIT 20,10; # 显示第21到30条记录

-- like
# _：匹配任意一个字符；
# %：匹配0个或多个字符
SELECT device_id
FROM user_profile
WHERE university LIKE '%北京%'

-- round保留一位小数
select 
  count(gender) as male_num,
  round(avg(gpa), 1) as avg_gpa
from user_profile where gender="male";


SELECT ...,....,...
FROM ... JOIN ... 
ON 多表的连接条件
JOIN ...
ON ...
WHERE 不包含组函数的过滤条件
AND/OR 不包含组函数的过滤条件
GROUP BY ...,...
HAVING 包含组函数的过滤条件
ORDER BY ... ASC/DESC # (默认升序，ASC)
LIMIT ...,...
```

![image-20230612093749812](E:\MarkDown\picture\image-20230612093749812.png)



```mysql
#中图：内连接 A∩B
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
ON e.`department_id` = d.`department_id`;
```

```mysql
#左上图：左外连接
SELECT employee_id,last_name,department_name
FROM employees e LEFT JOIN departments d
ON e.`department_id` = d.`department_id`;
```

```mysql
#右上图：右外连接
SELECT employee_id,last_name,department_name
FROM employees e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`;
```

```mysql
#左中图：A - A∩B
SELECT employee_id,last_name,department_name
FROM employees e LEFT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE d.`department_id` IS NULL
```

```mysql
#右中图：B-A∩B
SELECT employee_id,last_name,department_name
FROM employees e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE e.`department_id` IS NULL
```

```mysql
#左下图：满外连接
# 左中图 + 右上图  A∪B
SELECT employee_id,last_name,department_name
FROM employees e LEFT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE d.`department_id` IS NULL
UNION ALL  #没有去重操作，效率高
SELECT employee_id,last_name,department_name
FROM employees e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`;
```

```mysql
#右下图
#左中图 + 右中图  A ∪B- A∩B 或者 (A -  A∩B) ∪ （B - A∩B）
SELECT employee_id,last_name,department_name
FROM employees e LEFT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE d.`department_id` IS NULL
UNION ALL
SELECT employee_id,last_name,department_name
FROM employees e RIGHT JOIN departments d
ON e.`department_id` = d.`department_id`
WHERE e.`department_id` IS NULL
```

函数

```sql
# 按长度排序
SELECT last_name, LENGTH(last_name) "name_length"
FROM employees
ORDER BY name_length

# 查询员工id,last_name,salary，并作为一个列输出，别名为OUT_PUT
SELECT CONCAT(employee_id, ',', last_name, ',', salary) "OUT_PUT"
FROM employees

# 查询员工姓名，hire_date , department_id，满足以下条件：
# 雇用时间在1997年之后，department_id为80 或 90 或110, commission_pct不为空
SELECT last_name, hire_date, department_id
FROM employees
WHERE department_id IN (80, 90, 110)
AND commission_pct IS NOT NULL
#and hire_date >= '1997-01-01' # 隐式的转换
#and date_format(hire_date, '%Y-%m-%d') >= '1997-01-01'# 显示转换：格式化：日期 ——> 字符串
AND DATE_FORMAT(hire_date, '%Y') >= '1997'# 显示转换：格式化：日期 ——> 字符串
#and hire_date >= str_to_date('1997-01-01','%Y-%m-%d') # 显示转换：解析：字符串 ——> 日期
```



## 一些头文件

```cpp
#include<bits/stdc++.h>  // 建议用万金油头文件
```

## ACM

多组空格分隔的正整数

```CPP
#include <bits/stdc++.h>
using namespace std;

int main() {
    int a;
    while (cin >> a) { // 注意 while 处理多个 case
        vector<int> vec;
        vec.push_back(a);
        // 如果不是换行符的话，读到的是数字后面的空格或者table，被getchar吃掉
        while (getchar() != '\n') {
            cin >> a;
            vec.push_back(a);
        }
        // 读取完一行，进行逻辑处理
        cout << maxProfit(vec);
    }
}
```

## 快排

```cpp
void quicksort(vector<int>& nums, int left, int right) {
	if (left >= right) return;
	swap(nums[rand() % (right - left + 1) + left], nums[right]);
    int pivot = nums[right];
    int lt = left - 1, gt = right, cur = left;  // 当前遍历位置
    while (cur < gt) {
		if (nums[cur] < pivot) swap(nums[cur++], nums[++lt]);
		else if (nums[cur] > pivot) swap(nums[cur], nums[--gt]);
		else cur++;
    }
    swap(nums[right], nums[gt]);
    quicksort(nums, left, lt);
    quicksort(nums, gt + 1, right);
}
```

## 计数质数

求2到n的质数和

```cpp
class Solution {
public:
    int countPrimes(int n) {
        vector<int> isPrime(n, 1);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i]) {
                ans += 1;
                if ((long long)i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = 0;
                    }
                }
            }
        }
        return ans;
    }
};
```



## ASCII码

| 十进制 | 字符  |
| ------ | ----- |
| **48** | **0** |
| **57** | **9** |
| **65** | **A** |
| **97** | **a** |

## 输出小数

> 保留两位有效数字：`cout << setprecision(2) << add;`

四舍五入

保留两位小数：`printf("%.2f", a);`

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
	double a = 1.455;
	printf("%.2f", a);  // 1.46
}

#include<bits/stdc++.h>
using namespace std;
// cout<<fixed<<setprecision(2);设置一次就行
int main() {
	cout<<fixed<<setprecision(2);
	double a = 1.455;
	cout << a;  // 1.46
}
```

%x 16进制

## 截取字符串

```cpp
#include <bits/stdc++.h>  // 也可以直接使用这个万能头文件
using namespace std;

int main() {
    string s;
    vector<string> vec;
    while (cin >> s) {  // 注意，这里s读取的是一整行（cin遇空格或换行才停止）
        stringstream ss(s);  // 将s变为stringstream对象
        string tmp = "";
        // while(ss >> tmp) {  // 如果是以空格分割的话，这样写就行
        while(getline(ss, tmp, ',')) {  // 以,为分隔符读取
            vec.push_back(tmp);
        }
        // ....
    }
}
```

## 构造链表

输入一串数字到双向链表中，再将一个数字插入到该单向/双向链表中，最后按从小到大的顺序排列输出

```cpp
# include<iostream>
#include<vector>
using namespace std;

// 单链表
struct ListNode {
	int val;  // 节点上存储的元素
	ListNode* next;  // 指向下一个节点的指针
	ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};

ListNode* creat(vector<int>& vec) {//创建n个节点
	ListNode* head = new ListNode(vec[0]);
	ListNode* temp = head;
	
	for (int i = 1; i < vec.size(); i++) {
		ListNode* node = new ListNode(vec[i]);
		
		temp->next = node;
		temp = temp->next;
	}
	return head;
}

//往链表中插入值为val的节点,尾插法，插在尾部
void insert_list(ListNode* head, int val) {
	ListNode* node = new ListNode(val);
	if (head == NULL) {
		head = node;
	}

	ListNode* temp = head;
	while (temp->next) {
		temp = temp->next;
	}
	temp->next = node;
}


//按照节点值从小到大的顺序进行排序
void sort_list(ListNode* head) {
	ListNode* temp = new ListNode(0);
	temp = head;

	while (temp) {
		ListNode* node = head;
		
		while (node->next) {
			if (node->next->val < node->val) {
				int val = node->next->val;
				node->next->val = node->val;
				node->val = val;
			}
			node = node->next;
		}
		temp = temp->next;

	}
	delete temp;
}

//输出链表节点值
void print_list(ListNode* head) {
	ListNode* temp = new ListNode(0);
	temp = head;
	while (temp) {
		cout << temp->val << " ";
		temp = temp->next;
	}
	cout << endl;
	delete temp;
}

int main() {
	int a = 5;
	vector<int> vec{ 1,2,3,9,6,4 };
	//cout << "请输入一串数字：";
	//while (cin >> a) {
	//	vec.push_back(a);
	//}

	ListNode* head = creat(vec);
	cout << "链表节点顺序：" << endl;
	print_list(head);

	//cout << "请输入要插入的数字：";
	//cin >> a;
	insert_list(head, a);
	insert_list(head, a);
	cout << "插入节点后链表节点顺序：" << endl;
	print_list(head);

	sort_list(head);
	cout << "排序后链表节点顺序："<<endl;
	print_list(head);

	return 0;
}
```

## 构造二叉树

输入数组（层序遍历的顺序），构造二叉树，其中用 -1 来表示null

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// 根据数组构造二叉树
TreeNode* construct_binary_tree(const vector<int>& vec) {
    vector<TreeNode*> vecTree (vec.size(), NULL);
    TreeNode* root = NULL;
    // 把输入数值数组，先转化为二叉树节点数组
    for (int i = 0; i < vec.size(); i++) {
        TreeNode* node = NULL;
        if (vec[i] != -1) node = new TreeNode(vec[i]); // 用 -1 表示null
        vecTree[i] = node;
        if (i == 0) root = node;
    }
    
    for (int i = 0; i * 2 + 1 < vec.size(); i++) {
        if (vecTree[i] != NULL) {
            // 线性存储转连式存储关键逻辑
            vecTree[i]->left = vecTree[i * 2 + 1];
            if(i * 2 + 2 < vec.size()) vecTree[i]->right = vecTree[i * 2 + 2];
        }
    }
    return root;
}

int main() {
    // 注意本代码没有考虑输入异常数据的情况
    // 用 -1 来表示null
    int a;
    while (cin >> a) {
	
    }
    vector<int> vec = {4,1,6,0,2,5,7,-1,-1,-1,3,-1,-1,-1,8};
    TreeNode* root = construct_binary_tree(vec);
    
    //  处理逻辑
}

```

## 十大排序相关

不稳定排序：快排、堆排、选择、希尔

![image-20230213125004139](E:\MarkDown\picture\image-20230213125004139.png)

> 排序算法的稳定性：
> 	指若有重复数据时，若这些重复数据的相对次序保持不变，则是稳定的；反之则是不稳定的。
>
> 一般只需要记住，**快排、堆排、选择排序和希尔排序是不稳定的**即可

## 时间复杂度

priority_queue 插入O(logN)
unordered_map、unordered_set 无序 插入O(1)，但最坏为O(n)，也取决于哈希表。查询也是O(1)
map、set、multimap、multiset的底层实现都是平衡二叉搜索树（AVL数）/ 红黑树 插入删除都为O(logn)。如果插入单个元素且无暗示，时间复杂度为 O(logn)，其中 n 为容器的大小。
如果插入单个元素且有最优位置（Position）暗示，时间复杂度为 O(1)，这是一个平均分摊后的常值。
如果插入多个元素，时间复杂度为 O(nlogn)，“第一个” n 为插入元素数，“第二个” n 为插入元素数加容器大小。如果插入的范围中的元素已经按同样的排序规则排序，执行过程将被优化，时间复杂度甚至会降到 O(n)。



vector.insert和list.insert的时间复杂度都为O(n)
因为**链表插入**元素前，还是要先遍历找到需要**插入的**位置**的**地址O(n)，然后**插入**O(1)

## sort及排序算法

关于[排序](https://leetcode.cn/problems/sort-an-array/solution/dang-wo-tan-pai-xu-shi-wo-zai-tan-xie-shi-yao-by-s/)算法



C++ std sort：整体采用快速排序的算法，时间复杂度为O(nlogn)，并且选择哨兵的时候，采用了三数取中法（头部，中部，尾部元素，三者的中间值作为哨兵）。如果在某次递归时，数据量小于16个，则采用插入排序。如果递归层次过深，会采用桶排序。其实std的实现还有更进一步优化，前面所说的有一些细节上不太一样，想关心具体源码细节的同学可以参考[知无涯之std::sort源码剖析](https://feihu.me/blog/2014/sgi-std-sort/)。

[c++实现的十大排序](https://leetcode.cn/problems/sort-an-array/solution/by-peaceful-thompsonfsu-b3bu/)



sort的使用

> 1. `vector<int>& a`里要用引用，否则刷一些题的时候可能会超时
> 2. 作为谓词的函数若是定义在类中，需要定义为静态成员变量(static)

```cpp
// 将0维度从大到小排（身高相同的话则1维度小的站前面）
static bool cmp(vector<int>& a, vector<int>& b) {
    if (a[0] == b[0]) return a[1] < b[1];
    return a[0] > b[0];
}
sort(people.begin(), people.end(), cmp);
```





## lambda

```cpp
// 错误使用：
auto f = [](pair<int, int>& a, pair<int, int>& b) -> bool  {return a.second > b.second;};
// 通过一个从小到大排列的优先队列，来维持k个最大元素
priority_queue<pair<int, int>, vector<pair<int, int>>, f> que;

// 对于容器，自定义排序方式需要输入的是仿函数！lambda是一个可调用对象，是个谓词
```

## list

```cpp
std::list<int> l = {7, 5, 16, 8};

// element
list.front();
list.back();

// iterator
begin();
end();

empty();
size();

insert();
emplace();
erase();  // 填入迭代器
push_back();  // 填入元素
push_front();
emplace_back();
emplace_front();
pop_back();
pop_front();
```



## set

insert函数的返回值：

* set和unordered_set的insert函数返回值是pair<iterator,bool>。pair的第一个成员是指向欲插入元素的迭代器，第二个成员是布尔量，表示本次操作是否成功。
* multiset的insert函数的返回值是指向所插入元素的迭代器。

```cpp
if (set.insert(nums[i]).second) {
	// ....
}
```



## **queue**

```cpp
#include<queue>
// queue先进先出
queue<int> que;
q.emplace(args);
q.push();  // 在末尾插入
q.pop();  // 弹出首元素
q.front();
q.back();
```



## priority_queue

```cpp
priority_queue<pair<int, int>> q;
// 默认排序使用less<T>，容器中最大的元素会排在队列前面，即大顶堆，队头为最大元素
// 可以通过emplace插入二元组，先比较二元组的第一个元素，第一个元素相等则比较第二个元素
q.emplace(nums[i], i);
q.push(aaa);
q.pop();
q.top();
q.size();

// priority_queue<Type, Container, Functional>
// 其中Functional是一个仿函数（一个重载了operator()的类）
// 小顶堆，升序队列
priority_queue <int,vector<int>,greater<int> > q;
// 自定义比较方式的小顶堆
class mycomparison {
public:
	bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
		return lhs.second > rhs.second;
	}
};
// 小顶堆，队头是最小值
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> q;
```



## vector和其他容器的相互转化

```cpp
list<vector<int>> lst;
...
return vector<vector<int>>(lst.begin(), lst.end());
```



```cpp
vector<string> wordDict
unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
```



> 对于容器适配器stack、queue、priority_queue，不存在`stack<int> st(nums.size())`这样定义了容量的构造方式，因为容器适配器不提供迭代器

## string和数值之间的转换

![image-20230203151413610](E:\MarkDown\picture\image-20230203151413610.png)

截取字符串

s.substr(pos, len)，从pos开始截取len长度，时间复杂度为O(len)



## 一些常用的函数

求2^n：`1 << n` 或 `pow(2, n)`

```cpp
#include<cmath>
double sqrt(double n);  // 开根号函数
```

max函数想比较多个变量：

```cpp
#include<algorithm>
max({a, b, c});
```

vector没有内置的find函数
`find(wordDict.begin(), wordDict.end(), tmp) != wordDict.end()`





回溯法的函数参数也尽量写为引用，若想增加安全性，加个const

```cpp
bool aa(int tag, const string& s, const unordered_set<string>& wordDict)
```

## 差分

差分的思路：
	定义一个diff差分数组，起点处++，终点+1处--，顺便统计下start和end。然后在这个范围内遍历diff，res[i] += res[i - 1] + diff[i];得到结果数组。结果数组就存储着每个位置处重合的数量

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
	int num;
	cin >> num;
	vector<int> diff(1e6 + 1, 0);
	// 确定时间片的最大范围
	int n = 0, start = 1e6 + 2;
	for (int i = 0; i < num; i++) {
		int a, b;
		cin >> a >> b;
		start = min(start, a);
		n = max(n, b);
		diff[a] += 1;
		diff[b + 1] -= 1;
	}
	// 根据diff中的起点终点进行累加
	// 如 2-5 8-9，在diff中
	// 2 3 4 5  6 7 8 9 10
	// 1 0 0 0 -1 0 1 0 -1
	// 在res中
	// 1 1 1 1  0 0 1 1
	vector<int> res(n + 1, 0);
	res[0] = diff[0];
	for (int i = 1; i < n + 1; i++) {
		res[i] += res[i - 1] + diff[i];
	}
	// 从2到9遍历
	int sum = 0;
	for (int i = start; i < n + 1; i++) {
		if (res[i] == 0) sum += 1;
		else if (res[i] == 1) sum += 3;
		else sum += 4;
	}
	cout << sum;
}
```



## 数据类型

两个位数不确定的数据类型：

long = long int，在linux64位下是8字节，其他情况是4字节，所以最好用long long(8字节) 

void*在32位下4字节，在64位下8字节



对于**浮点数**，cpp中常用的有float(单精度，4字节)、double(双精度，8字节) 和 long double（可能16字节、12字节、8字节）

对于**整数**，short(2字节)、int(4字节)、long long(8字节)，int64_t(long long，8字节)，uint64_t(unsigned long long)用的比较多

其他还有int8_t(char)/int16_t(short)/int32t(int)以及对应的uint8_t等

long long不需要 #include < cstdint>。但写库时，int64_t 用得更多，因为你没法确定对方用的编译器中 long long 一定是64bits。

![image-20230206192108197](E:\MarkDown\picture\image-20230206192108197.png)



## 数组

​	在leetcode中数组长度不能定义为变量。在其他编译器里是可以的，但不建议使用。因为**数组**使用的是**栈**内存，栈内存是有大小限制的，一般是8192字节，既然长度是变量，那就可能是任何值，就有可能超过8192，这样就会stack overflow，所以动态内存最好使用堆内存。比如`vector<int> v = {1, 2, 3}`，v一般是栈对象，而其内容会被allocator分配到堆中

```cpp
int fib(int n) {
        if (n <= 1) return n;
        int dp[n + 1] = {0};
}
```



## array

> std::array与数组相同，也是分配在栈内存中

​	std::array是具有固定大小的数组。因此，它并不支持添加或删除元素等改变大小的操作。也就是说，当定义一个array时，除了指定元素类型，还要指定容器大小。

​	定义`array`时，需要指定其数据类型和大小，两者不可或缺。同时，array的大小不能使用变量来指定，但对于内置数组来说，是可以使用变量来指定数组大小的。定义`array`时，可以使用{}来直接初始化，也可以使用另外的array来构造，但不可以使用内置数组来构造。

```cpp
# include <iostream>
# include <array>

int main(int argc, char const *argv[])
{
  std::array<int, 5> a0 = {0, 1, 2, 3, 4};          //正确
  std::array<int, 5> a1 = a0;                       //正确
  int m = 5;
  int b[m];                                 //正确，内置数组
  std::array<int, 5> a2;                    //正确
  std::array<int, m> a3;                    //错误，array不可以用变量指定
  std::array<int, 5> a4 = b;                //错误，array不可以用数组指定

  return 0;
}
```



既然有了内置的数组，为什么还要引入array呢？

​	内置的数组有很多麻烦的地方，比如无法直接对象赋值，无法直接拷贝等等，同时内置的数组又有很多比较难理解的地方，比如数组名是数组的起始地址等等。相比较于如vector等容器的操作，内置数组确实有一些不方便的地方。因此，C++11就引入array容器来代替内置数组。

​	简单来说，std::array除了有内置数组支持随机访问、效率高、存储大小固定等特点外，还支持迭代器访问、获取容量、获得原始指针等高级功能。而且它还不会退化成指针给开发人员造成困惑。


`std::array`提供了`[]`、`at`、`front`、`back`、`data`的方式来进行元素：

> 尽量使用at方法来访问元素，因为运算符[]不会对索引值进行检查，像myarray[-1]是不会报错的。使用at()，将在运行期间捕获非法索引的，默认将程序中断。

| 访问方式 |                含义                |
| :------: | :--------------------------------: |
|    at    |  访问指定的元素，同时进行越界检查  |
|   \[\]   |           访问指定的元素           |
|  front   |           访问第一个元素           |
|   back   |          访问最后一个元素          |
|   data   | 返回指向内存中数组第一个元素的指针 |

和一般的容器一样，`array`还提供了迭代器的方式进行元素遍历和访问：

| 迭代器 |               含义               |
| :----: | :------------------------------: |
| begin  |  返回指向容器第一个元素的迭代器  |
|  end   |     返回指向容器尾端的迭代器     |
| rbegin | 返回指向容器最后元素的逆向迭代器 |
|  rend  |     返回指向前端的逆向迭代器     |

`array`支持其它一些函数：

|   函数    |          含义          |
| :-------: | :--------------------: |
|   empty   |    检查容器是否为空    |
|   size    |    返回容纳的元素数    |
| max\_size | 返回可容纳的最大元素数 |
|   fill    |    以指定值填充容器    |
|   swap    |        交换内容        |
