# 华为

## ==华为0412暑期实习==

## 1.交易系统的降级策略

​	有一个核心交易系统接口被N个上游系统调用，每个上游系统的调用量R=[R1,R2.....,RN].由于核心交易系统集群故障，需要暂时系统降级限制调用，核心交易系统能接受的最大调用量为cnt。设置降级规则如下;如果sum(R1.R2..RN)小于等于cnt，则全部可以正常调用，返回-1;如果sum(R1.R2....RN)大于cnt，设置一个闻值limit，如果某个上游系统发起的调用量超过limit，就将该上游系统的调用量限制为limit，其余未达到limit的系统可以正常发起调用。求出这个最大的lmit (mit可以为0)此题目对效率有要求，请选择高效的方式。

**输入描述**

第一行:每个上游系统的调用量(整型数组) 第二行:核心交易系统的最大调用量cnt 0<R.length<=10^5，0<R[i]<105，0<cnt <= 10^9

**输出描述**

调用量的阈值Iimit

**样例1输入**:

```
1 4 2 5 5 1 6 
13
```

**输出:**

```
 2
```

**解释:**

```
因为1+4+2+5+5+1+6>13;将limit设置为2，则1+2+2+2+2+1+2=12<13。所以imit为2
```

**样例2输入:**

```
1 7 8 8 1 0 2 4 9
7
```

**输出:**

```
0
```

解释:因为即使limit设置为1,1+1+1+1+1+1+1+1=8>7也不满足，所以limit只能为0



使用二分法，找右边界，即满足条件中最大的。这里涉及到二段性的分析，假设limit为x的时候是可以满足约束的，那么x-1的时候，必然也是满足的，因此这个属性是具有二段性的，所以可以对这个limit进行二分。

check()函数是判断当limit设置为x的时候，是否可以满足约束，这个函数的时间复杂度是O(n)。

二分的复杂度是O(log2n)，总体的复杂度是O(nlog2n)

```cpp
#include<bits/stdc++.h>
using namespace std;

vector<int> num;
int cnt;

bool check(int limit) {
	int sum = 0;
	for (auto i : num) {
		if (i < limit) sum += i;
		else sum += limit;
	}
	return sum <= cnt;
}

int main() {
	int a;
 	while (cin >> a) {
 		num.push_back(a);
 		if (cin.get() == '\n') {
 			break;
 		}
 	}
    cin >> cnt;
	int left = 0, right = 1e5;
	/************************ 二分查找，找右边界 *************************/
	while (left <= right) {
		int mid = left + (right - left) / 2;  // 必须+1，防止死循环
		if (check(mid)) left = mid + 1;
		else right = mid - 1;
	}
	if (right == 1e5) cout << -1 << endl;
	else cout << right << endl;
	return 0;
}
```

## 2.获取最多食物

​	主办方设计了一个获取食物的游戏。游戏的地图由N个方格组成，每个方格上至多2个传送门，通过传送门可将参与者传送至指定的其它方格。同时，每个方格上标注了三个数字: 
(1) 第一个数字id:代表方格的编号，从0到N-1，每个方格各不相同
(2) 第二个数字parent-id:代表从编号为parent-id的方格可以通过传送门传送到当前方格(-1则表示没有任何方格可以通过传送门传送到此方格，这样的方格在地图中有且仅有一个); 
(3) 第三个数字value:取值在[100，100]的整数值，正整数代表参与者得到相队取值单位的食物，负整数代表失去相应数值单位的食物(参与者可能存在临时持有食物为负数的情况)，0则代表无变化。

​	此外，地图设计时保证了参与者不可能到达相同的方格两次，并且至少有一个方格的value是正整数。 

​	游戏开始后，参与者任意选择一个方格作为出发点，当遇到下列情况之一退出游戏: 
​	(1) 参与者当前所处的方格无传送门: 
​	(2) 参与者在任意方格上主动宣布退出游戏

​	请计算参与者退出游戏后，最多可以获得多少单位的食物

第一行:方块个数N (N<10000)

**样例1输入**:

```
7
0 1 8
1 -1 -2
2 1 9
4 0 -2
5 4 3
3 0 -3
6 2 -3
```

**输出:**

```
9
```

**解释:**

```
参与者从方格0出发，通过传送门到达方格4，再通过传送门到达方格5。一共获得8+(-2) +3=9个单位食物，得到食物展多: 或者参与者在游戏开始时处于方格2，直接主动宣布退出游戏，也可以获得9个单位食物。
```

**样例2输入:**

```
3
0 -1 3
1 0 1
2 0 2
```

输出:

```
5
```

**解释:**

```
参与者从方格0出发，通过传送门到达方格2，一共可以获得3+2=5个单位食物，此时得到食物最多
```





树形dp。

我们定义dp[i]表示以节点i结尾，可以获取的最大食物的数量。

对于dp[i]，我们的选择有走到父节点和不走到父节点，我们取最大的即可。也就是

**dp[i] = max(当前节点的食物， 当前节点的食物 +  dp[parent_id])**

我们需要把所有的dp[i]都枚举一次，最终复杂度为O(n)

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int num;
	cin >> num;
	// id 父节点id 当前值
	vector<vector<int>> node(num, vector<int>(2, 0));
	for (int i = 0; i < num; i++) {
		int id, pid, val;
		cin >> id >> pid >> val;
		node[id][0] = pid;
		node[id][1] = val;
	}
	// 树形dp.dp[i]表示以节点i结尾，可以获取的最大食物的数量 
	vector<int> dp(num, INT_MIN);
	int result = INT_MIN;
	for (int i = 0; i < num; i++){
		if (node[i][0] == -1) {
			dp[i] = node[i][1];
			continue;
		}
		dp[i] = max(node[i][1], node[i][1] + dp[node[i][0]]);
		result = max(result, dp[i]);
	}
	cout << result << endl;
	return 0;
}
```



## ==华为od0310==

## 小王的密码本

小王在进行游戏大问关,有个关卡需要输入一个密码才能通过。密码获得的条件如下:在个密码本中,每页都有个由26个小写字母组成的若干位位密码，每一页的密码不同，需要从这个密码本中寻找这样的一个最长的密码，从它的末尾开始依次去掉一位得到的新密码也在密码本中存在。请输出符合该要求的密码，如果有多个符合要求的密码，则返回字典序最大的密码。若没有符合调节的密码，则返回空字符串。

**输入描述**

密码本由一个字符串数组组成，不同元素之间使用空格隔开，每一个元素代表密码本每一页的密码。

**输出描述**

一个字符串

**示例1**

**输入**

h he hel hell hello

**输出**

hello

**说明**

"hello"从末尾一次去掉一位得到的"hell", "hel","he"和"h"在密码本中都存在。

**示例2**

**输入**

b eredderd bw bww bwwl bwwlm bwwln

**输出**

bwwln

**说明**

"bwwlm"和"bwwln"从末尾一次去掉一位得到密码在密码本中都存在。但是"bwwln"比"bwwlm"字典序排序大，所以应该返回"bwwln"

**备注**

**1 <= 密码本的页数 <= 10^3**

**1 <= 每页密码的长度 <= 10^3**

```cpp
// 小王的密码本
#include<bits/stdc++.h>
using namespace std;
bool check(string i, unordered_set<string>& map) {
	while(i != "") {
		if (map.find(i) == map.end()) return false;
		i.pop_back();
	}
	return true;
}
int main() {
	string s;
	unordered_set<string> map;
	while (cin >> s) {
		map.insert(s);
		if (cin.get() == '\n') break;
	}
	string result;
	for (auto i : map) {
		if (check(i, map)) {
			if (i.size() > result.size()) result = i;
			else if (i.size() == result.size()) {
				if (i.back() > result.back()) result = i;
			}
		}
	}
	cout << result;
	return 0;
}
```



## 小明定酒店

放暑假了，小明决定到某旅游景点游玩，他在网上搜索到了各种价位的酒店（长度为n的数组A），他的心理价位是x元，请帮他筛选出k个最接近x元的酒店（n>=k>=0），并由低到高打印酒店的价格。

**备注**

酒店价格数组A和小明的心理价位x均为整形数据；（0<n,k,x<10000）< p=""></n,k,x<10000）<>

优先选择最接近心理价位的酒店；若两家酒店和心理价位差价相同，则选择价格较低的酒店。（比如100元和300元距离心理价位200元同样接近，此时选择100元）；

酒店价格可能相同重复。

**输入描述**

第一行：n,k,x

第二行：A[0] A[1] A[2] ... A[n-1]

**输出描述**

由低到高打印筛选出的酒店价格

**示例1**

**输入**

10 5 6

1 2 3 4 5 6 7 8 9 10

**输出**

4 5 6 7 8

**说明**

数组长度n=10，筛选个数k=4，目标价位x=6，当4和8距离x相同时，优先选择价格低的4



```cpp
#include<bits/stdc++.h>
using namespace std;

static bool cmp(int a, int b) {
	if (abs(a) == abs(b)) return a < b;
	return abs(a) < abs(b);
};

int main() {
	int length, num, price;
	cin >> length >> num >> price;
	vector<int> nums;
	int temp;
	for (int i = 0; i < length; i++) {
		cin >> temp;
		nums.push_back(temp - price);  // 正的就是高的
	}
	
	sort(nums.begin(), nums.end(), cmp);
	vector<int> result;
	for (int i = 0; i < num; i++) {
		result.push_back(nums[i] + price);
	}
	sort(result.begin(), result.end());
	for (int i = 0; i < result.size(); i++) {
		if (i == result.size() - 1) cout << result[i];
		else cout << result[i] << " ";
	}
	return 0;
}
```

## **站点部署**

​	当前IT部门支撑了子公司颗粒化业务，该部门需要实现为子公司快速开租建站的能力，建站是指在一个全新的环境部署一套IT服务。每个站点开站会由一系列部署任务项构成，每个任务部署完成时间都是固定和相等的，设为1。部署任务项之间可能存在依赖，假如任务2依赖任务1，那么等待任务1部署完，任务2才能部署。任务有多个依赖任务则需要等所有依赖任务都部署完该任务才能部署。没有依赖的任务可以并行部署，优先的员工们会做到完全并行无等待的部署。给定一个站点部署任务项和他们之间的依赖关系，请给出一个站点的最短开站时间。

**输入描述**

第一行是任务书taskNum，第二行是任务的依赖关系数relationNum

接下来 relationNum 行，每行包含两个id，描述一个依赖关系，格式为：IDi IDj，表示部署任务i部署完成了，部署任务j才能部署，IDi和IDj值的范围为：[0: taskNum)

注：输入保证部署任务之间的依赖不会存在环。

**输出描述**

一个整数，表示一个站点的最短开站时间

**示例1**

**输入**

5

5

0 4

1 2

1 3

2 3

2 4

**输出**

3



未作

一个简单的拓扑排序。由于题目保证不会成环，所以我们可以进行“计算拓扑排序的层数”即可。

```python
from collections import deque
if __name__ == '__main__':
    n = int(input())
    m = int(input())
    nxs = {i: set() for i in range(n)}
    indegre = [0 for _ in range(n)]
    for i in range(m):
        k, v = map(int, input().split())
        nxs[k].add(v)
        indegre[v] += 1

    q = deque()
    for i in range(n):
        if indegre[i] == 0:
            q.append(i)

    res = 0
    while len(q):
        res += 1
        size = len(q)
        for _ in range(size):
            cur = q.popleft()
            for nx in nxs[cur]:
                indegre[nx] -= 1
                if indegre[nx] == 0:
                    q.append(nx)

    print(res)
```



华为其他考题

https://space.bilibili.com/603025674/search/video?keyword=%E5%8D%8E%E4%B8%BA



![image-20230419174027461](E:\MarkDown\picture\image-20230419174027461.png)







```cpp
#include<bits/stdc++.h>
string temp = "";
int counta = 0;
void aa(string& s, vector<int>& used) {
    if (temp.size() == s.size()) {
        counta++;
        return;
    }
    for (int i = 0; i < s.size(); i++) {
        if (i > 0 && s[i] == s[i - 1] && used[i - 1] == 0) continue;
        if (used[i] == 1) continue;
        used[i] == 1;
        temp.push_back(s[i]);
        aa(s, used);
        temp.pop_back();
        used[i] == 0;
    }
}
int main()
{
    string s;
    cin >> s;
    sort(s.begin(), s.end());
    vector<int> used(s.size(), 0);
    aa(s, used);
    cout << counta;
    return 0;
}
```



# 小红书

AC

```cpp
#include<bits/stdc++.h>
using namespace std;

unordered_map<long long,long long> mapp;
long long aa(long long a) {
  if (a == 0) return 1;
  if (a == 1) return 3;
  long long tmp ;
  if (mapp.find(a - 1) != mapp.end()) {
    tmp = mapp[a - 1] * (a + 1) + 1 ;
  } else {
    tmp = aa(a - 1) * (a + 1) + 1 ;
  }
  mapp[a] = tmp % 1000000007;
  return tmp % 1000000007;
}
int main() {
  // 1 ~ 2
  // 2 一次后变为3个1， 1 + 2^3
  // 3 ~ 1 + ^4
  int num;
  cin >> num;
  vector<int> vec(num, 0);
  for (int i = 0; i < num; i++) {
    int tmp;
    cin >> tmp;
    vec[i] = tmp;
  }
  long long result = 0;
  for (auto i : vec) {
    if (mapp.find(i) != mapp.end())
      result += mapp[i];
    else {
      long long tmp = aa(i);
      result += tmp;
      mapp[i] = tmp;
    }
  }
  cout << result % 1000000007;
  return 0;
}

```



骗了27

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
  int n, k;
  cin >> n >> k;
  cin.get();
  string s;
  getline(cin, s, '\n');
  unordered_map<int, vector<int>> mapp;
  for (int i = 0; i < n - 1; i++) {
    int a, b;
    cin >> a >> b;
    mapp[a].push_back(b);
    mapp[b].push_back(a);
  }
  
  return 0;
}
```





# 恒生

题型：选择 + SQL + 两道编程

基础题不定项选择，包括计算机基础，网络，Linux，数据结构，等

SQL三道题，还挺复杂的。

SQL是MySQL经典面试题原题？

算法题：

1.二分查找寻找有序数组插入位置

2.实现固定大小内存块的内存池，比较坑的是没有测试程序



3.说给出N个整数，又给一个整数m,要求把这n个数分成m组，并要求每一个组的所有数的和尽可能相等，并且每一组的数的个数尽量一致，如有余数的，尽量放在一行，即保持每组的差异化很小，包括个数

首先，计算所有数字的总和S，并将其除以m，得到每个组的理论总和。如果S不能被m整除，则无法将它们分成完全相等的组。 接下来，将数字排序，从大到小排列。 创建一个长度为m的空列表，表示m个组。 对于每个数字，将其添加到当前总和最小的组中。为此，可以遍历列表，找到总和最小的组，并将数字添加到该组中。 重复步骤4，直到所有数字都被分配到组中。 返回列表，表示m个组。



<img src="E:\MarkDown\picture\image-20230331174809712.png" alt="image-20230331174809712" style="zoom:67%;" />

21	00
