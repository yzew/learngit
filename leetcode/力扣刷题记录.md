[toc]



﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿# 一、数组

> 数组是array，vector的底层实现是array，严格来讲vector是容器，不是数组。
>
> 注意，二维数组在内存的空间地址是什么样的？
>
> * 在C++中二维数组是连续分布的。
> * 在JAVA中，如：`int[][] rating = new int[3][4]`; ， 这个二维数据在内存空间可不是一个 3*4 的连续地址空间，而是四条连续的地址空间组成
>   ![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-16754250412513.png)

***
***
## ==前缀和==

## *1991. 找到数组的中间位置(~)*

[1991. 找到数组的中间位置](https://leetcode.cn/problems/find-the-middle-index-in-array/)

首先想到的思路会是双指针，然后哪边大就扩张另一边。但这里的问题是存在负数，因此不行

前缀和

```cpp
class Solution {
public:
    int findMiddleIndex(vector<int>& nums) {
        // 前缀和
        // 2×sum+numsi=total
        int sum = 0;
        for (int num : nums) sum += num;
        int add = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (2 * add + nums[i] == sum) return i;
            add += nums[i];
        }
        return -1;
    }
};
```

## *560. 和为 K 的子数组(~)*

[560.和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

> 注意，是连续子数组，不能sort

**前缀和 + unordered_map**

> 定义pre[i]为[0到i]里所有数的和，则 **[j到i]这个子数组的和为 k** 这个条件即为 pre[i] − pre[j−1] == k，即为 pre[j−1] == pre[i] − k，这样考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i] − k 的 pre[j] 即可
>
> 更好理解的是，一边记录当前的前缀和作为pre[j]，一边用当前的和作为pre[i]，查询pre[i] - k的个数

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        // curSum - preSum == k，则cur到pre这段的和就是k
        // preSum == curSum - k
        // 即一边将当前的和作为preSum记录在map中，一边查curSum - k
        int sum = 0;
        int result = 0;
        unordered_map<int, int> mapp;
        mapp[0] = 1;  // 初值很重要，当curSum == k时，刚好是一个
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            // 当前和视为curSum，查询curSum - k的个数
            if (mapp.find(sum - k) != mapp.end()) {
                result += mapp[sum - k];
            }
            mapp[sum]++;  // 作为preSum记录
        }
        return result;
    }
};
```

![image-20230221181429973](E:\MarkDown\picture\image-20230221181429973.png)

超出时间限制

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int result = 0;
        for (int i = 0; i < nums.size(); i++) {
            int sum = 0;
            for (int j = i; j < nums.size(); j++) {
                sum += nums[j];
                // 存在负数的情况
                // if (sum > k) break;
                if (sum == k) {
                    result++;
                    // 不能加break;，否则[-1 1 0] 0 这种例子过不了
                }
            }
        }
        return result;
    }
};
```

## ==摩尔投票==

## 169. 多数元素

[169. 多数元素](https://leetcode.cn/problems/majority-element/) [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

**摩尔投票法**

假设数组中每个不同的数字就代表一个国家，而数字的个数就代表这个国家的人数，他们在一起混战，就是每两个同归于尽。我们就可以知道那个人数大于数组长度一半的肯定会获胜。就算退一万步来说，其他的所有人都来攻击这个人数最多的国家，他们每两个两个同归于尽，最终剩下的也是那个众数

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        // 这里count设为1，因为这里tmp设了一个初值
        int count = 1;
        int tmp = nums[0];
        for (int i = 1; i < nums.size(); i++) {  // 注意，从1开始抵消
            // 前面的都同归于尽了
            if (count == 0) {
                count = 1;
                tmp = nums[i];
            } else if (nums[i] == tmp) {  // 友军
                count++;
            } else {  // 敌军
                count--;
            }
        }
        // 最后留下的就是众数
        return tmp;
    }
};
```

## 229. 多数元素 II

[229. 多数元素 II](https://leetcode.cn/problems/majority-element-ii/)

**摩尔投票法**

> 完整版的摩尔投票法分为两个阶段：抵消阶段和计数阶段。
>
> * 抵消阶段：两个不同投票进行对坑，并且同时抵消掉各一张票，如果两个投票相同，则累加可抵消的次数；
> * 计数阶段：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定。
>
> 出现次数超过 n/k 的数最多只有 k−1 个。否则必然违背「数总共只有 n 个」或者「当前统计的是出现次数超过 n/k 的数」的前提条件。

```cpp
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        vector<int> result;
        int count1 = 0, count2 = 0;
        int tmp1 = 0, tmp2 = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (tmp1 == nums[i]) count1++;
            else if (tmp2 == nums[i]) count2++;
            else if (count1 == 0) {
                tmp1 = nums[i];
                count1++;
            } else if (count2 == 0) {
                tmp2 = nums[i];
                count2++;
            } else {
                count1--;
                count2--;
            }
        }
        count1 = 0;
        count2 = 0;
        for (auto i : nums) {
            if (i == tmp1) count1++;
            else if (i == tmp2) count2++;
        }
        if (count1 > nums.size() / 3) result.push_back(tmp1);
        if (count2 > nums.size() / 3) result.push_back(tmp2);
        return result;
    }
};
```

## 面试题 17.10. 主要元素

[面试题 17.10. 主要元素](https://leetcode.cn/problems/find-majority-element-lcci/)

与多数元素的区别：多数元素保证一定存在多数元素，而此题不保证，因此需要增加一个判定的步骤

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int pre = nums[0];
        int count = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] == pre) count++;
            else count--;
            if (count == 0) {
                count = 1;
                pre = nums[++i];
            }
        }
        // 判断一下这个元素是不是最大元素
        count = 0;
        for (auto i : nums) {
            if (i == pre) count++;
        }
        if (count > nums.size() / 2) return pre;
        else return -1;
    }
};
```



## ==二分查找==

> 二分查找仅针对**有序**列表，且**无重复元素**的情况
>
> 时间复杂度为O(log n)
>
> 假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止
> <img src="E:\MarkDown\picture\image-20230213194348448.png" alt="image-20230213194348448" style="zoom:50%;" />
> 当n / 2^k = 1时，k的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了k次区间缩小操作，时间复杂度就是 O(k)。n / 2^k = 1,可以求得 k=log n，所以时间复杂度就是 O(logn)  
>
> * while (l < r) or **while (l <= r)**
>   若是[l,r]，则l==r时是在区间内的，未触发停止搜索条件，需要while (l <= r)
>   若是[l,r)，则是while (l < r)
>   这里统一用[l,r]
> * **left = mid + 1; right = mid - 1;**
> * 找左边界，找到target时，缩小搜索区间的上界`if (nums[mid] >= target) right = mid - 1;`
> * 找右边界，找到target时，增大搜索区间的下界`else if (nums[mid] <= target) left = mid + 1;`

##  *704. 二分查找(~)*
[力扣](https://leetcode-cn.com/problems/binary-search/)

**左闭右闭**

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] > target) right = mid - 1;
            else if (nums[mid] < target) left = mid + 1;
            else return mid;
        }
        return -1;
    }
};
```

**扩展**：有重复元素的话，找出第一个重复元素，即题34的简化版

错误思路：找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。

找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的

while 的退出条件是 `left == right + 1`。若target比数组中的元素都要小，则right会出界；若target比所有元素要大，则left会出界。因此求左边界的时候，返回left，就要对left进行越界判定，求右边界的时候，返回right，就要对right判定

**二分，找左边界**

如nums = [1,2,2,2,3]

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // 寻找左边界
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            // 找到target时，缩小搜索区间的上界
            if (nums[mid] >= target) right = mid - 1;
            else if (nums[mid] < target) left = mid + 1;
        }
        if (left >= nums.size() || nums[left] != target)
            return -1;
        return left;
    }
};
```

**二分，找右边界**

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // 寻找右边界
        int left = 0, right = nums.size() - 1;
        while (left <= right) {  // 左闭右闭
            int mid = (right - left) / 2 + left;
            // 找到target时，缩小搜索区间的左边界
            if (nums[mid] > target) right = mid - 1;
            else if (nums[mid] <= target) left = mid + 1;
        }
        if (right < 0 || nums[right] != target)
            return -1;
        return right;
    }
};
```

## 34. 在排序数组中查找元素的第一个和最后一个位置(~)

[剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

普通方法

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int count = 0;
        for (auto i : nums) {
            if (i == target) count++;
            if (i > target) break;
        }
        return count;
    }
};
```

二分法

思路：通过两次二分法找到左右边界

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // 找右边界
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int pivot = (left + right) / 2;
            if (nums[pivot] <= target) left = pivot + 1;
            else right = pivot - 1;
        }
        int rightB = left;
        
        // 优化
        // 查找的是右边界，此时left指向右边界。right指向left的上一个
        if (right >= 0 && nums[right] != target) return 0;
        
        // 找左边界
        left = 0, right = nums.size() - 1;
        while (left <= right) {
            int pivot = (left + right) / 2;
            if (nums[pivot] < target) left = pivot + 1;
            else right = pivot - 1;
        }
        int leftB = right;
        
        return rightB - leftB - 1;
    }
};
```

写成俩函数

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftBorder = searchleft(nums, target);
        int rightBorder = searchright(nums, target);
        return {leftBorder, rightBorder};
    }
private:
    int searchleft(vector<int>& nums, int target) {
        // 寻找左边界
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            // 找到target时，缩小搜索区间的上界
            if (nums[mid] >= target) right = mid - 1;
            else if (nums[mid] < target) left = mid + 1;
        }
        if (left >= nums.size() || nums[left] != target)
            return -1;
        return left;
    }
    int searchright(vector<int>& nums, int target) {
        // 寻找右边界
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            // 找到target时，缩小搜索区间的左边界
            if (nums[mid] > target) right = mid - 1;
            else if (nums[mid] <= target) left = mid + 1;
        }
        if (right < 0 || nums[right] != target)
            return -1;
        return right;
    }
};
```



**F2 随想录版**

![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-16754250412527.png)
> 计算出来的右边界是不包含target的右边界，左边界同理。最后得到的右边界-1，左边界+1

1. 寻找右边界
nums[middle] <= target的情况下，让left往右，rB为left，就能使得最后跳过target，使得r在target上，l和rB在target右边

```cpp
// 二分查找，寻找target的右边界（不包括target）
// 如果rightBorder为没有被赋值（即target在数组范围的左边，例如数组[3,3]，target为2），为了处理情况一
int getRightBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
    int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
    while (left <= right) { // 当left==right，区间[left, right]依然有效
        int middle = left + ((right - left) / 2);
        if (nums[middle] > target) {
            right = middle - 1;
        } else { // 当nums[middle] == target的时候，更新left，这样才能得到target的右边界
            left = middle + 1;
            rightBorder = left;
        }
    }
    return rightBorder;
}
```
2. 寻找左边界
当l和m找到target的时候，nums[middle] == target，right = middle - 1移动到了m左边，同时lB=right，即保存了左边界
```cpp
// 二分查找，寻找target的左边界leftBorder（不包括target）
// 如果leftBorder没有被赋值（即target在数组范围的右边，例如数组[3,3],target为4），为了处理情况一
int getLeftBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
    int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
    while (left <= right) {
        int middle = left + ((right - left) / 2);
        if (nums[middle] >= target) { // 寻找左边界，就要在nums[middle] == target的时候更新right
            right = middle - 1;
            leftBorder = right;
        } else {
            left = middle + 1;
        }
    }
    return leftBorder;
}
```
3. 处理三种情况
    * 情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}
    * 情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}
    * 情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}
```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);
        // 情况一
        if (leftBorder == -2 || rightBorder == -2) return {-1, -1};
        // 情况三
        if (rightBorder - leftBorder > 1) return {leftBorder + 1, rightBorder - 1};
        // 情况二
        return {-1, -1};
    }
private:
     int getRightBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
        while (left <= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] > target) {
                right = middle - 1;
            } else { // 寻找右边界，nums[middle] == target的时候更新left
                left = middle + 1;
                rightBorder = left;
            }
        }
        return rightBorder;
    }
    int getLeftBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
        while (left <= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] >= target) { // 寻找左边界，nums[middle] == target的时候更新right
                right = middle - 1;
                leftBorder = right;
            } else {
                left = middle + 1;
            }
        }
        return leftBorder;
    }
};
```
## 35.搜索插入位置

[力扣](https://leetcode-cn.com/problems/search-insert-position/)

二分，左闭右闭

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] > target) right = mid - 1;
            else if (nums[mid] < target) left = mid + 1;
            else return mid;
        }
        return left;
    }
};
```

## 69.x 的平方根

[力扣](https://leetcode-cn.com/problems/sqrtx/)

### F1 二分

O(logx)

```cpp
class Solution {
public:
    int mySqrt(int x) {
        // 0到x/2内遍历
        if (x <= 1) return x;
        int left = 1, right = x / 2;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            // 防溢出，没用mid * mid < x，因此下界也要改为1
            if (mid > x / mid) right = mid - 1;
            else if (mid < x / mid) left = mid + 1;
            else return mid;
        }
        return right;
    }
};
```



### F2 牛顿法(这个的时间复杂度，回来再看看)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125210.png)![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125211.png)

```cpp
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) return 0;
        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0);
            // 一直迭代到相邻两次迭代得到的交点非常接近时，就停止
            if (fabs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return int(x0);
    }
};
```
时间复杂度：O(log⁡x)，此方法是二次收敛的，相较于二分查找更快。
空间复杂度：O(1)

## 367.有效的完全平方数(E)
[力扣](https://leetcode-cn.com/problems/valid-perfect-square/)

```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int mid, left = 1, right = num;
        while(left <= right){
            mid = left + (right - left) / 2;
            // 注意m会越界
            long int m = (long int)mid * mid;
            if(m > num) right = mid-1;
            else if(m < num) left = mid+1;
            else return true;
        }
        return false;
    }
};
```

写法2

```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left=1, right=num;
        float mid;
        while(left <= right){
            mid = right + (left - right) / 2;
            // 这里用float的类型来判断，避免出现mid=2,5/2=2，导致2=5/2的情况
            float m = (float)num / mid;
            if(mid>m) right=(int)mid-1; 
            else if(mid<m) left=(int)mid+1;
            else return true;
        }
        return false;
    }
};
```
## 162. 寻找峰值

[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

**暴力**

如果下一个数大于本数，则更新最大值，若小于，则返回最大值作为峰值

时间复杂度：O(n)

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int tag = 0;
        if (nums.size() == 1) return 0;
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) {
                tag = i + 1;
            } else {
                return tag;
            }
        }
        return nums.size() - 1;
    }
};
```

**二分**

时间复杂度O(logn)

> 前提条件：
>
> * **对于任意数组而言，一定存在峰值（一定有解）**，可以通过边界是负无穷，从0到nums.size()进行推理
> * **二分不会错过峰值**。整理一下由「证明 11」得出的推理：**如果当前位置大于其左边界或者右边界，那么在当前位置的右边或左边必然存在峰值**。通过二分的具体操作可以发现，二分一定可以找到峰值
>
> 如果mid > mid + 1，则左边一定存在一个峰值；若 < ，则在右侧一定存在一个峰值

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] > nums[mid + 1]) right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```

## *287. 寻找重复数(~)*

[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

**不符合要求，对nums进行了修改**

> 剑指 Offer 03. 数组中重复的数字 是可以对数组进行修改，因此可以用swap
>
> 比 剑指 Offer 03. 数组中重复的数字 更简化的原因是nums中只有一个重复的整数，因此只在0位置交换就一定可以找到重复数字

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        // 将nums[i]放到i的位置
        while (true) {
            swap(nums[0], nums[nums[0]]);
            if (nums[nums[0]] == nums[0]) return nums[0];
        }
        return -1;
    }
};
```

**二分法**

> nums数组包含n + 1个整数，数字在[1, n]的范围内，即 **将n + 1个数字放到长度为n的数组里**。通过统计[left, right]（初始值为[1, n]）区间内nums中小于等于mid的数量，若没有重复，则在[mid + 1, right]中；若大于mid，说明重复数字在[left, mid]区间内
>
> * 为什么是while (left < right)而不是while (left <= right)？
>   因为若是等于的话，right == mid那里会跳不出来
> * if else的顺序？
>   只有 (count > mid) 即有重复的时候才收缩右边界；等于和小于的时候收缩左边界
> * 循环终止条件是left = right，最后返回谁都行

时间复杂度O(nlogn)

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int left = 1, right = nums.size() - 1;  // [1, n]
        while (left < right) {
            int mid = (right - left) / 2 + left;
            int count = 0;
            for (auto i : nums) {
                if (i <= mid) count++;
            }
            if (count > mid) right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```

***

## 154. 寻找旋转排序数组中的最小值 II

[剑指 Offer 11. 旋转数组的最小数字](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/) [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

普通方法

```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int result = numbers[0];
        for (int i = 1; i < numbers.size(); i++) {
            if (numbers[i] < numbers[i - 1]) {
                result = numbers[i];
                break;
            }
        }
        return result;
    }
};
```

二分

* numbers[pivot] > numbers[high]
  <img src="E:\MarkDown\picture\image-20230621095508609.png" alt="image-20230621095508609" style="zoom:60%;" />
* numbers[pivot] < numbers[high]
  <img src="E:\MarkDown\picture\image-20230621095544904.png" alt="image-20230621095544904" style="zoom:60%;" />
* numbers[pivot] == numbers[high]，不确定，因此仅缩小右边界
  <img src="E:\MarkDown\picture\image-20230621095627617.png" alt="image-20230621095627617" style="zoom:50%;" />

时间复杂度O(logn)，最坏情况下数组中的元素完全相同，那么 while 循环就需要执行 n 次，每次忽略区间的右端点，时间复杂度为 O(n)。

```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int low = 0, high = numbers.size() - 1;
        while (low < high) {
            int pivot = (high + low) / 2;
            if (numbers[pivot] > numbers[high]) low = pivot + 1;
            else if (numbers[pivot] < numbers[high]) high = pivot;
            else high--;
        }
        return numbers[low];
    }
};
```



## ==螺旋矩阵==

## *59.螺旋矩阵II(~)*
[力扣](https://leetcode-cn.com/problems/spiral-matrix-ii/)

思路：
可以发现，一共循环n/2圈，按左闭右开的话，第一圈遍历n-1个数，后续每圈遍历n-1 -2个数，然后每圈依次右下左上赋值就行。然后如果是奇数的话，中间会剩一个没遍历到的，需要最后单独赋值。另外每圈的起始位置会变。
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125438.png)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_19,color_FFFFFF,t_70,g_se,x_16-167542504125439.png)

**写法1**

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        // 如果是完整的quan个圈的话，中间是一定不会有剩下的元素的，此时count == n * n + 1
        // 若中间有剩下的，如这个例子，循环1圈，此时需要我们将中间那个少的补上。此时count == n * n
        vector<vector<int>> result(n, vector<int>(n, 0));
        int quan = n / 2;  // 循环多少圈
        int loop = n - 1;  // 每圈在每个方向移动多少次
        int i = 0, j = 0;
        int count = 1;  // 计数移动到的元素
        while (quan--) {
            int tmp = loop;
            while (tmp--) {
                result[i][j++] = count++;
            }
            tmp = loop;
            while (tmp--) {
                result[i++][j] = count++;
            }
            tmp = loop;
            while (tmp--) {
                result[i][j--] = count++;
            }
            tmp = loop;
            while (tmp--) {
                result[i--][j] = count++;
            }
            i += 1;
            j += 1;
            loop -= 2;
        }
        if (count == n * n) result[n / 2][n / 2] = count;
        return result;
    }
};
```
**随想录写法**

思路差不多，但这个写法麻烦点

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> map(n, vector<int>(n, 0));
        int loop = n / 2;
        int x = 0, y = 0;  // 定义每个循环的起始位置
        int count = 1, q = 0;  // q是圈循环后遍历的长度需要减2
        int i = 0, j = 0;
        while (loop--) {
            // 这一步赋初值很重要，之前的报错都是因为忘掉写了
            i = x;
            j = y;
            for (j = y; j < n - 1 - q + y; j++) {
                map[i][j] = count++;
            }
            for (i = x; i < n - 1 - q + x; i++) {
                map[i][j] = count++;
            }
            for (; j > y; j--){
                map[i][j] = count++;
            }
            for (; i > x; i--){
                map[i][j] = count++;
            }
            q += 2;
            x++; y++;  // 更新起始位置
        }
        // n % 2 == 1为奇数的话，需要单独给中间位置赋值
        if (n % 2) map[n / 2][n / 2] = count;
        return map;
    }
};
```

## *54.螺旋矩阵/剑指 Offer 29. 顺时针打印矩阵(~)*
[力扣](https://leetcode-cn.com/problems/spiral-matrix/)

### F1 自写
仿之前的思路写的，还需要额外考虑特殊情况

* m == n 时，可能会遗漏中间的情况
* 存在走不完一圈的情况，需要增加count < m * n的判定

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<int> map(m * n, 0);
        int quan = max(m, n) / 2;
        int loop1 = m - 1, loop2 = n - 1;
        int i = 0, j = 0;
        int count = 0;
        while (quan--) {
            int linshi = loop2;
            while (linshi-- && count < m * n) {
                map[count++] = matrix[i][j++];
            }
            linshi = loop1;
            while (linshi-- && count < m * n) {
                map[count++] = matrix[i++][j];
            }
            linshi = loop2;
            while (linshi-- && count < m * n) {
                map[count++] = matrix[i][j--];
            }
            linshi = loop1;
            while (linshi-- && count < m * n) {
                map[count++] = matrix[i--][j];
            }
            i++;j++;
            loop1 -= 2;
            loop2 -= 2;
        }
        if (m == n && m % 2) map[count] = matrix[m / 2][n / 2];
        return map;
    }
};
```

### F2 更简洁
这里的方法不需要记录已经走过的路径，所以执行用时和内存消耗都相对较小

* 首先设定上下左右边界
* 其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界
* 判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案
* 若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理
* 不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案

> 注意，这里的if(++ u > d) break;这种，都是下面马上要用到了，所以可以反推if判定的内容

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> ans;
        int u = 0; // 赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(true)
        {
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); // 向右移动直到最右
            if(++ u > d) break; // 重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); // 向下
            if(-- r < l) break; // 重新设定有边界
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); // 向左
            if(-- d < u) break; // 重新设定下边界
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); // 向上
            if(++ l > r) break; // 重新设定左边界
        }
        return ans;
    }
};
```
# 二、链表

```cpp
struct ListNode {
	int val;
	ListNode *next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

## 203、移除链表元素
[力扣](https://leetcode.cn/problems/remove-linked-list-elements/)

**虚拟头结点**

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* node = new ListNode(-1, head);
        ListNode* dummy = node;
        while (node->next != nullptr) {
            if (node->next->val == val) {
                ListNode* tmp = node->next;
                node->next = node->next->next;
                delete tmp;
            } else {
                node = node->next;
            }
        }
        head = dummy->next;
        delete dummy;
        return head;
    }
};
```
**递归**

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head == nullptr) return head;
        head->next = removeElements(head->next, val);
        if (head->val == val) {
            ListNode* node = head->next;
            delete head;
            return node;
        }
        else return head;
    }
};
```



## 707、设计链表(M)

[力扣](https://leetcode.cn/problems/design-linked-list/)

### F1

```cpp
class MyLinkedList {
public:
    struct LinkNode{
        int val;
        LinkNode* next;
        LinkNode(int val):val(val),next(nullptr){}
    };
    // 有虚拟头结点
    MyLinkedList() {
        node = new LinkNode(0);
        size = 0;
    }

    int get(int index) {
        if(index > (size-1) || index < 0) return -1;
        LinkNode* tmp = node;
        index++;  // 下标从0开始
        while(index--){
            tmp=tmp->next;
        }
        return tmp->val;
    }
    
    void addAtHead(int val) {
        LinkNode* tmp = new LinkNode(val);
        tmp->next = node->next;
        node->next = tmp;
        size++;
    }
    
    void addAtTail(int val) {
        LinkNode* tmp = new LinkNode(val);
        LinkNode* tmp1 = node;
        int linshi=size;
        while(linshi--){
            tmp1=tmp1->next;
        }
        tmp1->next = tmp;
        size++;
    }
    
    void addAtIndex(int index, int val) {
        if(index > size) return;
        LinkNode* tmp1 = new LinkNode(val);
        LinkNode* tmp = node;
        while(index--){
            tmp=tmp->next;
        }
        tmp1->next = tmp->next;
        tmp->next = tmp1;
        size++;  
    }
    
    void deleteAtIndex(int index) {
        if (index >= size || index < 0) return;
        LinkNode* tmp = node;
        while(index--){
            tmp = tmp->next;
        }
        LinkNode* tmp1 = tmp->next;
        tmp->next = tmp1->next;
        delete tmp1;
        size--;
    }
    // 再写个打印链表
    void print(){
        LinkNode* tmp = node;
        while(tmp->next!=nullptr){
            cout<<tmp->next->val<<" ";
            tmp=tmp->next;
        }
        cout<<endl;
    }
private:
    LinkNode* node;
    int size;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```
## 24. 两两交换链表中的节点(M)
[力扣](https://leetcode.cn/problems/swap-nodes-in-pairs/)

设置虚拟头结点

![在这里插入图片描述](E:\MarkDown\picture\image-20230306185542603.png)

在我们的代码中，从左到右分别为pre、cur、tmp

<img src="E:\MarkDown\picture\image-20230306185716351.png" alt="image-20230306185716351" style="zoom: 23%;" />

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(-1, head);
        ListNode* pre = dummy;
        ListNode* cur = pre->next;
        while(cur && cur->next) {
            ListNode* tmp = cur->next;
            pre->next = tmp;
            cur->next = tmp->next;
            tmp->next = cur;
            pre = cur;
            cur = cur->next;
        }
        return dummy->next;
    }
};
```
## 剑指 Offer 62. 圆圈中最后剩下的数字(~)

循环链表，解决[约瑟夫环问题](https://leetcode.cn/circle/article/BOoxAL/)。对应题目：[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

**普通方法**

模拟环形链表->删除

超时

```cpp
class Solution {
public:
    struct LinkNode{
        int val;
        LinkNode* next;
        LinkNode(int x) : val(x), next(nullptr){}
    };
    int lastRemaining(int n, int m) {
        if (m == 1) return n - 1;
        // 构建一个环形链表,起点为tmp
        LinkNode* node = new LinkNode(0);
        LinkNode* tmp = node;
        for (int i = 1; i < n; i++) {
            node->next = new LinkNode(i);
            node = node->next;
        }
        node->next = tmp;
        // 计数，每计到m - 2，就删除下个节点
        int count = 0;
        while (tmp->next != tmp) {  // 剩余节点不止一个时       
            if (count == m - 2) {
                tmp->next = tmp->next->next;
                count = 0;
            } else {
                count++;
            }
            tmp = tmp->next;
        }
        return tmp->val;
    }
};
```

利用**求余**的方法判断等价最低的枚举次数

还是超时

```cpp
class Solution {
public:
    struct LinkNode{
        int val;
        LinkNode* next;
        LinkNode(int x) : val(x), next(nullptr){}
    };
    int lastRemaining(int n, int m) {
        if (m == 1 && m % n == 1) return n - 1;
        // 构建一个环形链表，起点为tmp
        LinkNode* node = new LinkNode(0);
        LinkNode* tmp = node;
        for (int i = 1; i < n; i++) {
            node->next = new LinkNode(i);
            node = node->next;
        }
        node->next = tmp;
        // 计数，每计到m - 2，就删除下个节点
        int count = 0;
        // 对数字个数进行计数
        int size = n;
        while (tmp->next != tmp) {  // 剩余节点不止一个时       
            if (count == (m - 2) % size) {
                tmp->next = tmp->next->next;
                count = 0;
                size--;
            } else {
                count++;
            }
            tmp = tmp->next;
        }
        return tmp->val;
    }
};
```

使用list容器

还是超时

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        if (m == 1 && m % n == 1) return n - 1;
        list<int> tmp;
        for (int i = 0; i < n; i++) {
            tmp.push_back(i);
        }
        int size = n;
        int index = 0;
        while (size > 1) {
            index = (index + m - 1) % size;
            auto it = tmp.begin();
            int a = index;
            while (a--) {
                it++;
            }
            tmp.erase(it);
            size--;
        }
        return *tmp.begin();
    }
};
```

**迭代**

![image-20230413191109407](E:\MarkDown\picture\image-20230413191109407.png)

已知 f(8, 3) = 6, f(7, 3) = 3，那如何根据 f(7, 3) 反推 f(8, 3) ？

现在我们知道了G的索引号的变化过程，那么我们反推一下从N = 7 到N = 8 的过程

我们先把被杀掉的C补充回来，然后右移m个人，发现溢出了，再把溢出的补充在最前面

神奇了 经过这个操作就恢复了 N = 8 的排列了！

![image-20230307122825504](E:\MarkDown\picture\image-20230307122825504.png)

因此我们可以推出递推公式 f(8, 3) = [f(7,3) + 3] % 8
进行推广泛化，即 `f(n, m) = [f(n−1, m) + m] % n`

<img src="E:\MarkDown\picture\image-20230413191356427.png" alt="image-20230413191356427" style="zoom:50%;" />

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        int value = 0;
        for (int i = 2; i <= n; i++) {
            value = (value + m) % i;
        }
        return value;
    }
};
```



**递归**

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        if (n == 1) return 0;
        return (lastRemaining(n - 1, m) + m) % n;
    }
};
```

## 143. 重排链表

[143. 重排链表](https://leetcode.cn/problems/reorder-list/)

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode* node = head;
        stack<ListNode*> st;
        int count = 0;
        while (node) {
            st.push(node);
            node = node->next;
            count++;
        }
        count = count / 2 - 1;
        node = head;
        ListNode* next;
        while (count--) {
            ListNode* tmp = st.top(); st.pop();
            next = node->next;
            node->next = tmp;
            tmp->next = next;
            node = next;
        }
    }
};
```



```cpp
class Solution {
public:
    void reorderList(ListNode *head) {
        vector<ListNode*> vec;
        ListNode* node = head;
        while (node != nullptr) {
            vec.emplace_back(node);
            node = node->next;
        }
        int i = 0, j = vec.size() - 1;
        while (i < j) {
            vec[i]->next = vec[j];
            i++;
            if (i == j) break;
            vec[j]->next = vec[i];
            j--;
        }
        vec[i]->next = nullptr;
    }
};
```

## 82. 删除排序链表中的重复元素 II

[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

确保「进入外层循环时 head 不会与上一节点相同」，因此插入时机：

* head 已经没有下一个节点，head 可以被插入
* head 有一下个节点，但是值与 head 不相同，head 可以被插入

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* node = new ListNode(-1);
        ListNode* result = node;
        while (head) {
            if (head->next == nullptr || head->val != head->next->val) {
                node->next = head;
                node = head;
            }
            while (head->next && head->val == head->next->val) head = head->next;
            head = head->next;
        }
        node->next = nullptr;
        return result->next;
    }
};
```

## 138. 复制带随机指针的链表

[138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/) [剑指 Offer 35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

写法1

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        // 构建 原链表节点 和 新链表对应节点 的键值对映射关系
        // 第一次遍历
        Node* cur = head;
        Node* start = new Node(-1), *result = start;
        unordered_map<Node*, Node*> map;
        while (cur) {
            start->next = new Node(cur->val);
            map.insert({cur, start->next});
            start = start->next;
            cur = cur->next;
        }
        // 第二次遍历，填充random
        cur = head;
        start = result->next;
        while (cur) {
            start->random = map[cur->random];
            cur = cur->next;
            start = start->next;
        }
        return result->next;
    }
};
```

写法2

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == nullptr) return nullptr;
        Node* cur = head;
        unordered_map<Node*, Node*> map;
        // 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != nullptr) {
            map[cur] = new Node(cur->val);
            cur = cur->next;
        }
        cur = head;
        // 4. 构建新链表的 next 和 random 指向
        while(cur != nullptr) {
            map[cur]->next = map[cur->next];
            map[cur]->random = map[cur->random];
            cur = cur->next;
        }
        // 5. 返回新链表的头节点
        return map[head];
    }
};
```



# 三、哈希表

## 242、有效的字母异位词(E)

[力扣](https://leetcode.cn/problems/valid-anagram/)

数组实现更快，因为set、map把数值映射到key上都要做hash计算的

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size()) return false;
        // 定义在函数体内部的内置类型变量将不被初始化，因此要使用列表初始化为0
        int record[26]={};
        for(auto ch:s){
            record[(int)(ch-'a')]++;
        }
        for(auto ch:t){
            if (record[(int)(ch-'a')] > 0) record[(int)(ch-'a')]--;
            else return false;
        }
        return true;
    }
};
```

写法2

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        // 定义在函数体内部的内置类型变量将不被初始化，因此要使用列表初始化为0
        int record[26]={};
        for(auto ch:s){
            record[(int)(ch-'a')]++;
        }
        for(auto ch:t){
            record[(int)(ch-'a')]--;
        }
        for(int i = 0; i < 26; i++){
            if(record[i] != 0) return false;
        }
        return true;
    }
};
```
unordered_map

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size()) return false;
        unordered_map<char, int> map;
        for (auto i : s) {
            map[i]++;
        }
        for (auto i : t) {
            if (map[i] > 0) map[i]--;
            else return false;
        }
        return true;
    }
};
```



## 349. 两个数组的交集(E)

[力扣](https://leetcode.cn/problems/intersection-of-two-arrays/)

数组实现

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        int hash[1001] = {};
        for (auto i : nums1) {
            hash[i]++;
        }
        unordered_set<int> result;
        for (auto i : nums2) {
            if (hash[i] > 0) {
                result.insert(i);
            }
        }
        return vector<int>(result.begin(), result.end());
    }
};
```

unordered_set

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set(nums1.begin(), nums1.end());
        unordered_set<int> result;
        for (auto i : nums2) {
            if (set.find(i) != set.end()) {
                result.insert(i);
            }
        }
        return vector<int>(result.begin(), result.end());
    }
};
```
## *350. 两个数组的交集 II*

[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        int hash[1001] = {};
        vector<int> result;
        for (auto i : nums1) {
            hash[i]++;
        }
        for (auto i : nums2) {
            if (hash[i] > 0) {
                result.push_back(i);
                hash[i]--;
            }
        }
        return result;
    }
};
```

**扩展：**

> **如果有序，如何优化？**
>
> 使用双指针
>
> **如果 nums1 的大小比 nums2 小，哪种方法更优？**
>
> 
>
> **如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？**
>
> 如果只是nums2存在磁盘上，存nums2的空间小，那肯定用hash更好，hash存在其他地方，nums2只关系到查询操作，解释如下：
>
> 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且不能一次加载所有的元素到内存中。那么就无法高效地对 nums2 进行排序，因此推荐使用方法一而不是方法二。在方法一中，nums2 只关系到查询操作，因此每次读取 nums2 中的一部分数据，并进行处理即可。
>
> 如果是整体空间比较小，不足以将数组全部载入内存，那么必然也不能使用哈希这类费空间的算法，只能选用空间复杂度最小的算法，即先排序再用双指针。但是解法一中需要改造，一般说排序算法都是针对于内部排序，一旦涉及到跟磁盘打交道（外部排序），则需要特殊的考虑。**归并排序**是天然适合外部排序的算法，可以将分割后的子数组写到单个文件中，归并时将小文件合并为更大的文件。当两个数组均排序完成生成两个大文件后，即可使用双指针遍历两个文件，如此可以使空间复杂度最低

## 380. O(1) 时间插入、删除和获取随机元素

最近考察时间2022-12-29

[380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

通过vector实现随机返回

```cpp
class RandomizedSet {
public:
    // 通过vec记录val，实现相同概率返回
    vector<int> vec;
    // map记录val和其在vec中的下标
    unordered_map<int, int> map;
    int idx = -1;
    RandomizedSet() {

    }
    
    bool insert(int val) {
        if (map.count(val)) return false;
        vec.push_back(val);
        idx++;
        map[val] = idx;
        return true;
    }
    
    bool remove(int val) {
        if (!map.count(val)) return false;
        // 从集合和vec中移除val
        // map[val]是val这个值在vector中的下标，vec[map[val]] = vec[idx]是将vec中val对应的下标的值替换为idx处的值
        vec[map[val]] = vec[idx];
        // 将map中vec[idx]的值更新为map[val]，因为map[val]中存着以前的val对应在vector中的下标，而现在这个下标对应的值是idx的了
        map[vec[idx]] = map[val];
        vec.pop_back();
        idx--;
        map.erase(val);
        return true;
    }
    
    int getRandom() {
        int random = rand() % (idx + 1);
        return vec[random];
    }
};
```

## 202. 快乐数(E)

[力扣](https://leetcode.cn/problems/happy-number/)

unordered_set的作用仅是判断是否出现循环

```cpp
class Solution {
public:
    int get_sum(int n){
        int sum = 0;
        while(n) {
            sum += (n%10)*(n%10);
            n = n / 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> s;
        int sum = get_sum(n);
        while (s.find(sum) == s.end()) {
            s.insert(sum);
            sum = get_sum(sum);
            if (sum == 1) return true;
        }
        return false;
    }
};
```
## *1. 两数之和(~)*

[力扣](https://leetcode.cn/problems/two-sum/)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 回溯，组合问题，n * 2^n
        // 暴力 n^2
        // 差分、unordered_map n
        unordered_map<int, int> diff;
        for (int i = 0; i < nums.size(); i++) {
            diff[target - nums[i]] = i;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (diff.find(nums[i]) != diff.end() && i != diff[nums[i]]) return {i, diff[nums[i]]};
        }
        return {};
    }
};
```

优化

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); i++) {
            if (map.find(nums[i]) != map.end()) {
                return {i, map[nums[i]]};
            }
            map[target - nums[i]] = i;
        }
        return vector<int>();
    }
};
```
## *454. 四数相加 II(~)*
[454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

注意：用set是错误的，因为有的结果可能出现多次

* 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
* 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
* 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
* 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
* 最后返回统计值 count 就可以了

两组两组的进行分组，时间复杂度最低，为O(n^2)

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        int result = 0;
        unordered_map<int, int> map;
        for (int num1 : nums1) {
            for (int num2 : nums2) {
                map[num1 + num2]++;
            }
        }
        for (int num3 : nums3) {
            for (int num4 : nums4) {
                // 增加判定的话可以减小空间复杂度，否则会创建更多的map
                // if (map.find(-(num3+num4)) != map.end()) result += map[-(num3 + num4)];
                result += map[-(num3 + num4)];
            }
        }
        return result;
    }
};
```

## 383. 赎金信(E)
[力扣](https://leetcode.cn/problems/ransom-note/)

>  从magazine中找ransomNote

数组实现

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int hash[26] = {};
        for (auto i : magazine) {
            hash[i - 'a']++;
        }
        for (auto i : ransomNote) {
            hash[i - 'a']--;
            if (hash[i - 'a'] < 0) return false;
        }
        return true;
    }
};
```

vector实现

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        vector<int> v(26,0);
        for (auto i : magazine) v[i - 'a']++;
        for (auto i : ransomNote) {
            v[i - 'a']--;
            if (v[i - 'a'] < 0) return false;
        }
        return true;
    }
};
```
## 554. 砖墙(~)

[554. 砖墙](https://leetcode.cn/problems/brick-wall/)

vector超时

![image-20230424200244683](../picture/image-20230424200244683.png)

```cpp
class Solution {
public:
    int leastBricks(vector<vector<int>>& wall) {
        int size = 0;
        for (auto i : wall[0]) {
            size += i;
        }
        vector<int> result(size + 1, 0);
        int tmp = 0;
        for (auto vec : wall) {
            int sum = 0;
            for (auto i : vec) {
                sum += i;
                if (sum != size) result[sum]++;
                tmp = max(tmp, result[sum]);
            }
        }
        return wall.size() - tmp;
    }
};

```

unorderen_map就正常

```cpp
class Solution {
public:
    int leastBricks(vector<vector<int>>& wall) {
        int size = 0;
        for (auto i : wall[0]) {
            size += i;
        }
        unordered_map<int, int> mapp;
        int tmp = 0;
        for (auto vec : wall) {
            int sum = 0;
            for (auto i : vec) {
                sum += i;
                if (sum != size) mapp[sum]++;
                tmp = max(tmp, mapp[sum]);
            }
        }
        return wall.size() - tmp;
    }
};
```

写法2

```cpp
class Solution {
public:
    int leastBricks(vector<vector<int>>& wall) {
        // 将wall变为递增数组
        // 然后出现次数最多的就是
        unordered_map<int, int> mapp;
        int size;
        for (auto vec : wall) {
            int sum = 0;
            for (auto i : vec) {
                sum += i;
                i = sum;
                mapp[i]++;
            }
            size = sum;
        }
        int count = 0;
        for (auto i : mapp) {
            if (i.first != size) count = max(count, i.second);
        }
        return wall.size() - count;
    }
};
```





# 四、字符串

## string与char*

string转char*

```cpp
char* aaa () {
    string s;
    if (s.size() == 0) return "\0";
    char* a = (char*)malloc( (s.size() + 1) * sizeof(char) );
    // 注意一定要使用strcpy()函数来操作c_str()
    strcpy(a, s.c_str());  // c_str()函数返回一个以'\0'结尾的字符数组
    return a;
}
```

char*转string

```cpp
string aaa(char* a) {
    string str = a;
    return string;
}
```



## 541. 反转字符串 II

[力扣](https://leetcode.cn/problems/reverse-string-ii/)

reverse(str.begin(), str.end());

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        for (int i = 0; i < s.size(); i += (2 * k)) {
            // 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            if (i + k <= s.size()) {
                reverse(s.begin() + i, s.begin() + i + k);
                continue;
            }
            // 剩余字符少于 k 个，则将剩余字符全部反转。
            reverse(s.begin() + i, s.begin() + s.size());
        }
        return s;
    }
};
```
简化版

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        int size = s.size();
        for (int i = 0; i < size; i += 2 * k) {
            reverse(s.begin() + i, s.begin() + min(size, i + k));
        }
        return s;
    }
};
```

## 151. 反转字符串中的单词
[力扣](https://leetcode.cn/problems/reverse-words-in-a-string/)

通过istringstream分割单词

```cpp
class Solution {
public:
    string reverseWords(string s) {
        /*
        // 或者使用stringstream
        stringstream str;
        str << s;
        */
        istringstream aa(s);
        string tmp;
        stack<string> st;
        while (aa >> tmp) {
            st.push(tmp);
        }
        string result = "";
        while (!st.empty()) {
            result += st.top() + " "; st.pop();
        }
        result.pop_back();
        return result;
    }
};
```





逆序遍历，遇到空格就将栈中单词弹出，否则将单词入栈。每个字母都入栈出栈，时间复杂度O(2n)

```cpp
class Solution {
public:
    string reverseWords(string s) {
        stack<char> st;
        string result;
        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] == ' ') {
                if (st.empty()) continue;
                while (!st.empty()) {
                    result += st.top(); st.pop();
                }
                result += ' ';
            } else {
                st.push(s[i]);
            }
        }
        // 若st为空，则多了一个' '；否则需要把st中单词弹出
        if (st.empty()) {
            result.pop_back();
        } else {
            while (!st.empty()) {
                result += st.top(); st.pop();
            }
        }
        
        return result;
    }
};
```



**不使用辅助空间**

> 移除多余空格；将整个字符串反转；将每个单词反转
>
> 举个例子，源字符串为："the sky is blue "
>
> 移除多余空格 : "the sky is blue"
> 字符串反转："eulb si yks eht"
> 单词反转："blue is sky the"

```cpp
class Solution {
public:
    void reverse(string& s, int start, int end){
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }
	// 去除所有空格并在相邻单词之间添加空格
    void removeExtraSpaces(string& s) {
        int slow = 0;
        for (int i = 0; i < s.size(); i++) {
            // 遇到非空格就处理
            if (s[i] != ' ') {
                // slow != 0说明不是第一个单词，需要在单词前添加空格。
                if (slow != 0) s[slow++] = ' ';
                // 补上该单词，遇到空格说明单词结束
                while (i < s.size() && s[i] != ' ') {
                    s[slow++] = s[i++];
                }
            }
        }
        // slow的大小即为去除多余空格后的大小
        s.resize(slow);
    }

    string reverseWords(string s) {
        removeExtraSpaces(s);
        reverse(s, 0, s.size() - 1);
        int start = 0;
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') {
                reverse(s, start, i - 1);
                start = i + 1;
            }
        }
        return s;
    }
};
```

## 剑指 Offer 58 - II. 左旋转字符串(E)
[力扣](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

**F1 erase**

自写，将前n个字符添加到s后，再擦除前n个
```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        // 思路1
        for (int i = 0; i < n; i++) {
            s.push_back(s[i]);
        }
        s.erase(0, n);  // O(n)
        return s;
    }
};
```
**将s的长度扩大一倍，再截取从n开始的size段**
空间复杂度为O(n)

```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        s += s;
        // 这里s.size()扩大了两倍，因此是s.size()/2
        return s.substr(n, s.size() / 2);
    }
};
```
**reverse**

不申请空间，只在本串上操作，空间复杂度为O(1)
![在这里插入图片描述](E:\MarkDown\picture\3bbafd97f1fb41518e2c6ceb9464f8ad.png)

```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        // 不申请空间，只在本串上操作
        reverse(s.begin(), s.begin() + n);
        reverse(s.begin() + n, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```
## ==KMP==

## 28. 找出字符串中第一个匹配项的下标

又名 实现 strStr()

[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

**暴力方法**

时间复杂度O((m - n) * n)

```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (haystack.size() < needle.size()) return -1;
        for (int i = 0; i < haystack.size() - needle.size() + 1; i++) {
            if (haystack[i] != needle[0]) continue;
            int tag = i;
            for (int j = 0; j < needle.size(); j++) {
                if (haystack[tag] != needle[j]) break;
                tag++;
            }
            if (tag == i + needle.size()) return i;
        }
        return -1;
    }
};
```

###  KMP

  [KMP](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)主要应用在字符串匹配上。KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。通常会通过前缀表求相同前后缀的长度

时间复杂度为O(m+n)

next数组为前缀表统一减1
```cpp
class Solution {
public:
	  // 构造next数组
	  // 这里string&将string声明为引用可以避免对元素的拷贝
    // 常量引用主要用来修饰形参，防止误操作
    void getNext(int* next, const string& s) {
        // 这里使用了整体减一的next数组
        int j = -1;
        // 初始化Next数组
        next[0] = j;
        // 注意，因为是和j+1比，所以i从1开始
        for (int i = 1; i < s.size(); i++) {
            // 若前后缀不同，j向前回退
            while (j >= 0 && s[j+1] != s[i]) {
                j = next[j];
            }
            // 相同前后缀，则j自增
            if (s[i] == s[j+1]) j++;
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        // 创建一个前缀表，存储每个位置的最长公共前后缀
        // 通过前缀表不一样的位置处的前一个位置的值进行跳转
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        // 因为next数组里记录的起始位置为-1
        int j = -1;
        for(int i = 0; i < haystack.size(); i++) {
            while(j >= 0 && haystack[i] != needle[j+1]){
                j = next[j];
            }
            // 匹配，j和i同时向后移动
            if (haystack[i] == needle[j + 1]) {
                j++;  // i的增加在for循环里
            }
            // 文本串haystack里出现了模式串t
            if (j == (needle.size() - 1) ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

next数组为前缀表，更好理解

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

## 459.重复的子字符串

[力扣](https://leetcode.cn/problems/repeated-substring-pattern/)

###  F1 枚举
时间复杂度：O(n^2)
空间复杂度：O(1)
![在这里插入图片描述](E:\MarkDown\picture\91086083790a46dcab8220936eea2494.png)

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        int n = s.size();
        // 至少有一个字串重复，所以只需要在前半段枚举
        for (int i = 1; i * 2 <= n; i++) {
            // 如n=9时，只可能重复3。如果拿i=2比的话，最后会漏一个
            if (n % i == 0) {
                bool a = true;
                // 从下个字串开始和前面的比对
                for (int j = i; j < n; j++) {
                    if (s[j] != s[j - i]) {
                        a = false;
                        break;
                    }
                }
                if (a) return true;
            }
        }
        return false;
    }
};
```

### F2 移动匹配
时间复杂度：O(m+n)=O(3n)
![在这里插入图片描述](E:\MarkDown\picture\ea53e30241c84b4989f36989840d5ec4.png)

```cpp
// 力扣官方版
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        // find(s, 1)表示从位置1开始查找
        // find返回s第一次出现的位置，返回的是下标，这里!= s.size()，就相当于
        // 如果那个位置是s.size()，则意味着我们查找到的是第二个s
        // 让其不等于，就相当于不计入字符串的最后一个位置
        return (s + s).find(s, 1) != s.size();
    }
};

// 随想录掐头去尾版
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        // erase的时间复杂度为O(n)
        t.erase(t.begin());
        t.erase(t.end() - 1);
        // npos可以表示string的结束位子，是string::type_size 类型的，也就是find（）返回的类型
        // find函数在找不到指定值的情况下会返回string::npos。
        return t.find(s) != string::npos;
    }
};
```
![在这里插入图片描述](E:\MarkDown\picture\95898cb6de4b4a2587ea90b8bdbd12bb.png)

### F3 KMP

时间复杂度：O(n)，其中 n 是字符串s的长度。
空间复杂度：O(n))
```cpp
class Solution {
public:
    void getNext (int* next, const string& s){
        next[0] = -1;
        int j = -1;
        for(int i = 1;i < s.size(); i++){
            while(j >= 0 && s[i] != s[j + 1]) {
                j = next[j];
            }
            if(s[i] == s[j + 1]) {
                j++;
            }
            next[i] = j;
        }
    }
    bool repeatedSubstringPattern (string s) {
        if (s.size() == 0) {
            return false;
        }
        int next[s.size()];
        getNext(next, s);
        int len = s.size();
        // 最长相等前后缀不包含的这个子串就是最小重复子串
        // 如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。
        if (next[len - 1] != -1 && len % (len - (next[len - 1] + 1)) == 0) {
            return true;
        }
        return false;
    }
};
```
# 七、双指针

## ==字符串==

## 344. 反转字符串

[力扣](https://leetcode.cn/problems/reverse-string/)

**双指针**

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        // 从两边到中间，两两交换
        for (int i = 0, j = s.size() - 1; i <= j; i++, j--) {
            swap(s[i],s[j]);
        }
    }
};
```


```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0, right = s.size() - 1;
        while (left < right) {
            swap(s[left++], s[right--]);
        }
    }
};
```



## 剑指 Offer 05. 替换空格(E)

[力扣](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

**使用额外空间**

```cpp
class Solution {
public:
    string replaceSpace(string s) {
        string result;
        for (auto i : s) {
            // result.append("%20");
            if (i == ' ') result += "%20";
            // result.push_back(i);
            else result += i;
        }
        return result;
    }
};
```

**原地更改(双指针)**

resize + 双指针 + 逆序遍历，时间复杂度O(n)，空间复杂度O(1)

```cpp
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0;
        int a = s.size();
        for (auto i : s) {
            if (i == ' ') count++;
        }
        s.resize(a + count * 2);
        int i = a - 1, j = s.size() - 1;
        while (i >= 0) {
            if(s[i] == ' ') {
                s[j--] = '0';
                s[j--] = '2';
                s[j--] = '%';
                i--;
            }
            else{
                s[j--] = s[i--];
            }
        }
        return s;
    }
};
```

## 125. 验证回文串

[125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)

**双指针**

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        int i = 0, j = 0;
        while (j < s.size()) {
            if (s[j] >= 'a' && s[j] <= 'z') s[i++] = s[j++];
            else if (s[j] >= '0' && s[j] <= '9') s[i++] = s[j++];
            else if (s[j] >= 'A' && s[j] <= 'Z') s[i++] = s[j++] + 32;
            else j++;
        }
        // 此时i指向转换完的字符串末尾的下一个元素
        j = 0;
        i--;
        // 双指针
        while (j < i) {
            if (s[i--] != s[j++]) return false;
        }
        return true;
    }
};
```

**库函数**

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0, right = s.size() - 1;
        while (left < right) {
            // isalnum检查所传的字符是否是字母和数字
            while (left < right && !isalnum(s[left])) {
                left++;
            }
            while (left < right && !isalnum(s[right])) {
                right--;
            }
            if (left < right) {
                // tolower把给定的字母转换为小写字母
                if (tolower(s[left]) != tolower(s[right])) {
                    return false;
                }
                ++left;
                --right;
            }
        }
        return true;
    }
};
```



## ==链表==

## *206、反转链表(~)*

翻转链表

是 [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)、[BM3 链表中的节点每k个一组翻转](https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tqId=722&ru=%2Fpractice%2Fb58434e200a648c589ca2063f1faf58c&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) 的基础

[力扣](https://leetcode.cn/problems/reverse-linked-list/)
思路：
![在这里插入图片描述](E:\MarkDown\picture\37a1e811c7a5405c9835020ed0b66884.png)
![在这里插入图片描述](E:\MarkDown\picture\78de16f07b6f49b56cc1ae15c4d35f9a-16799052680331.gif)


### F1 双指针

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* next, *pre = nullptr, *cur = head;
        while (cur) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
```

### F2 递归

时间复杂度O(n)

```cpp
class Solution {
public:
    ListNode* aa(ListNode* pre, ListNode* cur) {
        if (cur == nullptr) return pre;
        ListNode* tmp = cur->next;
        cur->next = pre;
        // pre = cur; cur = tmp;
        return aa(cur, tmp);
        
    }
    ListNode* reverseList(ListNode* head) {
        return aa(nullptr, head);
    }
};
```

## *19.删除链表的倒数第 N 个结点(~)*

[力扣](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

### F1 普通方法

求长度，然后找删除结点位置，再删除

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* tmp = head;
        int count = 0;
        while (tmp) {
            count++;
            tmp = tmp->next;
        }
        ListNode* dummy = new ListNode(-1, head);
        ListNode* result = dummy;
        int size = count - n;
        while(size--) {
            dummy = dummy->next;
        }
        tmp = dummy->next;
        dummy->next = dummy->next->next;
        delete tmp;
        return result->next;
    }
};
```

### F2 快慢指针

设置快慢指针，快指针先移动n + 1次，然后两个指针一起移动，这样就可以刚好快指针指向Null，慢指针指向要删除的结点的前一个结点

> 删除的结点可能是头结点，因此要设虚拟头结点

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 快慢指针
        ListNode* dummy = new ListNode(-1, head);
        ListNode* slow = dummy, *fast = dummy;
        while(n--) {
            fast = fast->next;
        }
        fast = fast->next;
        while (fast) {
            slow = slow->next;
            fast = fast->next;
        }
        ListNode* tmp = slow->next;
        slow->next = slow->next->next;
        delete tmp;
        return dummy->next;
    }
};
```

## *160.相交链表/面试题 02.07. 链表相交(~)*

[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/) [160.相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)![在这里插入图片描述](E:\MarkDown\picture\dac45d967c764216a8b6fd2d6731dad0.png)

求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到和curB 末尾对齐的位置，此时就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

小技巧：可以通过swap保证长的链表是A


```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int sizeA = 0, sizeB = 0;
        ListNode *temp1 = headA, *temp2 = headB;
        while (temp1) {
            sizeA++;
            temp1 = temp1->next;
        }
        while (temp2) {
            sizeB++;
            temp2 = temp2->next;
        }
        temp1 = headA;
        temp2 = headB;
        if (sizeA < sizeB) {  // 保证长的是A
            swap(temp1, temp2);
            swap(sizeA, sizeB);
        }
        int tmp = sizeA - sizeB;
        while (tmp--) {
            temp1 = temp1->next;
        }
        
        while (temp1) {
            if (temp1 == temp2) return temp1;
            temp1 = temp1->next;
            temp2 = temp2->next;
        }
        return NULL;
    }
};
```

## *142. 环形链表 II(~)*

[力扣](https://leetcode.cn/problems/linked-list-cycle-ii/)

[思路](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#_142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii)

> 判断是否有环：
>
> 定义快慢节点，fast一次走两步，slow一次走一步，若有环，则fast与slow总会相遇，若无环，则在while处终止循环
>
> 判断环的入口（找环的起点：
> 找到fast和slow第一次相遇的位置后，令fast赋值为head，slow仍为第一次相遇的位置。两节点同时走，第一次相遇的地点就是入口。
>
> ![image-20230211110253491](E:\MarkDown\picture\image-20230211110253491.png)
>
> 上面这个思路不是很对
>
> 另一个思路：
>
> * 双指针第一次相遇：设head到入口结点有a步，环有b步，则第一次相遇时，f = 2*s ，且f = s + nb，即f比s多走了n圈。可以求得f = 2nb，s = nb
> * 若想走到入口结点，需要a + nb步，即走a步就能到，或者再走n个环。注意，第一次相遇时s已经走了nb步了，只需要再走a步我们就能得到入口结点位置
> * 因此将fast设在head处，这样f走a步的时候到了入口处，s走了a + nb步也到了入口处，即他们第二次相遇的位置就是入口结点



```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast -> next -> next;
            slow = slow -> next;
            if (fast == slow) {
                // 找到了第一次相遇的交点
                // 这里可以创建两个新指针分别指向head和交点，这里就直接用fast和slow了，但要注意他们的含义已经变了
                fast = head;
                while (fast != slow) {
                    fast = fast -> next;
                    slow = slow -> next;
                }
                return fast;
            }
        }
        return NULL;
    }
};
```

## ==数组==

## 27. 移除元素(E)

[力扣](https://leetcode-cn.com/problems/remove-element/)

**快慢指针法**

通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。
![在这里插入图片描述](E:\MarkDown\picture\43a9f43a1043a493a7e1ce36a707b6fe.gif)

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) nums[slowIndex++] = nums[fastIndex];
        }
        return slowIndex;
    }
};
```

时间复杂度：O(2n)，其中n为序列的长度。我们只需要遍历该序列至多两次。
空间复杂度：O(1)

**相向双指针法**

这是一种优化方法
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125215.png)这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。

***

思路：两个指针一个从最左边往右寻找等于val的，一个从最右边往左寻找不等于val的，然后用右边不等于val的赋值过去，再来往左挪动位置
这里可以是while(){}，也可以是while(){};，也可以是while() ...;    在这里分号和{}的意义都是起一个语句分隔的作用

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = nums.size() - 1;
        while (left <= right){  // 这里是否需要等于？需要。因为存在l=r的情况，需要对那一位进行判断
            while (left <= right && nums[left] != val) left++;
            while (left <= right && nums[right] == val) right--;
            // 需要有这个判断才能交换，比如上两部的while存在l==r的情况，这样就不该交换
            if (left < right) nums[left++] = nums[right--];
        }
        // left最后会移动到数组的后一位，刚好为数组大小
        return left;
    }
};
```

时间复杂度：O(n)，其中n为序列的长度。我们只需要遍历该序列至多一次。
空间复杂度：O(1)

## 26.删除排序数组中的重复项(E)

[力扣](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

快慢指针

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // 保持相对顺序一致，因此要使用快慢指针
        int slow = 0, fast = 1;
        while (fast < nums.size()) {
            while (fast < nums.size() && nums[slow] == nums[fast]) {
                fast++;
            }
            if(fast < nums.size()) swap(nums[++slow], nums[fast++]);
        }
        return slow + 1;
    }
};
```

从下标为1开始，和前面的一位比较，这样就能保证存入第一个数而不存第二个重复的数

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int j=1;
        for (int i = 1; i < nums.size(); i++) {  // i为fast
            if(nums[i-1]!=nums[i]){
                nums[j++]=nums[i];
            }
        }
        return j;
    }
};
```

## 283.移动零(E)

[力扣](https://leetcode-cn.com/problems/move-zeroes/)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125218.png)

### F1 自写双指针

思路：先去0，后补0
问题：人家要的是移动0，这写的是删0补0

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int j = 0;
        for (int i = 0; i < nums.size(); i++){
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }
        for (int i = j; i < nums.size(); i++) {
            nums[i] = 0;
        }
    }
};
```

### F2 官方双指针，移动0

![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125219.png)

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部
        int left = 0, right = 0;
        while (right < nums.size()) {
            if (nums[right]) {  // 初始时r=l=0。r寻找不为0的
                swap(nums[left], nums[right]);
                left++;  // left指向移动好的序列的末尾，给left换上非0后就移动left
            }
            right++;
        }
    }
};
```

## 844.比较含退格的字符串(E)

[力扣](https://leetcode-cn.com/problems/backspace-string-compare/)

### **双指针**

![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125321.png)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_19,color_FFFFFF,t_70,g_se,x_16.png)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125322.png)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125323.png)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125324.png)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125325.png)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125326.png)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125327.png)
![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125328.png)


```cpp
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        int i = S.length() - 1, j = T.length() - 1;
        int skipS = 0, skipT = 0;

        while (i >= 0 || j >= 0) {
            // S循环
            while (i >= 0) {
                if (S[i] == '#') {
                    skipS++, i--;
                } else if (skipS > 0) {
                    skipS--, i--;
                } else {
                    // skipS变为0时，跳出循环，进行比较
                    break;
                }
            }
            // T循环
            while (j >= 0) {
                if (T[j] == '#') {
                    skipT++, j--;
                } else if (skipT > 0) {
                    skipT--, j--;
                } else {
                    break;
                }
            }
            if (i >= 0 && j >= 0) {
                if (S[i] != T[j]) return false;
            } 
            else {
                if (i >= 0 || j >= 0) return false;
            }
            i--, j--;
        }
        return true;
    }
};
```

### 栈

![在这里插入图片描述](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125329.png)

这里将string当栈使用，直接用std::basic_string中构造好的函数
![在这里插入图片描述](E:\MarkDown\picture\afd2968e89c742f4b8307549bc7e7589.png)



```cpp
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        string ret1,ret2;
        for (char ch : S) {
            if (ch != '#') ret1.push_back(ch);
            else if (!ret1.empty()) ret1.pop_back();
        }
        for (char ch : T) {
            if (ch != '#') ret2.push_back(ch);
            else if (!ret2.empty()) ret2.pop_back();
        }
        return ret1 == ret2;
    }
};
```

![空间复杂度为： n+m](E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125330.png)

## 977.有序数组的平方(E)

[力扣](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

### F1 暴力法

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++) {
            nums[i] = nums[i] * nums[i];
        }
        sort(nums.begin(), nums.end());
        return nums;
    }
};
```

时间：O(n*logn) 
空间：O(logn)。除了存储答案的数组以外，我们需要 O(log⁡n)的栈空间进行排序。

### F2 双指针

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> result(nums.size());
        int start = 0, end = nums.size() - 1;
        int tag = end;
        while (start <= end) {
            if (abs(nums[start]) > abs(nums[end])) {
                result[tag--] = nums[start] * nums[start];
                start++;
            } else {
                result[tag--] = nums[end] * nums[end];
                end--;
            }
        }
        return result;
    }
};
```

时间：On
空间：O1：除了存储答案的数组以外，我们只需要维护常量空间

## *15. 三数之和(~)*

[力扣](https://leetcode.cn/problems/3sum/) [随想录](https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E5%93%88%E5%B8%8C%E8%A7%A3%E6%B3%95)

### 双指针（最优方法）

i用for循环遍历，left和right用双指针法

时间复杂度：O(n^2)。
![在这里插入图片描述](E:\MarkDown\picture\e01bac87f41bbf49786a0ef44a19157e.gif)

> 错误去重方法，将会漏掉-1,-1,2 这种情况
>
> ```cpp
> if (nums[i] == nums[i + 1]) continue;
> ```
>
> 正确去重方法，这样先检索完前面的-1有无三元组后，再检索第二个-1时，才应该发现是重复，然后跳过此次循环
>
> ```cpp
> if (i > 0 && nums[i] == nums[i - 1]) continue;
> ```
>
> 注意left和right去重的位置，要在找到一个三元组之后



```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) return result;
            // i 去重
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = nums.size() - 1;
            while (left < right) {
                // 去重逻辑如果放在开头，对于0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组，因此应该将去重逻辑放在找到一个三元组之后的位置
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) right--;
                else if (sum < 0) left++;
                else {
                    result.push_back({nums[i], nums[left], nums[right]});
                    // left right 去重
                    // 去重逻辑应该放在找到一个三元组之后
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                    /* // 或者将else逻辑写成这样
                    result.push_back({nums[i], nums[left++], nums[right--]});
                    while (left < right && nums[right] == nums[right + 1]) right--;
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    */
                }
            }
        }
        return result;
    }
};
```

> 时间上再次优化：在其他判断中对right和left再分别去重
>
> ![image-20230213161248706](E:\MarkDown\picture\image-20230213161248706.png)

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) return result;
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                    // 当前元素不合适了，可以去重，这里的去重即right右移了一位后还是相同的值
                    while (left < right && nums[right] == nums[right + 1]) right--;
                } 
                else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                    // 不合适，去重
                    while (left < right && nums[left] == nums[left - 1]) left++;
                } 
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};

```

### 哈希解法

两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。

把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。

去重的过程不好处理，有很多小细节，如果在面试中很难想到位。

时间复杂度可以做到$O(n^2)$，但还是比较费时的，因为不好做剪枝操作。

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[j], c = -(a + b)
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) break;  // 剪枝

            if (i > 0 && nums[i] == nums[i - 1]) continue; // i去重
            unordered_set<int> set;
            for (int j = i + 1; j < nums.size(); j++) {
                // 三元组元素b去重
                if (j > i + 2 && nums[j] == nums[j-1] && nums[j-1] == nums[j-2]) {
                    continue;
                }
                int c = 0 - (nums[i] + nums[j]);
                if (set.find(c) != set.end()) {
                    result.push_back({nums[i], nums[j], c});
                    set.erase(c);// 三元组元素c去重
                } else {
                    set.insert(nums[j]);
                }
            }
        }
        return result;
    }
};

```

## 18. 四数之和(M)

[力扣](https://leetcode.cn/problems/4sum/) [随想录](https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E8%A1%A5%E5%85%85)

### 双指针法

四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是$O(n^2)$，四数之和的时间复杂度是$O(n^3)$ 。

> 注意对越界情况的判断
>
> `if ((long int)nums[i] + nums[j] - target > -(nums[left] + nums[right]))`

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        for (int i = 0; i < nums.size(); i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < nums.size(); j++) {
                // 去重，避免-2,-2,-2,-1这种三连重复的情况
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                int left = j + 1, right = nums.size() - 1;
                while (left < right) {
                    // 注意越界情况
                    if ((long int)nums[i] + nums[j] - target > -(nums[left] + nums[right])) right--;
                    else if ((long int)nums[i] + nums[j] - target < -(nums[left] + nums[right])) left++;
                    else {
                        result.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        left++;
                        right--;
                    }
                }
            }
        }
        return result;
    }
};
```

## ==滑动窗口==

模板：

```cpp
for (遍历right) {
	// 处理逻辑
    while () {  // 有重复/超出某个限制
        // 收缩left
	}
    // 保存结果
}
```

## 剑指 Offer 57 - II. 和为s的连续正数序列

[剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

```cpp
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        // 滑动窗口
        vector<vector<int>> result;
        int left = 1, right = 1, sum = 0;
        for (; right <= target / 2 + 1; right++) {
            sum += right;
            while (sum > target) {
                sum -= left;
                left++;
            }
            if (sum == target) {
                vector<int> tmp;
                for (int i = left; i <= right; i++) tmp.push_back(i);
                result.push_back(tmp);
            }
        }
        return result;
    }
};
```



## 1004. 最大连续1的个数 III

[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

注意思路的转变

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        // 滑动窗口
        // 找出一个最长的子数组，该子数组内最多允许有 K 个 0
        int result = 0, left = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) k--;
            while (k < 0) {
                if (nums[left++] == 0) k++;
            }
            result = max(result, i - left + 1);
        }
        return result;
    }
};
```



## 3.无重复字符的最长子串(~)

[3.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

left为滑动窗口的左边界。每次将新元素放入set，若是有重复的，就收缩左边界，直到去掉那个重复的，此时再计算滑动窗口的长度

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> set;
        int result = 0;
        int left = 0;
        for (int i = 0; i < s.size(); i++) {
            while (set.find(s[i]) != set.end()) {  // 有重复
                set.erase(s[left]);
                left++;
            }
            result = max(result, i + 1 - left);
            set.insert(s[i]);
        }
        return result;
    }
};
```

## 209.长度最小的子数组(M)

[力扣](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
设计一个O(nlogn)的算法

### F1 暴力解法

通过两个循环来找。

```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX; // 最终的结果，可以直接写INT_MAX
        int sum = 0; // 子序列的数值之和
        int subLength = 0; // 子序列的长度
        for (int i = 0; i < nums.size(); i++) { // 设置子序列起点为i
            sum = 0;
            for (int j = i; j < nums.size(); j++) { // 设置子序列终止位置为j
                sum += nums[j];
                if (sum >= s) { // 一旦发现子序列和超过了s，更新result
                    subLength = j - i + 1; // 取子序列的长度
                    result = result < subLength ? result : subLength;
                    break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break
                }
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

时间复杂度 O(n^2)
空间复杂度 O(1)

### F2 滑动窗口

> j 用 for 循环遍历，i 通过 while 进行收缩

![在这里插入图片描述](E:\MarkDown\picture\1b0061b9d915c17c24c65c026d07f81a.gif)

```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int sum = 0, i = 0, length = INT_MAX;  // 滑动窗口数值之和
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                sum = sum - nums[i];
                length = (j - i + 1) > length ? length : (j - i + 1);
                i++;  // 不断变更i（子序列的起始位置）
            }
        }
        return length == INT_MAX ? 0 : length;
    }
};
```

时间复杂度：O(n)，虽每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是O(2n)
空间复杂度：O(1)

另一种不好的写法，相向指针的话边界判定就有点复杂了

```cpp
class Solution {
public:
    // 收缩法
    int minSubArrayLen(int target, vector<int>& nums) {
        int result = INT_MAX;
        int slow = 0, fast = 0;
        int sum = 0;
        while (slow < nums.size()) {
            while (sum < target && fast < nums.size()) {
                sum += nums[fast++];
            }
            if (sum >= target) result = min(result, fast - slow);
            sum -= nums[slow++];
        }
        return result == INT_MAX ? 0 : result;
    }
};
```



## 904、水果成篮(M)/双值数组

[力扣](https://leetcode-cn.com/problems/fruit-into-baskets/)

另一种题干：

![image-20230323172340672](E:\MarkDown\picture\image-20230323172340672.png)

**滑动窗口**

求最多包含k个不同字符的滑动窗口大小

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> map;
        int result = 0;
        int left = 0;
        for (int i = 0; i < fruits.size(); i++) {
            map[fruits[i]]++;
            while (map.size() > 2) {
                map[fruits[left]]--;
                if (map[fruits[left]] == 0) {
                    map.erase(fruits[left]);
                }
                left++;
            }
            result = max(result, i - left + 1);
        }
        return result;
    }
};
```

## *76、最小覆盖子串(~)*

[力扣](https://leetcode-cn.com/problems/minimum-window-substring/)

**暴力解法**

时间复杂度：O(n^2)，超时

```cpp
class Solution {
public:
    string aa(int start, string s, string t, unordered_map<char, int> map) {
        int tmp = INT_MAX;
        int count = 0;
        for (int i = start; i < s.size(); i++) {
            if (map[s[i]]) {
                tmp = min(tmp, i);  // 起始下标
                map[s[i]]--;
                count++;
            }
            if (count == t.size()) return string(s.begin() + tmp, s.begin() + i + 1);
        }
        return "";
    }
    string minWindow(string s, string t) {
        if (t.size() > s.size()) return "";
        string result;
        unordered_map<char, int> map;
        for (int i = 0; i < t.size(); i++) map[t[i]]++;
        int size = s.size();
        for (int i = 0; i < s.size() - t.size() + 1; i++) {
            string str = aa(i, s, t, map);
            if (str == "") continue;
            if (str.size() <= size && str!= "") {
                size = str.size();
                result = str;
            }
        }
        return result;
    }
};
```

**滑动窗口**

思路一：创建两个unordered_map，tmap记录t中有多少字母、每个字母有多少个，map则是我们遍历用的。若s中字母在t中，则用map进行计数，map和tmap相等时就开始收缩左边界

```cpp
class Solution {
public:
    bool aa(unordered_map<int, int>& map, unordered_map<int, int>& tmap) {
        for (auto i : tmap) {
            if (map[i.first] < i.second) {
                return false;
            }
        }
        return true;
    }
    string minWindow(string s, string t) {
        unordered_map<char, int> map;
        unordered_map<char, int> tmap;
        for (auto i : t) {
            tmap[i]++;
        }
        int left = 0, right = 0;
        int len = INT_MAX, start = 0;
        while (right < s.size()) {
            if (tmap.find(s[right]) != tmap.end()) {
                map[s[right]]++;
            }
            while (aa(map, tmap) && left <= right) {
                if (right - left + 1 < len) {
                    len = right - left + 1;
                    start = left;
                }
                if (tmap.find(s[left]) != tmap.end()) {
                    map[s[left]]--;
                }
                left++;
            }
            right++;
        }
        return len == INT_MAX ? "" : s.substr(start, len);
    }
};
```

思路二：用一个数组来保存

<img src="E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125336.png" alt="在这里插入图片描述" style="zoom:47%;" />




```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> need(128, 0);  // 128个ascii码
        int count = t.size();
        for (char c : t) need[c]++;  // 记录需要的每个字符的数量
        int left = 0, right = 0, start = 0, size = INT_MAX;
        while (right < s.size())
        {
            char c = s[right];
            if (need[c] > 0) count--;  // 如果c是t中的字符，count--
            need[c]--;
            if (count==0)
            {
                while (left < right && need[s[left]] < 0)  // need[s[l]] < 0，即l不在t中，则缩减窗口
                {
                    need[s[left]]++;
                    left++;
                }  
                // 更新答案
                if (right - left + 1 < size)
                {
                    size = right - left + 1;
                    start = left;  
                }
                // 左边界右移，准备下一个循环
                need[s[left]]++;   //右移之前需要释放map[s[l]]
                left++;
                count++;
            }
            right++;
        }
        return size == INT_MAX ? "" : s.substr(start, size);  // 返回由start开始的size个字符串
    }
};
```

## 438. 找到字符串中所有字母异位词

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)



```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;  // 保存结果
        vector<int> cnt(26, 0);  // 记录p中字符
        vector<int> window(26, 0);
        for (auto i : p) cnt[i - 'a']++;

        int count = 0;  // 统计p中不同的字符的数量
        for (int i = 0; i < 26; i++) if (cnt[i] != 0) count++;

        for (int left = 0, right = 0, counts = 0; right < s.size(); right++) {
            if (cnt[s[right] - 'a']) {
                window[s[right] - 'a']++;
                if (window[s[right] - 'a'] == cnt[s[right] - 'a']) counts++;
            }
            // 如果长度超了，收缩left。这里用if或while都可以，因为只需要收缩一次
            while (right - left + 1 > p.size()) {
                if (cnt[s[left] - 'a']) {
                    if (cnt[s[left] - 'a'] == window[s[left] - 'a']) counts--;
                    window[s[left] - 'a']--;
                }
                left++;
            }
            if (count == counts) result.push_back(left);
        }
        return result;
    }
};
```

优雅写法

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;  // 保存结果
        vector<int> cnt(26, 0);  // 记录p中字符
        for (auto i : p) cnt[i - 'a']++;

        int count = 0;  // 统计p中不同的字符的数量
        for (int i = 0; i < 26; i++) if (cnt[i] != 0) count++;

        for (int left = 0, right = 0, counts = 0; right < s.size(); right++) {
            if (--cnt[s[right] - 'a'] == 0) counts++;  // 必须先自减
            // 如果长度超了，收缩left
            if (right - left + 1 > p.size() && ++cnt[s[left++] - 'a'] == 1) counts--;
            if (count == counts) result.push_back(left);
        }
        return result;
    }
};
```



# 八、栈与队列
## *232. 用栈实现队列(~)*
[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/) [剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

两个栈实现，一个输入栈一个输出栈

> 此为进阶方法，每个操作均摊时间复杂度为 `O(1)` 。换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间
>
> 我们的「倒腾」不是发生在每一次的「输出操作」中，而是集中发生在一次「输出栈为空」的时候，因此 pop 和 peek 都是均摊复杂度为 O(1)O(1) 的操作。
>

```cpp
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;
    
    MyQueue() {

    }
    void push(int x) {
        stIn.push(x);
    }

    int pop() {
        // 只有当stOut为空的时候，再从stIn里导入数据
        if (stOut.empty()) {
            while(!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }

    int peek() {
        int res = this->pop();
        stOut.push(res);
        return res;
    }

    bool empty() {
        return stIn.empty() && stOut.empty();
    }
};
```
### 其他方法

但不是均摊O(1)

push时间复杂度O(n)，pop和peek时间复杂度O(1)

数据存在second中方便pop。push的时候就需要将数据传回去、psuh、再传回second

```cpp
class MyQueue {
public:
    stack<int> first;
    stack<int> second;

    MyQueue() {

    }
    // 每次push的时候
    void push(int x) {
        while (!second.empty()) {
            first.push(second.top());
            second.pop();
        }
        first.push(x);
        while (!first.empty()) {
            second.push(first.top());
            first.pop();
        }
    }
    
    int pop() {
        int tmp = second.top();
        second.pop();
        return tmp;
    }
    
    int peek() {
        return second.top();;
    }
    
    bool empty() {
        return second.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



## 225. 用队列实现栈(E)
[力扣](https://leetcode.cn/problems/implement-stack-using-queues/)

###  F1 双队列实现
pop时按顺序从一个队列中取出并放入另一个队列中，弹出最后一个，在复制到那个队列中
```cpp
class MyStack {
public:
    queue<int> que1;
    queue<int> que2; // 辅助队列，用来备份
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        que1.push(x);
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int size = que1.size();
        size--;
        while (size--) { // 将que1 导入que2，但要留下最后一个元素
            que2.push(que1.front());
            que1.pop();
        }

        int result = que1.front(); // 留下的最后一个元素就是要返回的值
        que1.pop();
        que1 = que2;            // 再将que2赋值给que1
        while (!que2.empty()) { // 清空que2
            que2.pop();
        }
        return result;
    }

    /** Get the top element. */
    int top() {
        return que1.back();
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return que1.empty();
    }
};
```
###  F2 单队列实现
一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了
```cpp
class MyStack {
public:
    queue<int> que;
    /** Initialize your data structure here. */
    MyStack() {

    }
    /** Push element x onto stack. */
    void push(int x) {
        que.push(x);
    }
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int size = que.size();
        size--;
        while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
        que.pop();
        return result;
    }

    /** Get the top element. */
    int top() {
        return que.back();
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return que.empty();
    }
};
```

## 剑指 Offer 31. 栈的压入、弹出序列

[剑指 Offer 31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

模拟一个栈。按pushed的顺序循环入栈，若栈顶==popped[cur]，就cur++并弹出

时间复杂度和空间复杂度都是O(N)

```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> st;
        int cur = 0;
        for (auto i : pushed) {
            st.push(i);
            while (!st.empty() && st.top() == popped[cur]) {
                st.pop();
                cur++;
            }
        }
        if (st.empty()) return true;
        return false;
    }
};
```



麻烦的思路，时间复杂度O(n^2)

```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        // 看序列的每个元素，比这个元素小的都必须逆序
        // 对于这个题，先要有pop和push的对应关系
        if (pushed.empty()) return true;
        unordered_map<int, int> map;
        int size = pushed.size();
        for (int i = 0; i < size; i++) {
            map[pushed[i]] = i;
        }
        vector<int> vec;
        for (auto i : popped) {
            vec.push_back(map[i]);
        }
        int old = vec[0];
        for (int j = 0; j < size; j++) {
            int pre = vec[j];
            if (pre < old) continue;
            else old = pre;

            int tmp = vec[j];
            for (int i = j + 1; i < size; i++) {    
                if (vec[i] < pre) {
                    if (vec[i] > tmp) return false;
                    else tmp = vec[i];
                }
            }
        }
        return true;
            

    }
};
```



## 71. 简化路径

[71. 简化路径](https://leetcode.cn/problems/simplify-path/)

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：

* 始终以斜杠 '/' 开头。
  两个目录名之间必须只有一个斜杠 '/' 。
  最后一个目录名（如果存在）不能 以 '/' 结尾。
  此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。

返回简化后得到的 规范路径 。

**istringstream**实现分割

```cpp
class Solution {
public:
    string simplifyPath(string path) {
        for (int i = 0; i < path.size(); i++) {
            if (path[i] == '/') path[i] = ' ';
        }
        istringstream aa(path);
        string s;
        deque<string> deq;
        while (aa >> s) {
            if (s == ".") continue;
            else if (s == "..") {
                if (!deq.empty()) deq.pop_back();
            } else {
                deq.push_back(s);
            }
        }
        string result;
        for (auto i : deq) {
            result = result + "/" + i;
        }
        if (result == "") result = "/";
        return result;
    }
};
```

普通写法

```cpp
class Solution {
public:
    string simplifyPath(string path) {
        deque<string> deq;
        for (int i = 0; i < path.size();) {
            if (path[i] == '/') i++;
            else {
                string tmp;
                while (i < path.size() && path[i] != '/') {
                    tmp += path[i++];
                }
                if (tmp == ".") continue;
                else if (tmp == "..") {
                    if (!deq.empty()) deq.pop_back();
                } else deq.push_back(tmp);
            }
        }
        string result;
        for (auto i : deq) {
            result += "/" + i;
        }
        if (result == "") result = "/";
        return result;
    }
};
```

## *20.有效的括号(~)*

[力扣](https://leetcode.cn/problems/valid-parentheses/)

注意，没有([)]这种情况，所以问题就变得简单起来了

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for (auto i : s) {
            if (i == '(') st.push(')');
            else if (i == '[') st.push(']');
            else if (i == '{') st.push('}');
            else if (!st.empty() && i == st.top()) st.pop();
            else return false;
        }
        return st.empty();
    }
};
```

## 1047. 删除字符串中的所有相邻重复项
[力扣](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

### **stack**

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> st;
        for (auto i : s) {
            if (!st.empty() && st.top() == i) st.pop();
            else st.push(i);
        }
        // 注意，这里必须要赋一个任意值
        string result(st.size(),' ');
        for (int i = st.size() - 1; i >= 0; i--) {
            result[i] = st.top(); st.pop();
        }
        return result;
    }
};
```
###  将字符串视为栈

string适用顺序容器vector的大部分操作

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string st;
        for (auto i : s) {
            if (st.empty() || st.back() != i) st.push_back(i);
            else st.pop_back();
        }
        return st;
    }
};
```
## 150. 逆波兰表达式求值
[力扣](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

也可不用unordered_set，直接`if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/")`

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        // 遇到运算符，就弹出两个数字进行计算，再放回栈中
        stack<int> st;
        unordered_set<string> set = {"+", "-", "*", "/"};
        for (auto i : tokens) {
            if (set.find(i) == set.end()) st.push(stoi(i));
            else {
                int b = st.top(); st.pop();
                int a = st.top(); st.pop();
                int sum;
                if (i == "+") sum = a + b;
                else if (i == "-") sum = a - b;
                else if (i == "*") sum = a * b;
                else sum = a / b;
                st.push(sum);
            }
        }
        return st.top();
    }
};
```

## *239.滑动窗口最大值(~)*
[力扣](https://leetcode.cn/problems/sliding-window-maximum/)

###  F1 单调队列/双端队列

> 维持一个deque，保证其队首元素为最大值
>
> 若要插入的元素大于队列末尾元素，则一直弹出，以此保证队列顶端的为最大值，再根据队列首元素的下标判断是否在区间内

![在这里插入图片描述](E:\MarkDown\picture\8afbd89995514cf6a217964abf051e0f.png)

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        // deque中存下标
        // 若要插入的元素大于队列末尾元素，则一直弹出，以此保证deque中队头到队尾单调递减
        // 存结果前判断队头的下标，弹出范围外的
        vector<int> result;
        deque<int> deq;
        for (int i = 0; i < k; i++) {
            while (!deq.empty() && nums[i] > nums[deq.back()]) deq.pop_back();
            deq.push_back(i);
        }
        result.push_back(nums[deq.front()]);
        for (int i = k; i < nums.size(); i++) {
            while (!deq.empty() && nums[i] > nums[deq.back()]) deq.pop_back();
            deq.push_back(i);
            while (deq.front() <= i - k) deq.pop_front();
            result.push_back(nums[deq.front()]);
        }
        return result;
    }
};
```
随想录版，空间复杂度比上个方法要高

时间复杂度：使用单调队列的时间复杂度是 O(n)。虽然在队列中 push元素的过程中，还有pop操作呢，感觉不是纯粹的O(n)。但单调队列的实现中，nums 中的每个元素最多也就被 push_back 和 pop_back 各一次，没有任何多余操作，所以整体的复杂度还是 O(n)。
空间复杂度：因为我们定义一个辅助队列，所以是O(k)。

```cpp
class Solution {
private:
    class MyQueue { //单调队列（从大到小）
    public:
        deque<int> que; // 使用deque来实现单调队列
        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。同时pop之前判断队列当前是否为空。
        // 这里就是滑动窗口移除最前面元素，如果那个元素刚好是nums[i-k]，则说明最大的是滑动窗口前面的那个，在这轮里就要pop
        void pop(int value) {
            if (!que.empty() && value == que.front()) {
                que.pop_front();
            }
        }
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。
        void push(int value) {
            while (!que.empty() && value > que.back()) {
                que.pop_back();
            }
            que.push_back(value);

        }
        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
        int front() {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
            que.push(nums[i]);
        }
        result.push_back(que.front()); // result 记录前k的元素的最大值
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]); // 滑动窗口移除最前面元素
            que.push(nums[i]); // 滑动窗口前加入最后面的元素
            result.push_back(que.front()); // 记录对应的最大值
        }
        return result;
    }
};
```
###  F2 优先队列
![在这里插入图片描述](E:\MarkDown\picture\5efe2c8ad6704f86ae2b4e72baa37e56.png)

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        priority_queue<pair<int, int>> que;
        for (int i = 0; i < k; i++) {
            que.emplace(nums[i], i);
        }
        result.push_back(que.top().first);
        for (int i = k; i < nums.size(); i++) {
            que.emplace(nums[i], i);
            while (que.top().second < i - k + 1) que.pop();
            result.push_back(que.top().first);
        }
        return result;
    }
};
```

## *347.前 K 个高频元素(~)*

[力扣](https://leetcode.cn/problems/top-k-frequent-elements/)

###  priority_queue
O(logm)*O(m)，最差为O(nlogn)，不大好
```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> v;  // 保存结果
        unordered_map<int, int> m;  // 减去重复
        priority_queue<pair<int, int>> q;  // 对value即个数排序
        // O(1)*O(n)
        for (int i = 0; i < nums.size(); i++) {
            m[nums[i]]++;
        }

        // 最简单的做法就是给出现次数数组排序，但时间复杂度：
        // O(logm)*O(m)，最差为O(nlogn)
        for (auto it = m.begin(); it != m.end(); it++) {
            q.emplace(it->second,it->first);
        }
        // O(k)
        for(int i = 0; i < k; i++) {
            v.push_back(q.top().second);
            q.pop();
        }
        return v;
    }
};
```
###  priority_queue
空间复杂度：O(Nlogk)+O(k)=O(Nlogk)
```cpp
class Solution {
public:
    // 注意这里>是小顶堆，从小到大，和快排算法那些是反着的
    class mycomparison {
    public:
        bool operator() (const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> m;  // 减去重复
        // O(1) * O(n)
        for (auto i : nums) {
            m[i]++;
        }
        // 小顶堆，队头是最小值
        // 因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素
        // priority_queue的长度为k，因此每次插入的时间复杂度为O(logk)，总为O(Nlogk)
        // priority_queue<Type, Container, Functional>
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> q;
        for (auto i : m) {
            // 堆的元素个数小于k，就直接插
            q.push(i);
            if (q.size() > k) { // 如果堆的大小大于了K，则弹出d，保证堆的大小一直为k
                q.pop();
            }
        }
        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = q.top().first;
            q.pop();
        }
        return result;
    }
};
```


# 九、二叉树

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## *94.144.145.二叉树的前中后序遍历*

[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

### F1 递归
#### 前
```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```
####  中
```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
```
####  后
```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

###  F2 迭代
#### 前
```cpp

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return result;
    }
};
```
#### 中
和 前 的实现不一样
要先遍历到最左边，再开始入栈
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```
#### 后
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 前序遍历为中左右，改下顺序就为中右左，逆序就为左右中的后序遍历
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end());
        return result;
    }
};
```

###  F3 统一迭代法
[不是很好理解](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E8%BF%AD%E4%BB%A3%E6%B3%95%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86)
#### 中
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
};
```
#### 前
```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```
#### 后
```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);

                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```

## 剑指 Offer 54. 二叉搜索树的第k大节点

[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```cpp
class Solution {
public:
    int kthLargest(TreeNode* root, int k) {
        // 反着的中序遍历的第k个
        stack<TreeNode*> st;
        TreeNode* node = root;
        while (node != nullptr || !st.empty()) {
            if (node != nullptr) {
                st.push(node);
                node = node->right;
            } else {
                node = st.top(); st.pop();
                k--;
                if (k == 0) return node->val;
                node = node->left;
            }
        }
        return -1;
    }
};
```



## 2331. 计算布尔二叉树的值

[2331. 计算布尔二叉树的值](https://leetcode.cn/problems/evaluate-boolean-binary-tree/)

![image-20230207154529820](E:\MarkDown\picture\image-20230207154529820.png)
![image-20230207154544786](E:\MarkDown\picture\image-20230207154544786.png)

简单的后序遍历

```cpp
class Solution {
public:
    bool evaluateTree(TreeNode* root) {
        // 后序遍历
        if (root->val == 0 || root->val == 1) return root->val;
        bool left = evaluateTree(root->left);
        bool right = evaluateTree(root->right);
        if (root->val == 2) return left||right;
        else return left && right;
    }
}
```

## 663 均匀树划分

> 力扣VIP题；华为手撕题
>
> 输入为二叉树数组形式

给定一棵有 n 个结点的二叉树，你的任务是检查是否可以通过去掉树上的一条边将树分成两棵，且这两棵树结点之和相等。

```
样例 1:
输入:     
    5
   / \
  10 10
    /  \
   2   3
输出: True
解释: 
    5
   / 
  10
      
和: 15

   10
  /  \
 2    3

和: 15


样例 2:
输入:     
    1
   / \
  2  10
    /  \
   2   20
输出: False
解释: 无法通过移除一条树边将这棵树划分成结点之和相等的两棵子树。
注释 :
树上结点的权值范围 [-100000, 100000]。
1 <= n <= 10000
```



```cpp
#include <bits/stdc++.h>
#include<iostream>
using namespace std;

struct TreeNode {
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 根据数组创建二叉树
TreeNode* aa(vector<int>& vec) {
	// 转换为数组
	vector<TreeNode*> vecNode(vec.size(), nullptr);
	TreeNode* root;
	for (int i = 0; i < vec.size(); i++) {
		TreeNode* node = nullptr;
		if (vec[i] != -1) node = new TreeNode(vec[i]);
		vecNode[i] = node;
		if (i == 0) root = node;
	}
	for (int i = 0; i * 2 + 1 < vec.size(); i++) {  // 遍历有子节点的
		if (vecNode[i] == nullptr) continue;
		vecNode[i]->left = vecNode[i * 2 + 1];
		if (i * 2 + 2 < vec.size()) vecNode[i]->right = vecNode[i * 2 + 2];
	}
	return root;
}

/*********************** 解题 ***********************/
// 前序遍历，求sum
int bb (TreeNode* node) {
	if (node == nullptr) return 0;
	int sum = node->val;
	sum += bb(node->left);
	sum += bb(node->right);
	return sum;
}

bool tag = false;
// 自底向上，后序遍历
int cc (TreeNode* node, int sum) {
	if (node == nullptr) return 0;
	int left = cc(node->left, sum);
	int right = cc(node->right, sum);
	if (left == sum || right == sum) tag = true;
	return left + right + node->val;
}

int main() {
	vector<int> vec1 = {5, 10, 10, -1, -1, 2, 3};
	vector<int> vec = {1, 2, 10, -1, -1, 2, 20};
	TreeNode* root = aa(vec);
	
	/*********************** 解题 ***********************/
	int sum = bb(root);
	
	// 找有没有和为sum/2的子树
	if (sum % 2 == 1) cout << false;
	else {
		cc(root, sum / 2);
		cout << tag;
	}
	
	return 0;
}
```

> 深度≤20说明了什么？





## *102.二叉树的层序遍历(~)*

[102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/) [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

迭代/BFS广度优先搜索

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        // 可以替换为if (root) que.push(root);
        if (root == nullptr) return result;
        vector<int> tmp;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                TreeNode* node = que.front();que.pop();
                tmp.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(tmp);
            tmp.clear();
        }
        return result;
    }
};
```

递归/DFS深度优先(比较难想到)

```cpp
class Solution {
public:
    void aa(TreeNode* node, vector<vector<int>>& result, int depth) {
        if (!node) return;
        // 注意，要先加上一个空vector，才能根据下标Push
        if (depth == result.size()) result.push_back(vector<int>());
        result[depth].push_back(node->val);
        aa(node->left, result, depth + 1);
        aa(node->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        aa(root, result, depth);
        return result;
    }
};
```

## 剑指 Offer 32 - III. 从上到下打印二叉树 III

[剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        // 层序遍历加个反向
        vector<vector<int>> result;
        queue<TreeNode*> que;
        if (root != nullptr) que.push(root);
        bool tag = true;
        while (!que.empty()) {
            int size = que.size();
            vector<int> tmp;
            if (!tag) tmp.assign(size, 0);
            while (size--) {
                TreeNode* node = que.front(); que.pop();
                if (tag) tmp.push_back(node->val);
                else tmp[size] = node->val;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(tmp);
            tag = !tag;
        }
        return result;
    }
};
```



## 107. 二叉树的层序遍历 II

[107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

自底向上的层序遍历，即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历

层序遍历后reverse

```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> result;
        if (root == nullptr) return result;
        vector<int> tmp;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                TreeNode* node = que.front();que.pop();
                tmp.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(tmp);
            tmp.clear();
        }
        reverse(result.begin(), result.end());
        return result;
    }
};
```

## 199. 二叉树的右视图

[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

层序遍历的时候，遍历到单层的最后面的元素时放入result中

写法一

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) return result;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            TreeNode* node;
            while (size--) {
                node = que.front();que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(node->val);
        }
        return result;
    }
};
```

写法二

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        // 层序遍历的时候，判断是否遍历到单层的最后面的元素
        // 如果是，就放进result数组中，随后返回result
        queue<TreeNode*> que;
        if (root != nullptr) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                // 重点
                if (i == (size - 1)) result.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};

```

## 637. 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

```cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<double> result;
        while (!que.empty()) {
            int size = que.size();
            double sum = 0; // 统计每一层的和
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front(); que.pop();
                sum += node->val;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(sum / size); // 将每一层均值放进结果集
        }
        return result;
    }
};
```

## 429. N 叉树的层序遍历

[429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> result;
        if (root == nullptr) return result;
        vector<int> tmp;
        queue<Node*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                Node* node = que.front();que.pop();
                tmp.push_back(node->val);
                for (auto i : node->children) {
                    que.push(i);
                }
            }
            result.push_back(tmp);
            tmp.clear();
        }
        return result;
    }
};
```

## 515. 在每个树行中找最大值

[515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```cpp
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) return result;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            int maxVal = INT_MIN;
            while (size--) {
                TreeNode* node = que.front();que.pop();
                maxVal = max(maxVal, node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(maxVal);
        }
        return result;
    }
};
```

## 116. 填充每个节点的下一个右侧节点指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

分开写

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        if (root == nullptr) return root;
        queue<Node*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size() - 1;
            Node* node = que.front();que.pop();
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
            while (size--) {
                Node* tmp = que.front();que.pop();
                node->next = tmp;
                node = tmp;
                if (tmp->left) que.push(tmp->left);
                if (tmp->right) que.push(tmp->right);
            }
            node->next = nullptr;
        }
        return root;
    }
};
```

合并写

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        if (root == nullptr) return root;
        queue<Node*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            Node* pre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    node = que.front();que.pop();
                    pre = node;
                } else {
                    node = que.front();que.pop();
                    pre->next = node;
                    pre = node;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            node->next = nullptr;
        }
        return root;
    }
};
```

## 117. 填充每个节点的下一个右侧节点指针 II

[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

与116没差别

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            Node* nodePre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    nodePre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = nodePre;
                } else {
                    node = que.front();
                    que.pop();
                    nodePre->next = node; // 本层前一个节点next指向本节点
                    nodePre = nodePre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodePre->next = NULL; // 本层最后一个节点指向NULL
        }
        return root;
    }
};

```

## *104.二叉树的最大深度(~)*

[104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

**递归/后序遍历**

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        return max(left, right) + 1;
    }
};
```

**迭代/层序遍历**

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> que;
        int result = 0;
        if (root != nullptr) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                TreeNode* node = que.front(); que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result++;
        }
        return result;
    }
};
```

## 559. N 叉树的最大深度

[559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

递归

```cpp
class Solution {
public:
    int maxDepth(Node* root) {
        if (root == nullptr) return 0;
        int result = 0;
        for (auto i : root->children) {
            int temp = maxDepth(i);
            result = max(temp, result);
        }
        return result + 1;
    }
};
```

迭代

```cpp
class Solution {
public:
    int maxDepth(Node* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<Node*> que;
        que.push(root);
        while (!que.empty()) {
            depth++;
            int size = que.size();
            for (int i = 0; i < size; i++) {
                Node* node = que.front();
                que.pop();
                for (int i = 0; i < node->children.size(); i++) {
                    if (node->children[i]) que.push(node->children[i]);
                }
            }
        }
        return depth;
    }
};

```

## 111. 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

**递归**

若root为叶子节点，返回1；若左子树或右子树为空，则返回另一个子树

if (root == nullptr) return 0;仅针对输入为null的情况

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        if (root->left == nullptr && root->right == nullptr) return 1;
        if (root->left == nullptr) return minDepth(root->right) + 1;
        if (root->right == nullptr) return minDepth(root->left) + 1;
        int a = minDepth(root->left);
        int b  = minDepth(root->right);
        return min(a, b) + 1;
    }
};
```

另一种写法

```cpp
class Solution {
public:
    int getDepth(TreeNode* node) {
        if (node == nullptr) return 0;
        // 注意，最小深度和最大深度是不同的
        // 左右节点都为空时才是最小深度
        int leftDepth = getDepth(node->left);       
        int rightDepth = getDepth(node->right);     
        // 当一个左子树为空，右不为空，这时并不是最低点
        if (node->left == NULL && node->right != NULL) { 
            return 1 + rightDepth;
        }   
        // 当一个右子树为空，左不为空，这时并不是最低点
        if (node->left != NULL && node->right == NULL) { 
            return 1 + leftDepth;
        }

        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }
    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
};
```

**迭代**

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        // 关键点是怎么确定是最小深度
        // 第一次出现左右节点都是null时
        queue<TreeNode*> que;
        if (root != nullptr) que.push(root);
        int depth = 0;
        while (!que.empty()) {
            int size = que.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
                if(!node->left && !node->right) return depth;
            }
        }
        return depth;
    }
};
```

## 226. 翻转二叉树

[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/) [剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)

**递归**

```cpp
class Solution {
public:
    // 前序遍历
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return root;
        swap(root->left, root->right);  // 中
        invertTree(root->left);  // 左
        invertTree(root->right);  // 右
        return root;
    }
};
```

**迭代**（深度优先遍历

```cpp
class Solution {
public:
    // 这里用stack或queue都没影响
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root != nullptr) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top(); st.pop();
            swap(node->left, node->right);
            if(node->left) st.push(node->left);
            if(node->right) st.push(node->right);
        }
        return root;
    }
};
```

**层序遍历**

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return root;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left, node->right);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

## *101.对称二叉树(~)*

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/) [剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)

递归，写法1

```cpp
class Solution {
public:
    bool aa(TreeNode* leftTree, TreeNode* rightTree) {
        if (!leftTree && !rightTree) return true;
        if ((leftTree && !rightTree) || (!leftTree && rightTree)) return false;
        if (leftTree->val != rightTree->val) return false;
        bool a = aa(leftTree->left, rightTree->right);
        bool b = aa(leftTree->right, rightTree->left);
        return a && b;
    }
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return true;
        return aa(root->left, root->right);
    }
};
```

写法2

```cpp
class Solution {
public:
    bool aa(TreeNode* leftTree, TreeNode* rightTree) {
        if (!leftTree && !rightTree) return true;
        else if (leftTree && rightTree) {
            if (leftTree->val != rightTree->val) return false;
            bool a = aa(leftTree->left, rightTree->right);
            bool b = aa(leftTree->right, rightTree->left);
            return a && b;
        } else return false;
    }
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return true;
        return aa(root->left, root->right);
    }
};
```

时间复杂度O(n)，需要遍历n个结点
空间复杂度O(n)，与递归深度即树的高度有关，最坏情况下变成一个链表，高度为n

**迭代**/层序遍历，队列实现

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

## 100. 相同的树

[100. 相同的树](https://leetcode.cn/problems/same-tree/)

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p && !q) return true;
        if (!p || !q) return false;
        if (p->val != q->val) return false;
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

## 572. 另一棵树的子树

[572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

递归

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p && !q) return true;
        if (!p || !q) return false;
        if (p->val != q->val) return false;
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        // 前序遍历
        if (root == nullptr) return false;
        if (root->val == subRoot->val) {
            bool result = isSameTree(root, subRoot);
            if (result) return true;
        }
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
};
```

迭代/层序遍历

```cpp
class Solution {
public:
    bool compare(TreeNode* p, TreeNode* q) {
        if (!p && !q) return true;
        else if (p && !q) return false;
        else if (!p && q) return false;
        else if(p->val != q->val) return false;

        bool a = compare(p->left, q->left);
        bool b = compare(p->right, q->right);
        return a&&b;
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        // 层序遍历，有相等的就用递归法判断
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            TreeNode* node = que.front();
            que.pop();
            if (node->val == subRoot->val) {
                bool a = compare(node, subRoot);
                if (a) return true;
            }
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
        }
        return false;
    }
};
```

## 222. 完全二叉树的节点个数

[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

**普通二叉树**：遍历一遍

```cpp
class Solution {
private:
    int getNodesNum(TreeNode* cur) {
        if (cur == NULL) return 0;
        // 先求左节点，再求右节点
        int leftNum = getNodesNum(cur->left);     
        int rightNum = getNodesNum(cur->right);   
        return leftNum + rightNum + 1;
    }
public:
    int countNodes(TreeNode* root) {
        return getNodesNum(root);
    }
};
```

**完全二叉树**

错误思路：
	求出深度和叶子节点个数再进行计算。但像 [1,2,3,4] 这种情况，可以发现不是仅在最后一层有叶子节点，倒数第二层也是有的

```cpp
class Solution {
public:
    int result = 0;
    int aa(TreeNode* root) {
        if (root == nullptr) return 0;
        if (root->left == nullptr && root->right == nullptr) result++;
        return max(aa(root->left), aa(root->right)) + 1;
    }
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        int n = aa(root) - 1;
        if (n == 0) return 1;  // 只有一个根节点的情况
        // 1 << n 相当于 2^n ，也可以用 pow(2, n)
        return (1 << n) - 1 + result;
    }
};
```

正确思路：

<img src="E:\MarkDown\picture\image-20230311115041353.png" alt="image-20230311115041353" style="zoom:50%;" />
	如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树)的节点数量。对于满二叉树，节点数量为 `2^树深度 - 1` 

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        // 若左右节点为空，则认为这个子树的深度为1
        int countLeft = 1, countRight = 1;
        while (left) {
            countLeft++;
            left = left->left;
        }
        while (right) {
            countRight++;
            right = right->right;
        }
        if (countRight == countLeft) return (1 << countLeft) - 1;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

时间复杂度：O(log n × log n)，因为对于完全二叉树，遍历一遍边是logn，最坏情况是 [1, 2, 3, 4]这种，左边的边遍历到最后才是完全二叉树，因此遍历了 log n × log n 次

## 110. 平衡二叉树

[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

**递归**

若子树是平衡二叉树，返回最大深度；若不是，返回-1

```cpp
class Solution {
public:
    int aa(TreeNode* root) {
        if (root == nullptr) return 0;
        int left = aa(root->left);
        int right = aa(root->right);
        if (left == -1 || right == -1) return -1;
        if (abs(left - right) > 1) return -1;
        return max(left, right) + 1;
    }
    bool isBalanced(TreeNode* root) {
        int result = aa(root);
        if (result == -1) return false;
        return true;
    }
};
```

## 257. 二叉树的所有路径

[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

```cpp
class Solution {
public:
    vector<string> result;
    void aa(TreeNode* node, string s) {
        if (node == nullptr) return;
        if (node->left == nullptr && node->right == nullptr) {
            result.push_back(s + to_string(node->val));
            return;
        }
        aa(node->left, s + to_string(node->val) + "->");
        aa(node->right, s + to_string(node->val) + "->");
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        string temp;
        aa(root, temp);
        return result;
    }
};
```

递归精简了一小下

```cpp
class Solution {
public:
    vector<string> result;
    void aa(TreeNode* node, string s) {
        if (node == nullptr) return;
        s += to_string(node->val);
        if (node->left == nullptr && node->right == nullptr) {
            result.push_back(s);
            return;
        }
        aa(node->left, s + "->");
        aa(node->right, s + "->");
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        string temp;
        aa(root, temp);
        return result;
    }
};
```

## 404. 左叶子之和

[404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

递归

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == nullptr) return 0;
        int leftval = 0, rightval = 0;
        if (root->left) {
            if (root->left->left == nullptr && root->left->right == nullptr) {
                leftval = root->left->val;
            } else {
                leftval = sumOfLeftLeaves(root->left);
            }
        }
        if (root->right) rightval = sumOfLeftLeaves(root->right);
        return leftval + rightval;
    }
};
```

精简版递归

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL) return 0;
        int leftValue = 0;
        if (root->left != NULL && root->left->left == NULL && root->left->right == NULL) {
            leftValue = root->left->val;
        }
        return leftValue + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
    }
};
```

## 513. 找树左下角的值

[513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

**层序遍历/迭代**

```cpp
class Solution {
public:
    // 层序遍历
    int findBottomLeftValue(TreeNode* root) {
        int result = 0;
        queue<TreeNode*> que;
        if (root) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            result = que.front()->val;
            while (size--) {
                TreeNode* node = que.front(); que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

**递归/回溯**

不断向下遍历，遇到更大深度的则更新值

```cpp
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) {
        if (root->left == NULL && root->right == NULL) {
            if (depth > maxDepth) {
                maxDepth = depth;
                result = root->val;
            }
            return;
        }
        if (root->left) {
            traversal(root->left, depth + 1);
        }
        if (root->right) {
            traversal(root->right, depth + 1);
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```

## 112. 路径总和

[112. 路径总和](https://leetcode.cn/problems/path-sum/)

```cpp
class Solution {
public:
    bool aa(TreeNode* root, int sum, int targetSum) {
        if (root == nullptr) return false;
        sum += root->val;
        // 遇到叶子节点，则进行判断
        if (!root->left && !root->right) {
            if (sum == targetSum) return true;
            else return false;
        }
        return aa(root->left, sum, targetSum) || aa(root->right, sum, targetSum);
    }
    bool hasPathSum(TreeNode* root, int targetSum) {
        return aa(root, 0, targetSum);
    }
};
```

精简版，完全可以不用sum

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return false;
        // 遇到叶子节点，则进行判断
        // 注意，这里targetSum还没减掉val
        if (!root->left && !root->right && targetSum - root->val == 0) {
            return true;
        }
        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);
    }
};
```

## 113. 路径总和 II

[113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

写法一，好理解一点

```cpp
class Solution {
public:
    vector<int> tmp;
    vector<vector<int>> result;
    void aa(TreeNode* node, int sum, int target) {
        if (!node->left && !node->right) {
            if (sum == target) result.push_back(tmp);
            return;
        }
        if (node->left) {
            tmp.push_back(node->left->val);
            aa(node->left, sum + node->left->val, target);
            tmp.pop_back();
        }
        if (node->right) {
            tmp.push_back(node->right->val);
            aa(node->right, sum + node->right->val, target);
            tmp.pop_back();
        }
        return;
    }
    vector<vector<int>> pathSum(TreeNode* root, int target) {
        // 回溯。走完每一种可能
        if (root == nullptr) return result;
        tmp.push_back(root->val);
        aa(root, root->val, target);
        return result;
    }
};
```



写法二

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> vec;
    void aa(TreeNode* root, int targetSum) {
        if (root == nullptr) return;
        vec.push_back(root->val);
        // 遇到叶子节点，则进行判断
        if (!root->left && !root->right && targetSum - root->val == 0) {
            result.push_back(vec);
            return;
        }
        if (root->left) {
            aa(root->left, targetSum - root->val);
            vec.pop_back();
        }
        if (root->right) {
            aa(root->right, targetSum - root->val);
            vec.pop_back();
        }
        return;
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        aa(root, targetSum);
        return result;
    }
};
```

另一种写法，略有差别

```cpp
class Solution {
public:
    void aa(TreeNode* node, int count, vector<vector<int>>& result, vector<int>& path) {
        path.push_back(node->val); // 把根节点放进路径
        if (!node->left && !node->right && count == 0) {
            result.push_back(path);
            return;
        }
        if (!node->left && !node->right && count == 0) return;

        if (node->left) {
            aa(node->left, count - node->left->val, result, path);
            path.pop_back();  
        }
        if (node->right) {
            aa(node->right, count - node->right->val, result, path);
            path.pop_back();  
        }
        return;
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        vector<vector<int>> result;
        vector<int> path;
        if (root == nullptr) return result;
        
        aa(root, targetSum - root->val, result, path);
        return result;
    }
};
```



## 106. 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        // TreeNode* root = nullptr;
        // if (inorder.size() == 0) return root;
        if (inorder.size() == 0) return nullptr;

        // 先找后序遍历的最后一个元素作为根节点
        int rtval = postorder[postorder.size() - 1];
        TreeNode* root = new TreeNode(rtval);

        // 以根节点分割inorder
        // 找rtval:可以用find，或者遍历找
        int tag;
        for (int i = 0; i < inorder.size(); i++) {
            if (inorder[i] == rtval) {
                tag = i;
            }
        }
        vector<int> leftio(inorder.begin(), inorder.begin() + tag);
        vector<int> rightio(inorder.begin() + tag + 1, inorder.end());
        vector<int> leftpo(postorder.begin(), postorder.begin() + leftio.size());
        vector<int> rightpo(postorder.begin() + leftio.size(), postorder.begin() + postorder.size() - 1);

        root->left = buildTree(leftio, leftpo);
        root->right = buildTree(rightio, rightpo);
        return root;
    }
};
```

## *105.从前序与中序遍历序列构造二叉树(~)*

[105.从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.size() == 0) return nullptr;
        int rtval = preorder[0];
        // 在中序中找根节点
        TreeNode* root = new TreeNode(rtval);
        int tag;
        for (tag = 0; tag < inorder.size(); tag++) {
            if (inorder[tag] == rtval) break;
        }
        // 分割中序
        vector<int> leftio(inorder.begin(), inorder.begin() + tag);
        vector<int> rightio(inorder.begin() + tag + 1, inorder.end());
        // 分割前序
        vector<int> leftpre(preorder.begin() + 1, preorder.begin() + 1 + leftio.size());
        vector<int> rightpre(preorder.begin() + 1 + leftio.size(), preorder.end());

        root->left = buildTree(leftpre, leftio);
        root->right = buildTree(rightpre, rightio);
        return root;
    }
};
```

## 654. 最大二叉树

[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

```cpp
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if (nums.size() == 0) return nullptr;
        // 在数组中找最大值
        int tag = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > nums[tag]) tag = i;
        }
        TreeNode* node = new TreeNode(nums[tag]);
        vector<int> leftVector(nums.begin(), nums.begin() + tag);
        vector<int> rightVector(nums.begin() + tag + 1, nums.end());
        node->left = constructMaximumBinaryTree(leftVector);
        node->right = constructMaximumBinaryTree(rightVector);
        return node;
    }
};
```

空间优化

```cpp
class Solution {
public:
    TreeNode* aa(vector<int>& nums, int start, int end) {
        if (start >= end) return nullptr;
         // 在数组中找最大值
        int tag = start;
        for (int i = start; i < end; i++) {
            if (nums[i] > nums[tag]) tag = i;
        }
        TreeNode* node = new TreeNode(nums[tag]);
        node->left = aa(nums, start, tag);
        node->right = aa(nums, tag + 1, end);
        return node;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return aa(nums, 0, nums.size());
    }
};
```

## 617. 合并二叉树

[617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (!root1 && !root2) return nullptr;
        else if (!root1 && root2) return root2;
        else if (root1 && !root2) return root1;
        // else {
        root1->val += root2->val;
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
};
```

## 700. 二叉搜索树中的搜索

[700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

递归

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == nullptr) return root;
        
        if (root->val == val) return root;
        else if (root->val > val) return searchBST(root->left, val);
        else return searchBST(root->right, val);
    }
};
```

**迭代**

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```

## *98.验证二叉搜索树(~)*

[98.验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

> 若是二叉搜索树，则中序遍历是个递增序列

```cpp
class Solution {
public:
    TreeNode* pre = NULL; // 用来记录前一个节点
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        bool left = isValidBST(root->left);
        if (pre != NULL && pre->val >= root->val) return false;
        pre = root;
        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

递归

注意，八字节用long long，别用long或long int，这俩在不同平台表示的字节数也不一样，容易出问题

```cpp
class Solution {
public:
    bool aa(TreeNode* node, long long low, long long high) {
        if (node == nullptr) return true;
        if (node->val <= low || node->val >= high) return false;
        return aa(node->left, low, node->val) && aa(node->right, node->val, high);
    }
    bool isValidBST(TreeNode* root) {
        return aa(root, LONG_MIN, LONG_MAX);
    }
};
```

## 530. 二叉搜索树的最小绝对差

[530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

递归——中序遍历

```cpp
class Solution {
public:
    int result = INT_MAX;
    TreeNode* pre = nullptr;
    int getMinimumDifference(TreeNode* root) {
        if (root == nullptr) return 0;
        getMinimumDifference(root->left);
        if (pre) result = min(result, root->val - pre->val);
        pre = root;
        getMinimumDifference(root->right);
        return result;
    }
};
```

## 501. 二叉搜索树中的众数

[501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

中序遍历

```cpp
class Solution {
public:
    vector<int> result;
    int count;
    int countMax = 1;
    TreeNode* pre = nullptr;
    void aa(TreeNode* root) {
        if (root == nullptr) return;
        // 左
        aa(root->left);
        // 中
        if (pre == nullptr) count = 1;
        else if (pre->val == root->val) count++;
        else count = 1;
        pre = root;
        if (count == countMax) result.push_back(root->val);
        if (count > countMax) {
            countMax = count;
            result.clear();
            result.push_back(root->val);
        }
        // 右
        aa(root->right);
    }
    vector<int> findMode(TreeNode* root) {
        aa(root);
        return result;
    }
};
```

**Morris 中序遍历**

```cpp
```

## *236.二叉树的最近公共祖先(~)*

[236.二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

递归/dfs

```cpp
class Solution {
public:
    // 后序遍历，遇到p或q则一路传上去
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == p || root == q || root == nullptr) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        if (left && right) return root;
        else if (!left && !right) return nullptr;
        else if (left) return left;
        else return right;
    }
};
```

## 235. 二叉搜索树的最近公共祖先

[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

如果中间节点是 q 和 p 的公共祖先，则中间节点的数值一定是在[p, q]区间内

**迭代法**

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while (root) {
            if (root->val > p->val && root->val > q->val) root = root->left;
            else if (root->val < p->val && root->val < q->val) root = root->right;
            else return root;
        }
        return nullptr;
    }
};
```

递归

```cpp
class Solution {
public:
    // 注意，pq一定存在，因此一定可以遍历到，不存在root==null的情况
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root->val > p->val && root->val > q->val) {
            return lowestCommonAncestor(root->left, p, q);
        } else if (root->val < p->val && root->val < q->val) {
            return lowestCommonAncestor(root->right, p, q);
        } else return root;
    }
};
```

## 701. 二叉搜索树中的插入操作

[701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == nullptr) {
            root = new TreeNode(val);
            return root;
        }
        if (root->val > val) root->left = insertIntoBST(root->left, val);
        else root->right = insertIntoBST(root->right, val);
        return root;
    }
};
```

## 450. 删除二叉搜索树中的节点(*)

[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

**递归**

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        TreeNode* node = root;
        // 前序遍历
        if (root == nullptr) return root;
        
        if (root->val == key) {
            // 情况一：叶子节点，删除就行
            // 情况二：只有左或右结点，移过去
            // 情况三：左右结点都有：直接把右节点挪上去，左节点放右节点的最下面
            if (!root->left && !root->right) return nullptr;
            else if (!root->left) return root->right;
            else if (!root->right) return root->left;
            else {
                TreeNode* temp = root->right;
                while (temp->left != nullptr) {
                    temp = temp->left;
                }
                temp->left = root->left;
                return root->right;
            }
        }
        // 二叉搜索树的搜索，有这个前置条件来优化
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```

**迭代**

需要记录删除结点的父节点，且需要确定删除结点是pre的左孩子还是右孩子

```cpp
class Solution {
private:
    // 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上
    // 并返回目标节点右孩子为新的根节点
    // 是动画里模拟的过程
    TreeNode* deleteOneNode(TreeNode* target) {
        if (target == nullptr) return target;
        if (target->right == nullptr) return target->left;
        TreeNode* cur = target->right;
        while (cur->left) {
            cur = cur->left;
        }
        cur->left = target->left;
        return target->right;
    }
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        TreeNode* cur = root;
        TreeNode* pre = nullptr; // 记录cur的父节点，用来删除cur
        while (cur) {
            if (cur->val == key) break;
            pre = cur;
            if (cur->val > key) cur = cur->left;
            else cur = cur->right;
        }
        if (pre == nullptr) { // 如果搜索树只有头结点
            return deleteOneNode(cur);
        }
        // pre 要知道是删左孩子还是右孩子
        if (pre->left && pre->left->val == key) {
            pre->left = deleteOneNode(cur);
        }
        if (pre->right && pre->right->val == key) {
            pre->right = deleteOneNode(cur);
        }
        return root;
    }
};
```

## 669. 修剪二叉搜索树(*)

[669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr) return root;
        if (root->val < low) return trimBST(root->right, low, high);
        if (root->val > high) return trimBST(root->left, low, high);
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```

## 108. 将有序数组转换为二叉搜索树

[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

```cpp
class Solution {
public:
    TreeNode* aa(vector<int>& nums, int left, int right) {
        // 如果偶数，取右
        if (left > right) return nullptr;
        int mid = left + (right - left) / 2;
        TreeNode* node = new TreeNode(nums[mid]);
        node->left = aa(nums, left, mid - 1);
        node->right = aa(nums, mid + 1, right);
        return node;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return aa(nums, 0, nums.size() - 1);
    }
};
```

## 538. 把二叉搜索树转换为累加树 / 1038. 从二叉搜索树到更大和树

[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) [1038. 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)

```cpp
class Solution {
public:
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        // 左中右的逆序遍历
        if (root == nullptr) return nullptr;
        convertBST(root->right);
        sum += root->val;
        root->val = sum;
        convertBST(root->left);
        return root;
    }
};
```

## 剑指 Offer 33. 二叉搜索树的后序遍历序列

[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

**递归分治**

<img src="E:\MarkDown\picture\image-20230621211645613.png" alt="image-20230621211645613" style="zoom:50%;" />

思路：后序遍历可以分为左子树和右子树和根节点三部分，递归保证左子树<根节点，右子树>根节点

```cpp
class Solution {
public:
    bool aa(vector<int>& postorder, int start, int end) {
        // 后序遍历可以分为左子树和右子树和根节点三部分，递归保证左子树<右子树>
        if (start >= end) return true;
        int pivot = postorder[end];
        int i = start;
        for (; i < end; i++) {
            if (postorder[i] > pivot) break;
        }
        int tag = i - 1;
        for (; i < end; i++) {
            if (postorder[i] < pivot) return false;
        }
        return aa(postorder, start, tag) && aa(postorder, tag + 1, end - 1);
    }
    bool verifyPostorder(vector<int>& postorder) {
        return aa(postorder, 0, postorder.size() - 1);
    }
};
```

简写

```cpp
class Solution {
public:
    bool aa(vector<int>& postorder, int start, int end) {
        // 后序遍历可以分为左子树和右子树和根节点三部分，递归保证左子树<右子树>
        if (start >= end) return true;
        int i = start;
        while (postorder[i] < postorder[end]) i++;
        int tag = i - 1;
        while (postorder[i] > postorder[end]) i++;
        return i == end && aa(postorder, start, tag) && aa(postorder, tag + 1, end - 1);
    }
    bool verifyPostorder(vector<int>& postorder) {
        return aa(postorder, 0, postorder.size() - 1);
    }
};
```

辅助单调栈解法，复杂度O(n)，没看

## 230. 二叉搜索树中第K小的元素

[230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

**迭代遍历**

时间复杂度：O(H + k)，其中 H 是树的高度。在开始遍历之前，我们需要 O(H) 到达叶结点。当树是平衡树时，时间复杂度取得最小值 O(logN + k)；当树是线性树（树中每个结点都只有一个子结点或没有子结点）时，时间复杂度取得最大值 O(N + k)

空间复杂度：O(H)，栈中最多需要存储 H 个元素。当树是平衡树时，空间复杂度取得最小值 O(logN)；当树是线性树时，空间复杂度取得最大值 O(N)。

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != nullptr || !st.empty()) {
            if (cur) {
                st.push(cur);
                cur = cur->left;
            } else {
                k--;
                cur = st.top(); st.pop();
                if (k == 0) return cur->val;
                cur = cur->right;
            }
        }
        return -1;
    }
};
```

> 如果你需要频繁地查找第 k 小的值，你将如何优化算法？
>
> 遍历后存到vector中



## *==297. 二叉树的序列化与反序列化(~)==*

[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

> 用' '将值隔开，遇到null填入x
>
> 由于存在123这种数字，不易将其截断再通过stoi转换为int，因此通过istringstream将字符去空格并取出来将多位数字组成的字符串完整取出

**层序遍历/bfs**

层序遍历和bfs还是有些区别的，层序遍历会统计每层的size，bfs只需要不断取出再放入队列。这里的序列化过程是用的层序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    // 层序遍历，遇到null就填入X
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string s;
        if (root == nullptr) return s;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                TreeNode* node = que.front(); que.pop();
                if (node == nullptr) s += 'x';
                else {
                    s += to_string(node->val);
                    que.push(node->left);
                    que.push(node->right);
                }
                s += ' ';
            }
        }
        return s;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        // 通过istringstream将以空格分割的字符串转换为一个个单独的字符串
        int size = data.size();
        if (size == 0) return nullptr;
        istringstream aa(data);
        string s;
        aa >> s;
        queue<TreeNode*> que;
        TreeNode* node = new TreeNode(stoi(s));
        que.push(node);
        string left, right;
        while (!que.empty()) {
            aa >> left >> right;
            TreeNode* tmp = que.front(); que.pop();
            if (left != "x") {
                tmp->left = new TreeNode(stoi(left));
                que.push(tmp->left);
            }
            if (right != "x") {
                tmp->right = new TreeNode(stoi(right));
                que.push(tmp->right);
            }
        }
        return node;
    }
};
```

char*版

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    // 层序遍历，遇到null就填入X
    // Encodes a tree to a single string.
    char* serialize(TreeNode* root) {
        string s;
        if (root == nullptr) return "\0";
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                TreeNode* node = que.front(); que.pop();
                if (node == nullptr) s += 'x';
                else {
                    s += to_string(node->val);
                    que.push(node->left);
                    que.push(node->right);
                }
                s += ' ';
            }
        }
        // 将string转为char*
		char* ch = (char*)malloc((s.size() + 1) * sizeof(char));
    	strcpy(ch,s.c_str());
    	return ch;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(char* data1) {
        // char*转string，只需要一个赋值
        string data = data1;
        int size = data.size();
        if (size == 0) return nullptr;
        // 通过istringstream将以空格分割的字符串转换为一个个单独的字符串
        istringstream aa(data);
        string s;
        aa >> s;
        queue<TreeNode*> que;
        TreeNode* node = new TreeNode(stoi(s));
        que.push(node);
        string left, right;
        while (!que.empty()) {
            aa >> left >> right;
            TreeNode* tmp = que.front(); que.pop();
            if (left != "x") {
                tmp->left = new TreeNode(stoi(left));
                que.push(tmp->left);
            }
            if (right != "x") {
                tmp->right = new TreeNode(stoi(right));
                que.push(tmp->right);
            }
        }
        return node;
    }
};
```

**dfs**

前序遍历

![image-20230227122500509](E:\MarkDown\picture\image-20230227122500509.png)

![image-20230227122544241](E:\MarkDown\picture\image-20230227122544241.png)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (!root) return "x";
        string left = serialize(root->left);
        string right = serialize(root->right);
        return to_string(root->val) + " " + left + " " + right;
    }

    // Decodes your encoded data to tree.
    TreeNode* dfs(istringstream& is) {
        string s;
        is >> s;
        if (s == "x") return nullptr;
        TreeNode *root = new TreeNode(stoi(s));
        root->left = dfs(is);
        root->right = dfs(is);
        return root;
    }
    TreeNode* deserialize(string data) {
        istringstream is(data);
        return dfs(is);
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```



# 十、回溯算法

## 时间复杂度分析

子集问题分析：

* 时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。
* 空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。

组合问题分析：

* 时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
* 空间复杂度：$O(n)$，和子集问题同理。

排列问题分析：

* 时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：`result.push_back(path)`），该操作的复杂度为$O(n)$。所以，最终时间复杂度为：n * n!，简化为$O(n!)$。
* 空间复杂度：$O(n)$，和子集问题同理。

## ==组合==

## 77. 组合

[77. 组合](https://leetcode.cn/problems/combinations/)

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> temp;
    void aa(int n, int k, int tag) {
        if (temp.size() == k) {
            result.push_back(temp);
            return;
        }
        for (int i = tag; i <= n; i++) {
            temp.push_back(i);
            // 注意是 i + 1
            aa(n, k, i + 1);
            temp.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        aa(n, k, 1);
        return result;
    }
};
```

**剪枝**

> 1. 已经选择的元素个数：path.size();
> 2. 还需要的元素个数为: k - path.size();
> 3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历
>
> 为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。
>
> 举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。
>
> 从2开始搜索都是合理的，可以是组合[2, 3, 4]。

```cpp
for (int i = tag; i <= n - (k - temp.size()) + 1; i++)
```

## 216. 组合总和 III

[216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> temp;
    void aa(int sum, int k, int n, int tag) {
        if (temp.size() == k) {
            if (sum == n) result.push_back(temp);
            return;
        }
        for (int i = tag; i <= 9 && sum <= n; i++) {
            temp.push_back(i);
            aa(sum + i, k, n, i + 1);
            temp.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        aa(0, k, n, 1);
        return result;
    }
};
```

**剪枝**

> * sum > n 时
> * 9 - (k - temp.size()) + 1

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> temp;
    void aa(int sum, int k, int n, int tag) {
        // 剪枝1
        if (sum > n) return;
        if (temp.size() == k) {
            if (sum == n) result.push_back(temp);
            return;
        }
        // 剪枝2
        for (int i = tag; i <= 9 - (k - temp.size()) + 1; i++) {
            temp.push_back(i);
            aa(sum + i, k, n, i + 1);
            temp.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        aa(0, k, n, 1);
        return result;
    }
};
```

## 17. 电话号码的字母组合

[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

```cpp
class Solution {
public:
    vector<string> mapping = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> result;
    void aa(string digits, string temp, int i) {
        if (temp.size() == digits.size()) {
            result.push_back(temp);
            return;
        }
        int tag = digits[i]- '0' - 2;
        for (int j = 0; j < mapping[tag].size(); j++){
            aa(digits, temp + mapping[tag][j], i + 1);
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits == "") return result;
        aa(digits, "", 0);
        return result;
    }
};
```

写法2

```cpp
class Solution {
public:
    string st[8] = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    string tmp;
    vector<string> result;
    void aa(string digits, int k) {
        if (k == digits.size()) {
            result.push_back(tmp);
            return;
        }
        string s = st[digits[k] - '2'];
        for (int i = 0; i < s.size(); i++) {
            //return;
            tmp.push_back(s[i]);
            aa(digits, k + 1);
            tmp.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits == "") return result;
        aa(digits, 0);
        return result;
    }
};
```



## *39.组合总和(~)*

[39.组合总和](https://leetcode.cn/problems/combination-sum/)

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> temp;
    void aa(vector<int>& candidates, int target, int tag) {
        if (target == 0) {
            result.push_back(temp);
            return;
        }
        if (target < 0) return;
        // 横着不能选到重复的
        for (int i = tag; i < candidates.size(); i++) {
            temp.push_back(candidates[i]);
            aa(candidates, target - candidates[i], i);
            temp.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        aa(candidates, target, 0);
        return result;
    }
};
```

剪枝

> 对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum > target的话就返回
> 因此通过增加一项判断：如果 sum + candidates[i] > target 就终止遍历 来进行剪枝
>
> 注意，剪枝的话必须先sort

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> temp;
    void aa(vector<int>& candidates, int target, int tag) {
        if (target == 0) {
            result.push_back(temp);
            return;
        }
        if (target < 0) return;
        // 剪枝
        for (int i = tag; i < candidates.size() && target - candidates[i] >= 0; i++) {
            temp.push_back(candidates[i]);
            aa(candidates, target - candidates[i], i);
            temp.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        // 剪枝必须增加sort排序
        sort(candidates.begin(), candidates.end());
        aa(candidates, target, 0);
        return result;
    }
};
```

## ==去重==

## 40. 组合总和 II

[40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

**通过增加一个判断来去重**

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> temp;
    void aa(vector<int>& candidates, int target, int tag) {
        if (target == 0) {
            result.push_back(temp);
            return;
        }
        for (int i = tag; i < candidates.size() && target - candidates[i] >= 0; i++) {
            // 树层(横向)去重
            if (i > tag && candidates[i] == candidates[i - 1]) continue;
            temp.push_back(candidates[i]);
            aa(candidates, target - candidates[i], i + 1);
            temp.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        aa(candidates, target, 0);
        return result;
    }
};
```

**通过used数组去重**

![image-20230321151101430](E:\MarkDown\picture\image-20230321151101430.png)

used[i - 1]为false，则表示是同一树层出现了重复；而若为true，则是树枝出现了重复。因为used也是在不断回溯的，只有在树枝上才能不断的增加true的个数，而在树层，为true的元素的个数是不会变的

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> temp;
    void aa(vector<int>& candidates, int target, int tag, vector<bool>& used) {
        if (target == 0) {
            result.push_back(temp);
            return;
        }
        for (int i = tag; i < candidates.size() && target - candidates[i] >= 0; i++) {
            // 树层(横向)去重
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) continue;
            temp.push_back(candidates[i]);
            used[i] = true;
            aa(candidates, target - candidates[i], i + 1, used);
            used[i] = false;
            temp.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        aa(candidates, target, 0, used);
        return result;
    }
};
```

通过unordered_set去重

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        unordered_set<int> uset; // 控制某一节点下的同一层元素不能重复
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            if (uset.find(candidates[i]) != uset.end()) {
                continue;
            }
            uset.insert(candidates[i]); // 记录元素
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i + 1);
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```



## ==分割==

## 131. 分割回文串

[131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/) [剑指 Offer II 086. 分割回文子字符串](https://leetcode.cn/problems/M99OJA/)

```cpp
class Solution {
public:
    bool palindrome(string s) {
        int left = 0, right = s.size() - 1;
        while (left <= right) {
            if (s[left] != s[right]) return false;
            left++; right--;
        }
        return true;
    }
    vector<vector<string>> result;
    vector<string> temp;
    void traceback(string s, int tag) {
        if (tag >= s.size()) {
            result.push_back(temp);
            return;
        }
        for (int i = tag; i < s.size(); i++) {
            string tmp = s.substr(tag, i - tag + 1);
            if (palindrome(tmp)) temp.push_back(tmp);
            else continue;
            traceback(s, i + 1);
            temp.pop_back();
        }
    }
    vector<vector<string>> partition(string s) {
        traceback(s, 0);
        return result;
    }
};
```

## 93. 复原 IP 地址

[93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

```cpp
class Solution {
public:
    vector<string> result;
    bool isIP(string tmp) {
        if (tmp.size() != 1 && tmp[0] == '0') return false;
        if (tmp.size() > 3) return false;
        if (stoi(tmp) > 255) return false;
        return true;
    }
    void traceback(string s, int tag, string temp, int count) {
        // 四个.
        if (count == 4) {
            if (tag >= s.size()) {
                temp.pop_back();
                result.push_back(temp);
            }
            return;
        }
        for (int i = tag; i < s.size(); i++) {
            string tmp = s.substr(tag, i - tag + 1);
            if (isIP(tmp)) traceback(s, i + 1, temp + tmp + '.', count + 1);
            else break;  // 不合法，结束本层的循环
        }
    }
    vector<string> restoreIpAddresses(string s) {
        if (s.size() < 4 || s.size() > 12) return result;
        traceback(s, 0, "", 0);
        return result;
    }
};
```

三个.，更快一点

```cpp
class Solution {
public:
    vector<string> result;
    bool isIP(string tmp) {
        if (tmp.size() > 3 || tmp.size() == 0) return false;
        if (tmp.size() != 1 && tmp[0] == '0') return false;
        if (stoi(tmp) > 255) return false;
        return true;
    }
    void traceback(string s, int tag, string temp, int count) {
        // 3个.
        if (count == 3) {
            string tmpstr = s.substr(tag, s.size() - tag);
            if (isIP(tmpstr)) {
                result.push_back(temp + tmpstr);
            }
            return;
        }
        for (int i = tag; i < s.size(); i++) {
            string tmp = s.substr(tag, i - tag + 1);
            if (isIP(tmp)) traceback(s, i + 1, temp + tmp + '.', count + 1);
            else break;  // 不合法，结束本层的循环
        }
    }
    vector<string> restoreIpAddresses(string s) {
        if (s.size() < 4 || s.size() > 12) return result;
        traceback(s, 0, "", 0);
        return result;
    }
};
```

## ==子集==

## *78.子集(~)*

[78.子集](https://leetcode.cn/problems/subsets/)

回溯

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> tmp;
    void aa(vector<int>& nums, int tag) {
        result.push_back(tmp);
        for (int i = tag; i < nums.size(); i++) {
            tmp.push_back(nums[i]);
            aa(nums, i + 1);
            tmp.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        aa(nums, 0);
        return result;
    }
};
```

> 注意：组合问题，用tag放到形参里，每次实参设为i+1，就可以避免出现重复的组合了。而used数组主要用于排列问题

## 90. 子集 II

[90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> tmp;
    void traceback(vector<int>& nums, int tag) {
        result.push_back(tmp);
        for (int i = tag; i < nums.size(); i++) {
            // 在树层去重
            if (i > tag && nums[i] == nums[i - 1]) continue;
            tmp.push_back(nums[i]);
            traceback(nums, i + 1);
            tmp.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        traceback(nums, 0);
        return result;
    }
};
```

used去重

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {
        result.push_back(path);
        for (int i = startIndex; i < nums.size(); i++) {
            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 而我们要对同一树层使用过的元素进行跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1, used);
            used[i] = false;
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0, used);
        return result;
    }
};
```

set去重，和used有区别

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path);
        unordered_set<int> uset; // 定义set对同一节点下的本层去重
        for (int i = startIndex; i < nums.size(); i++) {
            // 如果发现出现过就pass
            if (uset.find(nums[i]) != uset.end()) continue;
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        backtracking(nums, 0);
        return result;
    }
};
```



## 491. 递增子序列

[491. 递增子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

used数组去重

注意，这里的used是在每一层中都会新定义一个，因此不需要对used进行回溯，因为used就是用来保证一层中没有重复元素的

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> tmp;
    void traceback(vector<int>& nums, int tag) {
        if (tmp.size() > 1) result.push_back(tmp);
        int used[201] = {0};
        for (int i = tag; i < nums.size(); i++) {
            if (used[nums[i] + 100] == 1) continue;
            if (tmp.size() < 1 || nums[i] >= tmp.back()) tmp.push_back(nums[i]);
            else continue;
            used[nums[i] + 100] = 1;
            traceback(nums, i + 1);
            // used[nums[i] + 100] = 0;
            tmp.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        vector<int> used(nums.size(), false);
        traceback(nums, 0);
        return result;
    }
};
```

错误去重思路：

由于此题不能排序，因此之前的去重方法只能去除前后出现的重复数字

```cpp
class Solution {
public:

    vector<vector<int>> result;
    vector<int> tmp;
    void traceback(vector<int>& nums, int tag) {
        if (tmp.size() > 1) result.push_back(tmp);
        for (int i = tag; i < nums.size(); i++) {
            // 由于此题不能排序，因此这样去重只能去除前后出现的重复数字
            if (i > tag && nums[i] == nums[i - 1]) continue;
            if (tmp.size() < 1 || nums[i] >= tmp.back()) tmp.push_back(nums[i]);
            else if (nums[i] < tmp.back())
            else continue;
            traceback(nums, i + 1);
            tmp.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        traceback(nums, 0);
        return result;
    }
};
```

## ==排列==

## *46.全排列(~)*

[46.全排列](https://leetcode.cn/problems/permutations/)

回溯，排列问题，且无重复数字，easy

```cpp
class Solution {
public:
    // 树枝中不能有重复
    vector<int> tmp;
    vector<vector<int>> result;
    void aa (vector<int>& nums, vector<int>& used){
        if (tmp.size() == nums.size()) {
            result.push_back(tmp);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i] == 1) continue;
            tmp.push_back(nums[i]);
            used[i] = 1;
            aa(nums, used);
            used[i] = 0;
            tmp.pop_back();
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> used(nums.size(), 0);
        aa(nums, used);
        return result;
    }
};
```

## 47. 全排列 II

[47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

与46区别：增加了树层不能重复

used同时担任了两个作用：

* 与46中一样，保证不会重复选一个元素
* 树层去重

```cpp
class Solution {
public:
    // 
    vector<int> tmp;
    vector<vector<int>> result;
    void aa (vector<int>& nums, vector<int>& used){
        if (tmp.size() == nums.size()) {
            result.push_back(tmp);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            // 树层去重
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) continue;
            if (used[i] == 1) continue;  // 不能选自己
            tmp.push_back(nums[i]);
            used[i] = 1;
            aa(nums, used);
            used[i] = 0;
            tmp.pop_back();
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<int> used(nums.size(), 0);
        aa(nums, used);
        return result;
    }
};
```

## 剑指 Offer 38. 字符串的排列

[剑指 Offer 38. 字符串的排列](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)

```cpp
class Solution {
public:
    vector<string> result;
    void aa(string& s, vector<int>& used,string& tmp) {
        if (tmp.size() == s.size()) {
            result.push_back(tmp);
            return;
        }
        for (int i = 0; i < s.size(); i++) {
            if (used[i] == 1) continue;
            if (i > 0 && s[i] == s[i - 1] && used[i - 1] == 0) continue;
            used[i] = 1;
            tmp.push_back(s[i]);
            aa(s, used, tmp);
            tmp.pop_back();
            used[i] = 0;
        }
    }
    vector<string> permutation(string s) {
        // 回溯
        sort(s.begin(), s.end());
        vector<int> used(s.size(), 0);
        string tmp = "";
        aa(s, used, tmp);
        return result;
    }
};
```



## ==棋盘==

## 51. N 皇后

[51. N 皇后](https://leetcode.cn/problems/n-queens/)

```cpp
class Solution {
private:
vector<vector<string>> result;
// row 为当前递归到棋盘的第几行了
void backtracking(int n, int row, vector<string>& chessboard) {
    if (row == n) {
        result.push_back(chessboard);
        return;
    }
    // 对列进行遍历
    for (int col = 0; col < n; col++) {
        if (isValid(row, col, chessboard, n)) {
            chessboard[row][col] = 'Q';
            backtracking(n, row + 1, chessboard);
            chessboard[row][col] = '.';
        }
    }
}
bool isValid(int row, int col, vector<string>& chessboard, int n) {
    // 检查列
    for (int i = 0; i < row; i++) { // 这是一个剪枝
        if (chessboard[i][col] == 'Q') {
            return false;
        }
    }
    // 从当前点向上检查
    // 检查 45度角是否有皇后
    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    // 检查 135度角是否有皇后
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    return true;
}
public:
    vector<vector<string>> solveNQueens(int n) {
        result.clear();
        vector<string> chessboard(n, string(n, '.'));
        backtracking(n, 0, chessboard);
        return result;
    }
};
```

## 37. 解数独

[37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

```cpp
class Solution {
public:
    bool is(vector<vector<char>> board, int row, int col, char a) {
        for (int i = 0; i < 9; i++) {
            if (board[row][i] == a) return false;
        }
        for (int i = 0; i < 9; i++) {
            if (board[i][col] == a) return false;
        }
        for (int i = row/3 * 3; i < row/3 * 3 + 3; i++) {
            for (int j = col/3 * 3; j < col/3 * 3 + 3; j++) {
                if (board[i][j] == a) return false;
            }
        }
        return true;
    }
    bool aa(vector<vector<char>>& board) {
        for (int row = 0; row < 9; row++) {
            for (int col = 0; col < 9; col++) {
                if (board[row][col] == '.') {
                    for (char i = '1'; i <= '9'; i++) {
                        if (is(board, row, col, i)) {
                            board[row][col] = i;
                            if (aa(board)) return true;
                            board[row][col] = '.';
                        }
                    }
                    // 9个数都试完了，都不行，那么就返回false 
                    return false;
                }
            }
        }
        return true;
    }
    void solveSudoku(vector<vector<char>>& board) {
        aa(board);
    }
};
```

## ==其他==

## *332. 重新安排行程(~)*

[332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)

简化版

```cpp
class Solution {
public:
    unordered_map<string, map<string, int>> maps;
    vector<string> result;
    bool aa(int size) {
        if (result.size() == size + 1) return true;
        // 注意，这里必须使用引用，将改变传到maps中
        for (auto& i : maps[result[result.size() - 1]]) {
            if (i.second > 0) {
                result.push_back(i.first);
                i.second--;
                if (aa(size)) return true;
                result.pop_back();
                i.second++;
            }
        }
        return false;
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for (auto i : tickets) {
            maps[i[0]][i[1]]++;
        }
        result.push_back("JFK");
        aa(tickets.size());
        return result;
    }
};
```

详细注释版

```cpp
class Solution {
public:
    // <出发机场, map<到达机场, 航班次数>>
    // 对于一个出发机场，对应多个到达机场，到达机场存在map中，map对Key有序
    // “航班次数”作为一个标记，大于零说明目的地还可以飞；等于零说明目的地不能飞了
    unordered_map<string, map<string, int>> targets;
    vector<string> result;
    // 这里用bool，是因为对于递归函数，如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回（见题112
    bool aa(int size) {
        if (result.size() == size + 1) return true;
        // 使用范围for语句，读取target中 对应result的最后一位即出发地 对应的目的地
        // 注意这里的& ，使得target的int位的改变可以同步到targets中
        for (pair<const string, int>& target : targets[result[result.size() - 1]]) {
            if (target.second > 0 ) { // 记录到达机场是否飞过了
                result.push_back(target.first);
                target.second--;
                if (aa(size)) return true;
                result.pop_back();
                target.second++;
            }
        }
        return false;
    }
    // 是否有通路，有通路的话小的优先
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for (const vector<string>& vec : tickets) {
            targets[vec[0]][vec[1]]++; // 记录映射关系
        }
        result.push_back("JFK"); // 起始机场
        aa(tickets.size());
        return result;
    }
};
```



#### 

# 十一、贪心算法

## 455. 分发饼干

[455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

贪心：先满足胃口最小的孩子

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        int count = 0;
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        for (int i = 0, j = 0; i < s.size() && j < g.size(); i++) {
            if (s[i] >= g[j]) {
                j++;
                count++;
            }
        }
        return count;
    }
};
```

时间复杂度：

快排O(nlog n)，遍历O(n)，加一起就是还是O(nlogn)

## 376. 摆动序列

[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

### 贪心

<img src="E:\MarkDown\picture\image-20230322111340467.png" alt="image-20230322111340467" style="zoom:60%;" />

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff 
            }
        }
        return result;
    }
};
```

### 动态规划

## 53. 最大子数组和

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

### **贪心**

> 局部最优：当前"连续和"为负数的时候立刻放弃，从下一个元素重新计算"连续和"，因为负数加上下一个元素，"连续和"只会越来越小。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum = 0, result = INT_MIN;
        for (auto i : nums) {
            sum += i;
            result = max(result, sum);
            if (sum < 0) sum = 0;
        }
        return result;
    }
};
```

### 动态规划

## 121. 买卖股票的最佳时机

[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

### 贪心

写法一：与53类似，

> 假设[7 1 5 3 6 4]，则相邻元素差值为[-6 4 -2 3 -2]，只能买一次，则是求这个差值的最大子数组和
>
> > 注意，没有利润的话返回0，所以这里result初始化为0

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int sum = 0, result = 0;
        for (int i = 1; i < prices.size(); i++) {
            int temp = prices[i] - prices[i - 1];
            sum += temp;
            result = max(result, sum);
            if (sum < 0) sum = 0;
        }
        return result;
    }
};
```

写法2

因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            low = min(low, prices[i]);  // 取最左最小价格
            result = max(result, prices[i] - low); // 直接取最大区间利润
        }
        return result;
    }
};
```

时间复杂度：O(n)

空间复杂度：O(1)

### 动态规划

## 122. 买卖股票的最佳时机 II

[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

### **贪心**

局部最优：收集每天的正利润

> 假设[7 1 5 3 6 4]，则相邻元素差值为[-6 4 -2 3 -2]，最大利润就是4 + 3
>
> 即只要下个元素比当前元素大，就累加
>
> 情况1：[1 3 5]，则结果为2+2=4
>
> > 这里是可以买好几次股票。若是只能买一次股票，则是求完差后，再求最大子数组和

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 判断是否递增，递增的话累积差值
        int sum = 0;
        for (int i = 0; i < prices.size() - 1; i++) {
            if (prices[i] < prices[i + 1]) sum += prices[i + 1] - prices[i];
        }
        return sum;
    }
};

```

### 动态规划

## 714. 买卖股票的最佳时机含手续费

[714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

### 贪心(十分麻烦)

* 时间复杂度：O(n)
* 空间复杂度：O(1)

[随想录版](https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html)

* 买入日期：其实很好想，遇到更低点就记录一下。
* 卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。

所以我们在做收获利润操作的时候其实有三种情况：

* 情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。
* 情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。
* 情况三：不作操作，保持原有状态（买入，卖出，不买不卖）

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int result = 0;
        int minPrice = prices[0]; // 记录最低价格
        for (int i = 1; i < prices.size(); i++) {
            // 情况二：相当于买入
            if (prices[i] < minPrice) minPrice = prices[i];

            // 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出
            if (prices[i] > minPrice + fee) {
                result += prices[i] - minPrice - fee;
                // 如果还在收获利润的区间里，表示并不是真正的卖出，而计算利润每次都要减去手续费，所以要让minPrice = prices[i] - fee;，这样在明天收获利润的时候，才不会多减一次手续费！
                minPrice = prices[i] - fee;
            }
        }
        return result;
    }
};
```

官解

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        // buy表示最低买入价格
        int buy = prices[0] + fee;
        int profit = 0;
        for (int i = 1; i < n; ++i) {
            // 如果当前的股票价格 prices[i] 加上手续费 fee 小于 buy，那么与其使用 buy 的价格购买股票，不如以 prices[i]+fee 的价格购买股票，因此我们将 buy 更新为 prices[i]+fee
            if (prices[i] + fee < buy) {
                buy = prices[i] + fee;
            }
            // 如果当前的股票价格 prices[i] 大于 buy，那么我们直接卖出股票并且获得 prices[i]−buy 的收益
            else if (prices[i] > buy) {
                profit += prices[i] - buy;
                // 此时卖出股票可能并不是全局最优的（例如下一天股票价格继续上升），因此我们可以提供一个反悔操作，看成当前手上拥有一支买入价格为 prices[i]的股票，将 buy 更新为 prices[i]。这样一来，如果下一天股票价格继续上升，我们会获得 prices[i+1]−prices[i] 的收益，加上这一天 prices[i]−buy 的收益，恰好就等于在这一天不进行任何操作，而在下一天卖出股票的收益
                buy = prices[i];
            }
        }
        return profit;
    }
};
```

### 动态规划

## *55. 跳跃游戏(~)*

[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

局部最优解：每次取最大跳跃步数（取最大覆盖范围）
整体最优解：最后得到整体最大覆盖范围，看是否能到终点

```cpp
class Solution {
public:
    // 在能跳到的范围里找最大的
    bool canJump(vector<int>& nums) {
        int cover = 0;
        for (int i = 0; i <= cover; i++) {
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) return true;
        }
        return false;
    }
};
```

## 45. 跳跃游戏 II

[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

cover记录当前步的最大范围，next更新下一步能走的范围。当当前步走到头时，count++，并更新cover为next

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int cover = 0;  // 当前步的最大范围
        int count = 1;
        int next = 0;  // 下一步能走到的范围
        // 或写为
        // for (int i = 0; i < nums.size(); i++) {
        for (int i = 0; i <= cover; i++) {
            next = max(i + nums[i], next);
            if (i == cover) {
                cover = next;
                if (cover < nums.size() - 1) count++;
                else return count;
            }
        }
        return count;
    }
};
```

## 1005. K 次取反后最大化的数组和

[1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

写法一

```cpp
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        // 排序，有负数就先让负数变为正，没有的话
        sort(nums.begin(), nums.end());
        int minV = INT_MAX;
        for (auto& i : nums) {
            if (i < 0 && k > 0) {
                i = -i;
                k--;
            }
            // 正数里面找最小的
            if (i >= 0) minV = min(minV, i);
        }
        // 情况1：k用完了或者k是偶数，直接求和就行
        // 情况2：k是奇数，减去正数里最小的那个
        int result = 0;
        for (auto i : nums) {
            result += i;
        }
        if (k % 2 == 1)  result = result - 2 * minV;
        return result;
    }
};
```

写法二

```cpp
class Solution {
static bool cmp(int a, int b) {
    return abs(a) > abs(b);
}
public:
    // 贪心
    // 局部最优：让绝对值大的负数变为正数，当前数值达到最大；整体最优：整个数组和达到最大
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        // 按绝对值从大到小排序
        sort(nums.begin(), nums.end(), cmp);
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] < 0 && k > 0) {
                nums[i] = -nums[i];
                k--;
            }
        }
        if (k%2 == 1) nums[nums.size() - 1] *= -1;
        int sum = 0;
        for (int i : nums) sum += i;
        return sum;
    }
};
```

## 134. 加油站

[134. 加油站](https://leetcode.cn/problems/gas-station/)

i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。

**局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置**。

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int sum = 0;  // 记录总和，目的是保证gas > cost
        int curSum = 0;  // 保证局部最优
        int tag = 0;
        for (int i = 0; i < gas.size(); i++) {
            sum += gas[i] - cost[i];
            curSum += gas[i] - cost[i];
            // 如果[0, i]区间的和小于0了，则从i+1作为起点往后找
            if (curSum < 0) {
                tag = i + 1;
                curSum = 0;
            }
        }
        if (sum < 0) return -1;
        else return tag;
    }
};
```

## 135. 分发糖果

[135. 分发糖果](https://leetcode.cn/problems/candy/)

采用了两次贪心的策略：

* 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
* 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        // 假设每个人给一个
        // 如果下个人比这个高，则tag++，sum + tag；反之tag清零
        // 注意，对于相等的情况，如122，第二个2是可以只分配一个糖果的
        vector<int> result(ratings.size(), 1);
        // 对递增的情况：1 2 3
        for (int i = 0; i < ratings.size() - 1; i++) {
            if (ratings[i] < ratings[i + 1]) result[i + 1] = result[i] + 1;
        }
        // 对递减的情况：3 2 1
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i + 1] < ratings[i]) result[i] = max(result[i + 1] + 1, result[i]);
        }
        int sum = 0;
        for (auto i : result) sum += i;
        return sum;
    }
};
```

## 860. 柠檬水找零

[860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int count5 = 0, count10 = 0;
        for (auto i : bills) {
            if (i == 5) count5++;
            else if (i == 10) {
                if (count5 < 1) return false;
                count10++;
                count5--;
            } else {  // i == 20
                // 优先用10
                if (count10 >= 1 && count5 >= 1) {
                    count10--; count5--;
                } else if (count5 >= 3) {
                    count5 -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    }
};
```

## 406. 根据身高重建队列

[406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

<img src="E:\MarkDown\picture\image-20230323152326762.png" alt="image-20230323152326762" style="zoom:50%;" />

按照身高从大到小排序后：

**局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性**

**全局最优：最后都做完插入操作，整个队列满足题目队列属性**

```cpp
class Solution {
    // 将h维度从大到小排（身高相同的话则k小的站前面）
    static bool cmp(vector<int>& a, vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];  // 若身高相等，按k递增的顺序
        return a[0] > b[0];  // 按身高递减
    }
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);
        list<vector<int>> lst;
        for (auto i : people) {
            int position = i[1];
            list<vector<int>>::iterator it = lst.begin();
            // 注意，这里不能像vector一样直接begin() + position
            // 链表的迭代器是无序的，必须通过迭代来找下一个目标位置
            while (position--) {
                it++;
            }
            // insert的时间复杂度为O(n)
            lst.insert(it, i);
        }
        return vector<vector<int>>(lst.begin(), lst.end());
    }
};
```

* 时间复杂度：O(nlog n + n^2)
* 空间复杂度：O(n)

> 注意，如果使用vector，虽然表面上复杂度是O(n^ 2)，但是其底层都不知道额外做了多少次全量拷贝了，所以算上vector的底层拷贝，整体时间复杂度可以认为是O(n^2 + t × n)级别的，t是底层拷贝的次数。

## 452. 用最少数量的箭引爆气球

[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

> 注意，谓词函数务必加上引用，否则可能超时

<img src="E:\MarkDown\picture\image-20230323163319476.png" alt="image-20230323163319476" style="zoom:50%;" />

<img src="E:\MarkDown\picture\image-20230323163238944.png" alt="image-20230323163238944" style="zoom:10%;" />

写法一

```cpp
class Solution {
    static bool cmp(vector<int> a, vector<int> b) {
        return a[0] < b[0];
    }
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), cmp);
        int start = points[0][0], end = points[0][1];
        int count = 1;
        for (auto i : points) {
            if (i[0] > end) { 
                count++;
                start = i[0];
                end = i[1];
            } else {  // i[0] <= end
                start = i[0];
                end = min(end, i[1]);
            }
        }
        return count;
    }
};
```

写法二，更简洁

```cpp
class Solution {
    static bool cmp(vector<int>& a, vector<int>& b) {
        return a[0] < b[0];
    }
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), cmp);
        int count = 1;
        for (int i = 0; i < points.size() - 1; i++) {
            if (points[i][1] < points[i + 1][0]) {  // 没有重叠
                count++;
            } else {
                points[i + 1][1] = min(points[i + 1][1], points[i][1]);
            }
        }
        return count;
    }
};

```

## 435. 无重叠区间

[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

与上题类似但不同。上题是无重叠则箭数++，有重叠则改动范围

此题是有重叠则计数++，并收缩区间。为什么是取min呢？因为是移除区间，如[1 6] [2 3] [4 5]，前两个比较后收缩变为[2 3]，说明删的是尾巴长的那个，这样与[4 5]也不重叠，刚好是删除一个

```cpp
class Solution {
public:
static bool cmp(vector<int>& a, vector<int>& b) {
    if (a[0] == b[0]) return a[1] < b[1];
    return a[0] < b[0];
}
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        // 按照左边界从小到大排序。有重叠的话就删一个，我们不用在意删的是哪个，只需要把后面的那个的右边界更新下即可
        sort(intervals.begin(), intervals.end(), cmp);
        int result = 0;  // 记录重叠区间数
        for (int i = 0; i < intervals.size() - 1; i++) {
            // 有重叠
            if (intervals[i + 1][0] < intervals[i][1]) {
                result++;
                intervals[i + 1][1] = min(intervals[i + 1][1], intervals[i][1]);
            }
        }
        return result;
    }
};
```

## 763. 划分字母区间

[763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

<img src="E:\MarkDown\picture\8U5ZXI16A{6LADT8@VNQ$ZS.jpg" alt="img" style="zoom:13%;" />

写法1，count++记录数组长度

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> result;
        int aa[26] = {0};  // 记录每个字母结束的下标
        for (int i = 0; i < s.size(); i++) {
            aa[s[i] - 'a'] = i;
        }
        int curMax = INT_MIN;
        int count = 0;
        for (int i = 0; i < s.size(); i++) {
            curMax = max(curMax, aa[s[i] - 'a']);
            count++;
            if (i == curMax) {
                result.push_back(count);
                count = 0;
                curMax = INT_MIN;  // 0也行
            }
        }
        return result;
    }
};
```

写法2，用left记录起始位置，计算出数组长度

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> result;
        // 1.统计每一个字符最后出现的位置
        int m[27] = {0};
        for (int i = 0; i < s.size(); i++) {
            m[s[i] - 'a'] = i;
        }
        
        // 2.从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点
        int tag = 0;
        int left = 0;  // 用于直接计算出数组长度
        for (int i = 0; i < s.size(); i++) {
            tag = max(m[s[i] - 'a'], tag);
            if (tag == i) {
                result.push_back(i + 1 - left);
                left = i + 1;
            }
        }
        return result;
    }
};
```

## *56. 合并区间(~)*

[56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

不重叠，则保存上一组，并将起终点更新；重叠，则更新end。

注意，最后一组没有保存！

```cpp
class Solution {
    static bool cmp(vector<int>& a, vector<int>& b) {
        return a[0] < b[0];
    }
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> result;
        sort(intervals.begin(), intervals.end(), cmp);
        int start = intervals[0][0], end = intervals[0][1];
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] > end) {
                result.push_back({start, end});
                start = intervals[i][0];
                end = intervals[i][1];
            }
            else {
                end = max(end, intervals[i][1]);
            }
        }
        // 注意，最后一组没有保存
        result.push_back({start, end});
        return result;
    }
};
```

写法2，在原数组上修改

```cpp
class Solution {
public:
static bool cmp(vector<int>& a, vector<int>& b) {
    return a[0] < b[0];
}
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), cmp);
        vector<vector<int>> result;
        for (int i = 1; i < intervals.size(); i++) {
            // 如果重叠，更新i处的左和右边界，使其变为合并后的区间
            if (intervals[i - 1][1] >= intervals[i][0]) {
                intervals[i][0] = intervals[i - 1][0];
                intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]);
            } else {
                // 不重叠，就把前面的合并的那个放进去
                result.push_back({intervals[i - 1][0], intervals[i - 1][1]});
            }
        }
        // 最后一个需要单独处理
        // 放在此处，即包括[[1,3]]这种情况了
        result.push_back({intervals[intervals.size() - 1][0], intervals[intervals.size() - 1][1]});
        return result;
    }
};
```

## 738. 单调递增的数字(*)

[738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

> 遍历顺序：
>
> 数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。
>
> 那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -> 329 -> 299

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string strNum = to_string(n);
        // 必须通过flag标记下一步从哪里开始赋值9。若只是将strNum[i - 1]--，strNum[i] = 9的话，如100，就会变成90而不是99
        // 设置为strNum.size()，为了防止第二个for循环在flag没有被赋值的情况下执行
        int flag = strNum.size();
        for (int i = strNum.size() - 1; i > 0; i--) {
            if (strNum[i - 1] > strNum[i] ) {
                flag = i;
                strNum[i - 1]--;
            }
        }
        for (int i = flag; i < strNum.size(); i++) {
            strNum[i] = '9';
        }
        // stoi返回strNum的数值
        return stoi(strNum);
    }
};
```

* 时间复杂度：O(n)，n 为数字长度
* 空间复杂度：O(n)，需要一个字符串，转化为字符串操作更方便

## 968. 监控二叉树(*)

[968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

> 把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积，因此要从下往上看
>
> **局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！**

```cpp
class Solution {
public:
    int result = 0;
    // 后序遍历，自底向上
    int aa(TreeNode* node) {
        if (node == nullptr) return 2;  // 空结点视为被监控
        int left = aa(node->left);
        int right = aa(node->right);
        if (left == 0 || right == 0) {
            result++;  // 统计监控数量
            return 1;
        } else if (left == 2 && right == 2) {  // 都被监控了，则父节点是0
            return 0;
        }
        return 2;
    }
    int minCameraCover(TreeNode* root) {
        // 状态：0没被监控，1有摄像头，2被监控
        // 注意最后对根节点的判断
        // 如果根节点没被覆盖，则在根节点加一个摄像头
        if (aa(root) == 0) result++;
        return result;
    }
};
```

## 179. 最大数(~)

[179. 最大数](https://leetcode.cn/problems/largest-number/)

​	我们可以根据「结果」来决定 a 和 b 的排序关系：如果拼接结果 ab 要比 ba 好，那么我们会认为 a 应该放在 b 前面

```cpp
class Solution {
public:
    // 将nums放入string数组中，利用string的比较原则进行排序
    string largestNumber(vector<int>& nums) {
        vector<string> tmp;
        for (auto i : nums) {
            tmp.push_back(to_string(i));
        }
        auto cmp = [](string& a, string& b) {
            return a + b > b + a;
        };
        sort(tmp.begin(), tmp.end(), cmp);
        string result;
        for (auto i : tmp) {
            result += i;
        }
        // 注意数组中都是0的情况
        if (result[0] == '0') return "0";
        return result;
    }
};
```

时间复杂度：由于是对 String 进行排序，当排序对象不是 Java 中的基本数据类型时，不会使用快排（考虑排序稳定性问题）。Arrays.sort() 的底层实现会「元素数量/元素是否大致有序」决定是使用插入排序还是归并排序。这里直接假定使用的是「插入排序」。复杂度为 O(n^2)
空间复杂度：O(n)

**自写回溯**

> **报错：**
>
> ```
> terminate called after throwing an instance of 'std::length_error'  what():  basic_string::_M_create
> ```
>
> 原因：对于sort，对于所有的输入a，输入两个相同的元素，即cmp（a，a），返回的结果要是false，不能是true。
>
> **超时：**
>
> 对于数量比较多的示例，回溯必然超时
> <img src="E:\MarkDown\picture\image-20230428193650829.png" alt="image-20230428193650829" style="zoom:70%;" />

```cpp
class Solution {
public:
    string tmp;
    vector<string> result;
    void aa(int count, vector<int>& used, vector<int>& nums){
        if (count == used.size()) {
            result.push_back(tmp);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i] == 1) continue;
            tmp += to_string(nums[i]);
            used[i] = 1;
            aa(count + 1, used, nums);
            int len = to_string(nums[i]).size();
            while (len--) {
                tmp.pop_back();
            }
            used[i] = 0;
        }
    }
    static bool cmp (string a, string b) {
        for (int i = 0; i < a.size(); i++) {
            if (a[i] > b[i]) return true;
            else if (a[i] < b[i]) return false;
        }
        return false;
    }
    string largestNumber(vector<int>& nums) {
        // 找第一个数最大的；相同的话看第二个数.
        // 但这样有一个问题，就是比如[50, 503, 4]，显然50 4 503更大，而不是503 50 4，而[50, 503, 2]，则是503 50 2，即如果前面几位相同，则先选谁还要看别的元素
        // 因此只能回溯，且是排列问题。找到所有排列后再进行比较
        vector<int> used(nums.size(), 0);
        aa(0, used, nums);
        sort(result.begin(), result.end(), cmp);
        return result[0];
    }
};
```



# 十二、动态规划

[总结](https://kstar-1253855093.cos.ap-nanjing.myqcloud.com/baguwenpdf/_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE_%E9%9D%92.png)

如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## ==基础题目==

## 509、斐波那契数(E)
[力扣](https://leetcode-cn.com/problems/fibonacci-number/)

### F1 暴力递归

```cpp
class Solution {
public:
    int fib(int n) {
        if(n<2) return n;
        return fib(n-1)+fib(n-2);
    }
};
```

时间复杂度O(2^n)，空间复杂度O(n)
问题：重叠子问题，有重复计算，时间复杂度高

<img src="E:\MarkDown\picture\image-20230203193952973.png" alt="image-20230203193952973" style="zoom:57%;" />

<img src="E:\MarkDown\picture\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16-167542504125540.png" alt="在这里插入图片描述" style="zoom:50%;" />



### F2 动态规划
```cpp
class Solution {
public:
    int fib(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1);
        dp[0] = 0;
        dp[1] = 1;
        // 注意是小于等于n
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```
时间复杂度和空间复杂度都为O(N)

### F3 精简

```cpp
class Solution {
public:
    int fib(int n) {
        if (n <= 1) return n;
        int tmp, pre = 0, cur = 1;
        for (int i = 2; i <= n; i++) {
            tmp = pre + cur;
            pre = cur;
            cur = tmp;
        }
        return cur;
    }
};
```
```cpp
// 代码随想录版本，用的数组
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        int dp[2];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};

```
时间复杂度O(n)，空间复杂度O(1)


## *70、爬楼梯(~)*
[力扣](https://leetcode-cn.com/problems/climbing-stairs/)

### F1、动态规划

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n<=2) return n;
        vector<int> dp(n+1,1);//可以省略dp[0] = 1;dp[1] = 1;的初始化
        for(int i=2;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
};
```
随想录这个代码的好处就是，避免了对dp[0]这个没有意义的东西赋值
```cpp
// 随想录
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) { // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

### F2、空间上进行压缩
空间复杂度优化为O(1)
```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n<=2) return n;
        int pre = 1, cur = 1;
        for (int i = 2; i <= n; i++) {
            int tmp = pre + cur;
            pre = cur;
            cur = tmp;
        }
        return cur;
    }
};
```
### 扩展
这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到m个台阶，有多少种方法爬到n阶楼顶。

这其实是一个完全背包问题
#### 自写
问题：没有i-j>=0的判断
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    int climbStairs(int n,int m) {
    	if(n<=2) return n;
    	vector<int> dp(n+1,0);
        dp[0]=1;dp[1]=1;
    	for(int i=2;i<=n;i++){
    		for(int j=1;j<=m;j++){
    			dp[i]+=dp[i-j];
    		}
    	}
        return dp[n];
    }
};

int main() {
    Solution solution;
    cout << solution.climbStairs(5,2) << endl;
}
```
#### 随想录代码

完全背包问题

> **dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法**
>
> dp[i] += dp[i - j]
>
> 排列问题，先遍历背包

```cpp
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) { // 把m换成2，就可以AC爬楼梯这道题
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
```
## 剑指 Offer 46. 把数字翻译成字符串

[剑指 Offer 46. 把数字翻译成字符串](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

<img src="E:\MarkDown\picture\image-20230626150556762.png" alt="image-20230626150556762" style="zoom:50%;" />

dp[i]代表以xi为结尾的数字的翻译方案数量。

<img src="E:\MarkDown\picture\image-20230626150755442.png" alt="image-20230626150755442" style="zoom:50%;" />

```cpp
class Solution {
public:
    int translateNum(int num) {
        string str = to_string(num);
        vector<int> dp(str.size() + 1, 1);
        for (int i = 2; i <= str.size(); i++) {
            string tmp = str.substr(i - 2, 2);
            if (tmp >= "10" && tmp <= "25") dp[i] = dp[i - 1] + dp[i - 2];
            else dp[i] = dp[i - 1];
        }
        return dp[str.size()];
    }
};
```



## 746. 使用最小花费爬楼梯(E)

[力扣](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)


### 思路1

dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])

定义dp[i]为:第一步是不花费体力，最后一步是花费体力的

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size() + 1);
        dp[0] = 0; // 默认第一步都是不花费体力的
        dp[1] = 0;
        for (int i = 2; i <= cost.size(); i++) {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.size()];
    }
};
```
空间压缩
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int m=cost.size();
        int curr=0,pre1=0,pre2=0;
        for(int i=2;i<=m;i++){
            curr=min(pre2+cost[i-1],pre1+cost[i-2]);
            pre1=pre2;
            pre2=curr;
        }
        return curr;
    }
};
```

### 思路2

dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];

这里的dp[i]，指爬过这个楼梯的，故如dp[3]=min(dp[2]+dp[1])+cost[3]，即到这层楼梯的最小dp加爬过这一层的体力耗费。然后最后返回前两个dp中最小的那个就行
定义的dp[i]意思是是第一步是要花费体力的，最后一步不用花费体力了，因为已经支付了。

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值
        return min(dp[cost.size() - 1], dp[cost.size() - 2]);
    }
};
```
空间压缩
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp0 = cost[0];
        int dp1 = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            int dpi = min(dp0, dp1) + cost[i];
            dp0 = dp1; // 记录一下前两位
            dp1 = dpi;
        }
        return min(dp0, dp1);
    }
};
```

## 62.不同路径
[力扣](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

### F1 动态规划
自写
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // dp[m][n]为到m n位置的路径
        // dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        vector<vector<int>> dp(m, vector<int>(n, 1));
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```
随想录，区别就是这里先初始化i=0和j=0的地方，再计算中间部分的
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```
时间复杂度O(m *n)，空间复杂度O(m *n)

---
一维数组空间压缩，**滚动数组**

二维中第一行和第一列被初始化为如下的形式，因此变为一维后，也是从第二行和第二列开始遍历，但在初始化上是均初始化为1

| 0/1（不参与计算) | 1         | 1         |
| ---------------- | --------- | --------- |
| 1                | 1 + 1 = 2 | 2 + 1 = 3 |
| 1                | 2 + 1 = 3 | 3 + 3 = 6 |



```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n,1);
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[j]=dp[j]+dp[j-1];
            }
        }
        return dp[n-1];
    }
};
```
时间复杂度O(m *n)，空间复杂度O(n)

### F2 深度搜索 
[随想录](https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF)
但这个方法会超时

<img src="E:\MarkDown\picture\image-20230203203915356.png" alt="image-20230203203915356" style="zoom:70%;" />

```cpp
class Solution {
private:
    int dfs(int i, int j, int m, int n) {
        if (i > m || j > n) return 0; // 越界了
        if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点
        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
    }
public:
    int uniquePaths(int m, int n) {
        return dfs(1, 1, m, n);
    }
};
```
这个深搜的算法，其实就是要遍历整个二叉树。

这棵树的深度其实就是m+n-1（深度按从1开始计算）。

那二叉树的节点个数就是 2^(m + n - 1) - 1。可以理解深搜的算法就是遍历了整个满二叉树（其实没有遍历整个满二叉树，只是近似而已）

所以上面深搜代码的时间复杂度为O(2^(m + n - 1) - 1)，可以看出，这是指数级别的时间复杂度，是非常大的。

### F3 数论方法

走到终点需要m+n-2步
在这m+n-2步中，一定有m - 1步是要向下走的，不用管什么时候向下走。
那么有几种走法呢？可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。
那么这就是一个组合问题了。

C(n, k) = n! / ( (n-k)! * k! )

**思路1**

<img src="E:\MarkDown\picture\image-20230326130027150.png" alt="image-20230326130027150" style="zoom:40%;" /><img src="E:\MarkDown\picture\image-20230326130052355.png" alt="image-20230326130052355" style="zoom:40%;" /><img src="E:\MarkDown\picture\image-20230326130109492.png" alt="image-20230326130109492" style="zoom:40%;" />

```cpp
class Solution {
public:
    // 1 * n/1 * ... * (n + m - 2) / (m - 1)
    // 分母从1到m - 1，一共m - 2个，分子也从n跟着加到n + m - 2
    int uniquePaths(int m, int n) {
        long long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return ans;
    }
};
```

**思路2**

公式相同，只是计算顺序不同

```cpp
// 随想录版
class Solution {
public:
    // (m + n - 2) / (m - 1) * ... * n / 1
    int uniquePaths(int m, int n) {
        long long numerator = 1; // 分子
        int denominator = m - 1; // 分母
        int count = m - 1;
        int t = m + n - 2;
        while (count--) {
            numerator *= (t--);
            while (denominator != 0 && numerator % denominator == 0) {
                numerator /= denominator;
                denominator--;
            }
        }
        return numerator;
    }
};
```

时间复杂度：**O(m)**，空间复杂度：O(1)

## 63.不同路径II
[力扣](https://leetcode-cn.com/problems/unique-paths-ii/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

**动态规划**

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        // 注意，对于边界情况的赋值，一旦遇到obstacleGrid[i][0] == 1的情况就停止赋值1的操作
        for (int i = 0; i < n && obstacleGrid[0][i] == 0; i++) dp[0][i] = 1;
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] != 1) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

**空间优化**

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector<int> dp(n, 0);
        for (int i = 0; i < n; i++) {
            if (obstacleGrid[0][i] == 1) dp[i] = 0;  // 有障碍物
            else if (i == 0) dp[i] = 1;
            else dp[i] = dp[i - 1];  // 为了处理第一列中有障碍的情况
        }
        for (int i = 1; i < m; i++) {
            for (int j = 0; j < n; j++) {  // 这里j=0也要遍历了，因为可能有障碍物
                if (obstacleGrid[i][j] == 1) dp[j] = 0;
                else if (j != 0) dp[j] = dp[j] + dp[j - 1];  // 加上判断条件
            }
        }
        return dp[n - 1];
    }
};
```

## 343.整数拆分

[力扣](https://leetcode-cn.com/problems/integer-break/) [剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/)

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

### F1 动态规划

> dp[i]为拆分数字i，可以得到的最大乘积
>
> dp[i] = max( (i - j) * j, dp[i - j] * j )
>
> 解释：
> 从1遍历j，然后有两种渠道得到dp[i]：
> 一个是 j * (i - j) 直接相乘。
> 一个是 j * dp[i - j]，相当于是拆分 (i - j)
>
> 然后每次计算取dp最大的：
> dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

1.dp[0] = 1，dp[1] = 1的初始化比较牵强，无法解释，因此来避免，从dp[2]开始

2.j 的结束条件是j < i，即最后遍历到1 * (i - 1)的情况。但在 j = 1的时候，这一步就已经拆出来了，重复计算，所以 j < i - 1。此外，再进行优化，可以写成**j <= i / 2**;最差也应该是拆成两个相同的

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1, 0);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};

```
时间复杂度：O(n^2)  空间复杂度：O(n)

**另一种写法（需要推导）**

```cpp
class Solution {
public:
    int integerBreak(int n) {
        // dp[]为第n个数拆分的最大乘积
        vector<int> dp(n + 1, 0);  // 初始化dp[0] 1 2为1
        dp[1] = 1; dp[2] = 1;
         for (int i = 3; i <= n; i++) {
            dp[i] = max({dp[i - 2] * 2, dp[i - 3] * 3, (i - 2) * 2, (i - 3) * 3});
        }
        return dp[n];
    }
};
```

### F2 数学方法(需要推导)

可以发现，10->3^ 2+4  11->3^3+2  12->3 ^4，即最大值都3的几次方，若有余的话，大于1则直接乘，小于1则加上3

```cpp
class Solution {
public:
    int integerBreak(int n) {
        if(n<2) return 0;
        if(n<=3) return n-1;
        // pow(x, y)是求x的y次幂
        if (n % 3 > 1) return pow(3, n / 3) * (n % 3); // 余2
        else return pow(3, n / 3 - 1) * (n % 3 + 3); // 余0或1
    }
};
```

时间复杂度和空间复杂度都为O(1)

### F3 贪心算法（需要推导

```cpp
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n == 4) return 4;
        int result = 1;
        while (n >= 5) {  // 保证了n-3 >= 2，即最后剩的大于2
            result *= 3;
            n -= 3;
        }
        result *= n;
        return result;
    }
};
```
时间复杂度：O(n)   空间复杂度：O(1)

##  96. 不同的二叉搜索树(*)
[力扣](https://leetcode-cn.com/problems/unique-binary-search-trees/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

二叉搜索树是一个有序树：

* 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* 它的左、右子树也分别为二叉搜索树
### F1 动态规划
> dp[i] 1到i为节点组成的二叉搜索树的个数为dp[i]
>
> dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
>
> 解释：
> 元素1(j)为头结点搜索树的数量 = 右子树有2（i-j)个元素的搜索树数量 * 左子树有0 (j - 1)个元素的搜索树数量
> 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
> 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
>
> dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;  // 空节点也是一棵二叉搜索树
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= i; j++){
                dp[i] += dp[i-j] * dp[j-1];
            }
        }
        return dp[n];
    }
};
```
时间复杂度 : O(n^2)   空间复杂度：O(n)

### F2 数学（未看）

![image-20230204105136434](E:\MarkDown\picture\image-20230204105136434.png)

![image-20230204105107855](E:\MarkDown\picture\image-20230204105107855.png)

```cpp
class Solution {
public:
    int numTrees(int n) {
        long long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2 * (2 * i + 1) / (i + 2);
        }
        return (int)C;
    }
};
```
时间复杂度 : O(n)  空间复杂度：O(1)

## ==背包问题==

![image-20230204105720060](E:\MarkDown\picture\image-20230204105720060.png)

只需要掌握0-1背包和完全背包

## ==*01背包*==

有n件物品和一个最多能背重量为 w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大
<img src="E:\MarkDown\picture\image-20230204183752310.png" alt="image-20230204183752310" style="zoom:50%;" />

### 暴力解法（回溯

```cpp
// 自写背包问题的暴力解法
// O(2^n)
#include<iostream>
#include<vector>
using namespace std;

int result = 0;
vector<int> weight = {2, 4, 3};
vector<int> value = {4, 2, 1};
int n = 3;  // 有三个物品
int w = 5;  // 背包容量为5
int temp;
void aa(int wei, int sum, int tag) {
    if (wei >= w) {
		if (wei == w) result = max(result, sum);
		else result = max(result, sum - temp);
        return;
    }
    for (int i = tag; i < n; i++) {
		temp = value[i];
 		aa(wei + weight[i], sum + value[i], i + 1);
    }
}

int main() {
	aa(0, 0, 0);
    std::cout << result;  // 5
}
```



### 二维dp数组
dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是dp[i] [j] 。
dp[i] [j] 由两部分构成：

* 不放物品i：即背包已经满了，没容量了。因此dp[i] [j]=dp[i-1] [j]，等于没放前的dp

* 放物品i：dp[i] [j]=dp[i-1] [j-weight[i]]+value[i]

  因此递归公式为两个取max：dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);

内层循环从大到小遍历，才能保证每个物品仅参与计算一次

<img src="E:\MarkDown\picture\image-20230204183835013.png" alt="image-20230204183835013" style="zoom: 40%;" />

```cpp
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagweight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}


```

### 一维dp数组(更常用)
> * 在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]
> * 初始化：为0即可
>   递推公式中是取最大值，因此初始值设为0就行
> * **背包容量的遍历顺序：逆序**
>   保证物品i只被放入一次。如果正序遍历，物品将被重复加入
>   如果正序遍历：
>   dp[1] = dp[1-weight[0]] + value[0] = 15
>   dp[2] = dp[2-weight[0]] + value[0] = dp[1]+value[0]=30，value被重复加入
> * 遍历顺序的理解：dp是根据前面的状态累加value的，因此若是从前往后，物品将被重复加入，故只能从后往前。
> * 遍历物品和背包的先后顺序：必须**先遍历物品**，**再遍历背包容量**
>   因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么根据倒叙从后往前遍历背包，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。
>
> ```cpp
> for(int i = 0; i < weight.size(); i++) { // 遍历物品
>     for(int j = size; j >= weight[i]; j--) { // 遍历背包容量
>         dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
>     }
> }
> ```

```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}

int main() {
    test_1_wei_bag_problem();
}
```
## 416.分割等和子集

[力扣](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**动态规划**

背包容量：sum / 2

物品weight和value：对应nums

dp[j]为 容量为j的背包所背的最大价值。在这里就是容量为sum / 2的背包里装的最大的数，若是能填满，即dp[sum / 2] == sum / 2，则return true；

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // 背包容量：sum / 2
        int sum = 0;
        for (auto i : nums) {
            sum += i;
        }
        if (sum % 2 == 1) return false;
        sum = sum / 2;
        // 一维0-1背包
        vector<int> dp(sum + 1, 0);
        // 遍历顺序：先物品，后背包容量，其中背包容量逆序遍历
        for (int i = 0; i < nums.size(); i++) {
            for (int j = sum; j >= nums[i]; j--) {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[sum] == sum;
    }
};
```
时间复杂度O(n^2) 空间复杂度O(n)

## 1049. 最后一块石头的重量 II

[力扣](https://leetcode-cn.com/problems/last-stone-weight-ii/)

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

* 如果 x == y，那么两块石头都会被完全粉碎；
* 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。



### F1 动态规划
时间复杂度：O(m × n), m是石头总重量（准确的说是总重量的一半），n为石头块数
空间复杂度：O(m)

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for (int i : stones) sum += i;
        int target = sum / 2;
        vector<int> dp(target + 1, 0);
        for (int i = 0; i < stones.size(); i++) { // 遍历物品
            for (int j = target; j >= stones[i]; j--) { // 遍历背包
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
};
```

## 474.一和零(*)
[力扣](https://leetcode-cn.com/problems/ones-and-zeroes/)

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

### F1 动态规划

> 两个维度的0-1背包

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // m 和 n相当于是一个背包，两个维度的背包
        // dp[j][k]表示装满j k的最长子集
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for (int i = 0; i < strs.size(); i++) {
            int count0 = 0, count1 = 0;
            for (auto str : strs[i]) {
                if (str == '0') count0++;
                else count1++;
            }
            for (int j = m; j >= count0; j--) {
                for (int k = n; k >= count1; k--) {
                    dp[j][k] = max(dp[j][k], dp[j - count0][k - count1] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

## ==*完全背包*==

​	有 N 件物品和一个最多能背重量为 W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。
<img src="E:\MarkDown\picture\image-20230204183956215.png" alt="image-20230204183956215" style="zoom:55%;" />
<img src="E:\MarkDown\picture\image-20230204184309384.png" alt="image-20230204184309384" style="zoom:50%;" />

> 与 0-1 背包的区别：
>
> * 内层循环的遍历顺序不同。对于0-1背包，从大到小遍历，使得每个物品仅被添加一次；对于完全背包，物品可以添加多次，因此是从小到大遍历
>
> * 0-1背包中二维dp数组的两个for遍历的先后循序是可以颠倒的，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量；
>   而对于完全背包，只需要保证dp[j]前的dp都是经过计算的即可，因此也可以先遍历背包容量，再遍历物品
>
>   > 但要注意，对计算有多少种方法的问题，根据要求的是组合数还是排列数，遍历顺序是有区别的
>
>   <img src="E:\MarkDown\picture\image-20230204185043341.png" alt="image-20230204185043341" style="zoom:50%;" />

```cpp
vector<int> dp(bagWeight + 1, 0);
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}

// 先遍历背包，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

## 【`组合`】

## 494. 目标和(*)

[力扣](https://leetcode-cn.com/problems/target-sum/)

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

* 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。

返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

### F1 动态规划


> * 背包问题
>   将一个数组分为a、b两块，即a块里的元素均赋+，b赋-，则a-b=target，a+b=sum，可推出a=(sum+target)/2，即此问题转化为看数组中各个元素组合为a有多少种可能
>
> * 0-1 背包，每个物品只能装入一次
>   
> * 区别
>   之前的题目都是最多能装多少，而此题为装满有多少种方法
>
> * dp[j]表示装满j有dp种可能
>
> * 递推公式
>   只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。
>   例如：dp[j]，j为5，
>
>   * 已经有一个 1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。
>   * 已经有一个 2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。
>   * 已经有一个 3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包
>   * 已经有一个 4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包
>   * 已经有一个 5（nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包
>
>   那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。
>
>   所以求**组合类问题（装满背包有几种方法）**的公式，都是类似这种：`dp[j] += dp[j - nums[i]]`
>
>
> * 初始化
>   dp[0] = 1

注意：

* 如果sum与target的和为奇数的话，如sum奇target偶，则怎么加符号都构不成target
* 用abs[target]<sum来判断[100,100]  -300和[100,100]  300这种情况


```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
		for (int i = 0; i < nums.size(); i++) sum += nums[i];
        // 用abs[target]<sum来判断[100,100]  -300和[100,100]  300这种情况
        if ((sum + target) % 2 == 1 || abs(target) > sum) return 0;
        int a = (sum + target) / 2;
        vector<int> dp(a + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) { // 遍历物品
            for (int j = a; j >= nums[i]; j--){
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[a];
    }
};
```

时间复杂度：O(n × m)，n为正数个数，m为背包容量
空间复杂度：O(m)，m为背包容量

### F2 回溯算法

就是39.组合总和 直接拿过来

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) result.push_back(path);
        // 如果 sum + candidates[i] > target 就终止遍历
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum + candidates[i], i + 1);
            path.pop_back();
        }
    }
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (target > sum) return 0; // 此时没有方案
        if ((target + sum) % 2) return 0; // 此时没有方案，两个int相加的时候要各位小心数值溢出的问题
        int bagSize = (target + sum) / 2; // 转变为组合总和问题，bagsize就是要求的和
        sort(nums.begin(), nums.end());
        backtracking(nums, bagSize, 0, 0);
        return result.size();
    }
};
```



## 518.零钱兑换Ⅱ(M)

[力扣](https://leetcode.cn/problems/coin-change-ii/)

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

### F1 动态规划

> dp[j]表示面额达到j的硬币组合数
> 对于有多少种方法的问题：dp[j] += dp[j - coins[i]]
>
> 对于初始化，第一个数要为1，即组合为0有一种方法。后面的设为0，以不影响计算
>
> 纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行，而本题要求凑成总和的组合数，元素之间明确要求没有顺序。
>
> 对于此题，**遍历顺序很重要**
>
> * 先遍历物品，再遍历容量，比如先把coins[0]加入计算，再把coins[1]加入计算，这样计算的就是**组合数**。如计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！
> * 先遍历容量，再遍历物品，此时就会对物品即coins[i]重复计算，计算得到的就是**排列数**

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
		// 组合问题，遍历顺序先物品
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

## `【排列】`

## 377. 组合总和 Ⅳ

[377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

> * 个数不限->完全背包
> * 求方法数->dp[j] += dp[j - nums[i]];
> * 这里说是问组合个数，但根据例子，其实是求**排列**
>   * 排列个数->先遍历背包
> * dp[j]表示总和达到j的组合数
> * 对于初始化，第一个数要为1，这样递归其他dp[i]的时候才会有数值基础，以不影响计算
> * C++测试用例有两个数相加超过int的数据，所以需要在if里加上**dp[i] < INT_MAX - dp[i - num]**

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        // 重点，遍历顺序
        for (int j = 0; j <= target; j++) {
            for (int i = 0; i < nums.size(); i++) {
                // C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]
                if (j - nums[i] >= 0 && dp[j] < INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]];
            }
        }
        return dp[target];
    }
};
```

**进阶问题**

如果给定的数组中含有负数，则会导致出现无限长度的排列。

例如，假设数组 nums 中含有正整数 a 和负整数 −b（其中 a>0,b>0,−b<0），则有 a×b+(−b)×a=0，对于任意一个元素之和等于 target 的排列，在该排列的后面添加 b 个 a 和 a 个 −b 之后，得到的新排列的元素之和仍然等于 target，而且还可以在新排列的后面继续 b 个 a 和 a 个 −b。因此只要存在元素之和等于 target 的排列，就能构造出无限长度的排列。

如果允许负数出现，则必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数。



## 70.爬楼梯进阶版

一步一个台阶，两个台阶，三个台阶，直到m个台阶，有多少种方法爬到n阶楼顶。

完全背包问题

> **dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法**
>
> dp[i] += dp[i - j]
>
> m是物品，n是背包
>
> 排列问题，先遍历背包再遍历物品

```cpp
 class Solution {
 public:
     int climbStairs(int n) {
         vector<int> dp(n + 1, 0);
         dp[0] = 1;
         for (int i = 1; i <= n; i++) {
             for (int j = 1; j <= m; j++) {
                 if (i - j >= 0) dp[i] += dp[i - j];
             }
         }
         return dp[n];
     }
 };
```

## 139. 单词拆分(~)(*)

[139. Word Break](https://leetcode.cn/problems/word-break/)

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

### F1 动规

> 背包:s 物品:word 看word能不能把s装满
>
> dp[i] : 长度为i的字符串，或者说以i-1结尾的字符串（不包括i），true表示可以拆分为一个或多个在字典中出现的单词
>
> "apple" "pen" "apple"可以看出，求的是排列数，必须先遍历背包，再遍历物品
>
> 时间复杂度O(n^3)

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;  // 别忘了初始化
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < i; j++) {  // 遍历物品
                // 截取[j, i)区间的字符串
                // 时间复杂度为O(len)
                string tmp = s.substr(j, i - j);
                // vector没有内置的find函数
                if (find(wordDict.begin(), wordDict.end(), tmp) != wordDict.end() && dp[j]) dp[i] = true;
            } 
        }
        return dp[s.size()];
    }
};
```

### F2 回溯

有个用例超时了

```cpp
class Solution {
private:
    bool backtracking (const string& s, const unordered_set<string>& wordSet, int startIndex) {
        if (startIndex >= s.size()) {
            return true;
        }
        for (int i = startIndex; i < s.size(); i++) {
            string word = s.substr(startIndex, i - startIndex + 1);
            if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet, i + 1)) {
                return true;
            }
        }
        return false;
    }
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        return backtracking(s, wordSet, 0);
    }
};
```

* 时间复杂度：O(2^n)，因为每一个单词都有两个状态，切割和不切割
* 空间复杂度：O(n)，算法递归系统调用栈的空间

**改进的回溯**

递归的过程中有很多重复计算，可以使用数组保存一下递归过程中计算的结果。

这个叫做记忆化递归，这种方法我们之前已经提过很多次了。

使用memory数组保存每次计算的以startIndex起始的计算结果，如果memory[startIndex]里已经被赋值了，直接用memory[startIndex]的结果。

```cpp
class Solution {
private:
    bool backtracking (const string& s,
            const unordered_set<string>& wordSet,
            vector<bool>& memory,
            int startIndex) {
        if (startIndex >= s.size()) {
            return true;
        }
        // 如果memory[startIndex]不是初始值了，直接使用memory[startIndex]的结果
        if (!memory[startIndex]) return memory[startIndex];
        for (int i = startIndex; i < s.size(); i++) {
            string word = s.substr(startIndex, i - startIndex + 1);
            if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet, memory, i + 1)) {
                return true;
            }
        }
        memory[startIndex] = false; // 记录以startIndex开始的子串是不可以被拆分的
        return false;
    }
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> memory(s.size(), 1); // -1 表示初始化状态
        return backtracking(s, wordSet, memory, 0);
    }
};
```

这个时间复杂度其实也是：O(2^n)。只不过对于上面那个超时测试用例优化效果特别明显。

## `【最小数】`

## *322.零钱兑换(~)*

[322. Coin Change](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

**完全背包**

> * **dp[j]：凑足总额为j所需钱币的最少个数为dp[j]**
> * dp[j] = min(dp[j], dp[j - coins[i]] + 1); 凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]
> * 遍历顺序->随便，因为这里是求最小的个数，排列还是组合无所谓
> * 注意，这里要判断if (dp[j - coins[i]] != INT_MAX)，如果是初始值的话需要跳过

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // dp[j] = min(dp[j], dp[j - coins[i]] + 1)
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                // 如果dp[j - coins[i]]是初始值则跳过
                if (dp[j - coins[i]] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        // coins < amount时，返回-1
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```

**回溯**

超时

```cpp
class Solution {
public:
    // 回溯的组合问题？可重复
    int result = INT_MAX;
    void aa(vector<int>& coins, int amount, int sum, int count) {
        if (sum == amount) {
            result = min(result,count);
            return;
        }
        if (sum > amount) return;
        for (int i = 0; i < coins.size() && coins[i] <= amount; i++) {
            aa(coins, amount, sum + coins[i], count + 1);
        }
    }
    int coinChange(vector<int>& coins, int amount) {
        sort(coins.begin(), coins.end());
        aa(coins, amount, 0, 0);
        return result == INT_MAX ? -1 : result;
    }
};
```

## 279、完全平方数/Perfect Squares (M)

[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

> dp[j] 和为j的完全平方数的最少数量
>
> dp[j] = min(dp[j - i * i] + 1, dp[j]);
>
> 遍历顺序：都可以
>
> 初始化：INT_MAX，初值设为0

```cpp
class Solution {
public:
    int numSquares(int n) {
        // 背包n，物品根号n
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        // pow(n, 0.5)
        int target = sqrt(n);
        for (int i = 1; i <= target; i++) {
            for (int j = i * i; j <= n; j++) {
                dp[j] = min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
};
```



## *多重背包(了解，没有相关题目*

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

展开后类似0-1背包，时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量<img src="E:\MarkDown\picture\image-20230205105619737.png" alt="image-20230205105619737" style="zoom:50%;" />

先展开再计算

```cpp
void test_multi_pack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    vector<int> nums = {2, 3, 2};
    int bagWeight = 10;
    for (int i = 0; i < nums.size(); i++) {
        while (nums[i] > 1) { // nums[i]保留到1，把其他物品都展开
            weight.push_back(weight[i]);
            value.push_back(value[i]);
            nums[i]--;
        }
    }

    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    cout << dp[bagWeight] << endl;

}
int main() {
    test_multi_pack();
}
```

计算的时候展开

```cpp
void test_multi_pack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    vector<int> nums = {2, 3, 2};
    int bagWeight = 10;
    vector<int> dp(bagWeight + 1, 0);


    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
        }
        // 打印一下dp数组
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    cout << dp[bagWeight] << endl;
}
int main() {
    test_multi_pack();
}
```

## ==打家劫舍==

## 198、打家劫舍

[198. House Robber](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

> dp[i]表示偷窃第i个房屋内得到的金额
>
> dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1) return nums[0];
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```
## 213. 打家劫舍 II

[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，今晚能够偷窃到的最高金额。

<img src="E:\MarkDown\picture\image-20230205124455030.png" alt="image-20230205124455030" style="zoom:50%;" />
![image-20230205124511833](E:\MarkDown\picture\image-20230205124511833.png)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        // dp[i]表示偷窃第i个房屋内得到的金额
        if (nums.size() == 1) return nums[0];
        if (nums.size() == 2) return max(nums[0], nums[1]);
        vector<int> dp(nums.size() - 1, 0);  // dp的长度变小了
        // 不考虑首元素
        dp[0] = nums[1];
        dp[1] = max(nums[1], nums[2]);
        for (int i = 2; i < nums.size() - 1; i++) {
            dp[i] = max(dp[i - 2] + nums[i + 1], dp[i - 1]);
        }
        int tmp = dp[nums.size() - 2];
        // 不考虑尾元素
        dp.clear();
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size() - 1; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return max(tmp, dp[nums.size() - 2]);
    }
};
```

另一种写法，dp大小与上题一致

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1) return nums[0];
        if (nums.size() == 2) return max(nums[0], nums[1]);
        vector<int> dp(nums.size(), 0);
        // 不考虑首元素
        dp[1] = nums[1];
        dp[2] = max(nums[1], nums[2]);
        for (int i = 3; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        int temp = dp[nums.size() - 1];
        // 不考虑尾元素
        dp.clear();
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size() - 1; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return max(dp[nums.size() - 2], temp);
    }
};
```



## 337.打家劫舍 III(*)

[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。

除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。

给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

<img src="E:\MarkDown\picture\image-20230205124658795.png" alt="image-20230205124658795" style="zoom:50%;" />

### F1 动态规划

**树形dp**

pair<int, int>

每个结点有两个状态，node.first是偷，node.second是不偷

```cpp
class Solution {
public:
    // 后序遍历
    pair<int, int> aa(TreeNode* root) {
        if (root == nullptr) return {0, 0};
        auto left = aa(root->left);
        auto right = aa(root->right);
        // 偷当前结点
        int val1 = root->val + left.second + right.second;
        // 不偷当前结点
        int val2 = max(left.first, left.second) + max(right.first, right.second);
        return {val1, val2};
    }
    int rob(TreeNode* root) {
        auto val = aa(root);
        return max(val.first, val.second);
    }
};
```

vector<int>

```cpp
class Solution {
public:
    // 这里返回一个长为2的数组。下标0是不偷，1是偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left); // 左
        vector<int> right = robTree(cur->right); // 右
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
};
```

* 时间复杂度：O(n)，每个节点只遍历了一次
* 空间复杂度：O(log n)，算上递推系统栈的空间

### F2 递归

暴力递归，超时

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        // 偷父节点
        int val1 = root->val;
        if (root->left) val1 += rob(root->left->left) + rob(root->left->right); // 跳过root->left，相当于不考虑左孩子了
        if (root->right) val1 += rob(root->right->left) + rob(root->right->right); // 跳过root->right，相当于不考虑右孩子了
        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩子
        return max(val1, val2);
    }
};
```

> 通过map保存计算过的结果

```cpp
class Solution {
public:
    // 记录计算过的结果
    unordered_map<TreeNode* , int> umap; 
    // 后序遍历
    int rob(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        // 如果umap里已经有记录则直接返回
        if (umap[root]) return umap[root];
        // 情况一：偷父节点
        int val1 = root->val;
        if (root->left) val1 += rob(root->left->left) + rob(root->left->right); // 跳过root->left，相当于不考虑左孩子了
        if (root->right) val1 += rob(root->right->left) + rob(root->right->right); // 跳过root->right，相当于不考虑右孩子了
        // 情况二：不偷父节点
        int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩子
        umap[root] = max(val1, val2); // umap记录一下结果
        return max(val1, val2);
    }
};
```

* 时间复杂度：O(n)
* 空间复杂度：O(log n)，算上递推系统栈的空间

## ==股票问题==

多维数组，第二维为买入的状态

## 121. 买卖股票的最佳时机(~)(*)

[121. Best Time to Buy and Sell Stock](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/) [剑指 Offer 63. 股票的最大利润](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

### F1 动态规划

<img src="E:\MarkDown\picture\image-20230205170358198.png" alt="image-20230205170358198" style="zoom:50%;" /><img src="E:\MarkDown\picture\image-20230205170259557.png" alt="image-20230205170259557" style="zoom:33%;" />

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // dp[i][0] 第i天持有股票。和前一天相同，即之前买了，第i天也没卖；或者第i天买的
        // dp[i][1] 第i天不持有股票。和前一天相同，没买；或第i天卖，即前一天持有股票的钱(负的)加上prices[i]
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[prices.size() - 1][1];
    }
};
```

* 时间复杂度：O(n)
* 空间复杂度：O(n)

### F2 贪心

写法一：与53类似，

> 假设[7 1 5 3 6 4]，则相邻元素差值为[-6 4 -2 3 -2]，只能买一次，则是求这个差值的最大子数组和
>
> > 注意，没有利润的话返回0，所以这里result初始化为0

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int sum = 0, result = 0;
        for (int i = 1; i < prices.size(); i++) {
            int temp = prices[i] - prices[i - 1];
            sum += temp;
            result = max(result, sum);
            if (sum < 0) sum = 0;
        }
        return result;
    }
};
```

写法2

因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            low = min(low, prices[i]);  // 取最左最小价格
            result = max(result, prices[i] - low); // 直接取最大区间利润
        }
        return result;
    }
};
```

时间复杂度：O(n)

空间复杂度：O(1)

### F3 暴力解法

超时

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            for (int j = i; j < prices.size(); j++) {
                if (prices[j] - prices[i] > 0) result = max(result, prices[j] - prices[i]);
            }
        }
        return result;
    }
};
```

## 122. 买卖股票的最佳时机 II

[122. Best Time to Buy and Sell Stock II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

### F1 动态规划

在121中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即dp[i] [0]一定就是 -prices[i]。

而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 - 今天的股票价格 即：dp[i - 1] [1] - prices[i]。

> 如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来
>
> * 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]
> * 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1] [1] - prices[i]
>
> 如果第i天不持有股票即dp[i] [1]的情况，依然可以由两个状态推出来
>
> * 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]
> * 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1] [0]

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 0是持有股票没卖
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            // 前一天就持有股票，或前一天卖出了，今天又买入
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            // 前一天卖出，今天没买；前一天持有，今天卖
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
    }
};
```

### F2 贪心

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 判断是否递增，递增的话累积差值
        int sum = 0;
        for (int i = 0; i < prices.size() - 1; i++) {
            if (prices[i] < prices[i + 1]) sum += prices[i + 1] - prices[i];
        }
        return sum;
    }
};
```

## 123. 买卖股票的最佳时机 III(*)

[123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

> dp[i] [j] i表示第i天，j为 [0 - 4] 五个状态，dp[i] [j]表示第i天状态j所剩最大现金。
>
> 0. 没有操作  （其实我们也可以不设置这个状态）
>
> 1. 第一次持有股票
> 2. 第一次不持有股票
> 3. 第二次持有股票
> 4. 第二次不持有股票
>
> dp[i] [1]:
>
> * 操作一：第i天买入股票了，那么dp[i] [1] = dp[i-1] [0] - prices[i]
> * 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] = dp[i - 1] [1]
>
> dp[i] [2]
>
> * 操作一：第i天卖出股票了，那么dp[i] [2] = dp[i - 1] [1] + prices[i]
> * 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [2] = dp[i - 1] [2]
>
> 同理可推出剩下状态部分：
>
> dp[i] [3] = max(dp[i - 1] [3], dp[i - 1] [2] - prices[i]);
>
> dp[i] [4] = max(dp[i - 1] [4], dp[i - 1] [3] + prices[i]);
>
> 
>
> 初始化
>
> 第0天没有操作就是0，即：dp[0] [0] = 0;
>
> 第0天做第一次买入的操作，dp[0] [1] = -prices[0];
>
> 第0天做第一次卖出的操作，这个初始值应该是多少呢？
>
> 此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0] [2] = 0;
>
> 第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？
>
> 第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。
>
> 所以第二次买入操作，初始化为：dp[0] [3] = -prices[0];
>
> 同理第二次卖出初始化dp[0] [4] = 0;

```cpp
// 版本一
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```

* 时间复杂度：O(n)
* 空间复杂度：O(n × 5)

**空间简化**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<int> dp(5, 0);
        dp[1] = -prices[0];
        dp[3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
};
```

**四个状态版本**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 第一次买入、卖出；第二次买入、卖出
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(4, 0));
        dp[0][0] = -prices[0];
        // 注意第二次买入的初始化
        dp[0][2] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] - prices[i]);
            dp[i][3] = max(dp[i - 1][3], prices[i] + dp[i - 1][2]);
        }
        return dp[prices.size() - 1][3];
    }
};
```

## 188. 买卖股票的最佳时机 Ⅳ(k笔交易)

[188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

> * 0 表示不操作
> * 1 第一次买入
> * 2 第一次卖出
> * 3 第二次买入
> * 4 第二次卖出
> * .....

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if (prices.size() == 0) return 0;
        // 一共有什么都不做的状态和第k天卖出/买入共2 * k + 1种状态
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        // 对奇数，即第k天买入的状态设初值
        for (int i = 1; i < (2 * k); i += 2) {
            dp[0][i] = -prices[0];
        }
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];  // 删掉也行，一直为0
            for (int a = 1; a <= 2 * k; a++) {
                if (a % 2 == 1)  
                    dp[i][a] = max(dp[i - 1][a], dp[i - 1][a - 1] - prices[i]);
                else dp[i][a] = max(dp[i - 1][a], dp[i - 1][a - 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

## 进阶：有初始资金的k笔交易

例如，初始资金M = 10000，连续N = 7天的价格分别是(单位/元)1 2 1 2 2 3 2，最大交易次数为K = 2，则最大收益为50000元

（第一天1元买入，得10000股，第二天2元卖出得20000元，第三天1元买入得20000股，第六天卖出得60000元，盈利50000元

输入：10000, 2, (1, 2, 1, 2, 2, 3, 2)
输出：50000

```CPP
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxProfit(int M, int k, vector<int>& prices) {
        // 买入 卖出
        // 买入存股票数
        // 卖出存现金数
        vector<vector<int>> dp(prices.size(), vector<int>(k * 2 + 1, 0));
        for (int j = 1; j <= k * 2; j += 2) dp[0][j] = M / prices[0];
        for (int j = 0; j <= k * 2; j += 2) dp[0][j] = M;
        for (int i = 1; i < prices.size(); i++) {
            for (int j = 1; j <= k * 2; j++) {
                if (j % 2 == 1) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] / prices[i]);
                else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] * prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k] - M;
    }
};

int main() {
	Solution s;
	vector<int> prices = {1, 2, 1, 2, 2, 3, 2};
	cout << s.maxProfit(10000, 2, prices);
}
```



## 309. 最佳买卖股票时机含冷冻期(*)

[309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

* 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

> 0:买入股票，今天买入(前一天是冷冻期3或是保持之前卖出的状态1)或之前就持有
>
> 1：**保持之前卖出的状态**（前一天是冷冻期3。或者是前一天就是卖出股票状态2，一直没操作）
>
> 2：卖出股票，昨天是0
>
> 3：**冷冻状态**，昨天是3

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 买入0 保持卖出1 今天卖出2 冷静期3
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max({dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]});
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max({dp[n - 1][3], dp[n - 1][1], dp[n - 1][2]});
    }
};
```

## 714. 买卖股票的最佳时机含手续费(M)

[714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

### F1 动态规划

时间复杂度O(n)

与Ⅱ的区别在于减去了个fee

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        // dp[i][0] 第i天持有股票。和前一天相同，即之前买了，第i天也没卖；或者第i天买的
        // dp[i][1] 第i天不持有股票。和前一天相同，没买；或第i天卖，即前一天持有股票的钱(负的)加上prices[i]
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] -= prices[0];
        // dp[0][1] = -fee;代入0看一下就能发现不对
        dp[0][1] = 0;
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0] - fee);
        }
        return dp[prices.size() - 1][1];
    }
};
```

### F2 贪心

* 时间复杂度：O(n)
* 空间复杂度：O(1)

随想录版

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int result = 0;
        int minPrice = prices[0]; // 记录最低价格
        for (int i = 1; i < prices.size(); i++) {
            // 情况二：相当于买入
            if (prices[i] < minPrice) minPrice = prices[i];

            // 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出
            if (prices[i] > minPrice + fee) {
                result += prices[i] - minPrice - fee;
                // 如果还在收获利润的区间里，表示并不是真正的卖出，而计算利润每次都要减去手续费，所以要让minPrice = prices[i] - fee;，这样在明天收获利润的时候，才不会多减一次手续费！
                minPrice = prices[i] - fee;
            }
        }
        return result;
    }
};
```

官解

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        // buy表示最低买入价格
        int buy = prices[0] + fee;
        int profit = 0;
        for (int i = 1; i < n; ++i) {
            // 如果当前的股票价格 prices[i] 加上手续费 fee 小于 buy，那么与其使用 buy 的价格购买股票，不如以 prices[i]+fee 的价格购买股票，因此我们将 buy 更新为 prices[i]+fee
            if (prices[i] + fee < buy) {
                buy = prices[i] + fee;
            }
            // 如果当前的股票价格 prices[i] 大于 buy，那么我们直接卖出股票并且获得 prices[i]−buy 的收益
            else if (prices[i] > buy) {
                profit += prices[i] - buy;
                // 此时卖出股票可能并不是全局最优的（例如下一天股票价格继续上升），因此我们可以提供一个反悔操作，看成当前手上拥有一支买入价格为 prices[i]的股票，将 buy 更新为 prices[i]。这样一来，如果下一天股票价格继续上升，我们会获得 prices[i+1]−prices[i] 的收益，加上这一天 prices[i]−buy 的收益，恰好就等于在这一天不进行任何操作，而在下一天卖出股票的收益
                buy = prices[i];
            }
        }
        return profit;
    }
};
```

## ==子序列问题==
<img src="E:\MarkDown\picture\image-20230206102836079.png" alt="image-20230206102836079" style="zoom:67%;" />

## 300.最长递增子序列(~)(*)

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

本来想的是放到个stack里，然后比较，递增的话放进去，遇到更大的删掉。但对于 2 3 1 2 3这种情况，就把后面的1 2 3都删掉了

**动规**

时间复杂度O(n^2)

> * dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度
> * 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值：**if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);**即在i之前的范围里，从比nums[i]小的那些dp里找最大的
> * i的遍历顺序必须从前往后，j的顺序无所谓
> * 初始化：均设为1
>
> 注意，要设一个result来保存最大的dp[i]
>
> 如[1,3,6,7,9,4,10,5,6]，输出的dp[i]为[1,2,3,4,5,3,6,4,5]，dp[i]仅代表以i结尾的最长长度，而序列的最长长度显然不一定是最后一位结尾



```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        int result = 1;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
                result = max(dp[i], result);
            }
        }
        return result;
    }
};
```

**贪心**

时间复杂度O(nlog⁡n)

> * 贪心：如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小
>
> * `数组d[i]表示长度为i的最长上升子序列的末尾元素的最小值`，即在数组 `1,2,3,4,5,6` 中长度为3的上升子序列可以为`1,2,3 `也可以为 `2,3,4` 等，但是`d[3]=3`，即子序列末尾元素最小为3。
> * 无序列表解释清了数组d的含义之后，我们接着需要证明数组d具有**单调性**，即证明`i<j时，d[i]<d[j]`，使用反证法，假设存在`k<j时，d[k]>d[j]`，但在长度为j，末尾元素为`d[j]`的子序列A中，将后`j-i`个元素减掉，可以得到一个长度为i的子序列B，其末尾元素t1必然小于`d[j]`（因为在子序列A中，t1的位置上在d[j]的后面），而我们假设数组d必须符合`表示长度为 i 的最长上升子序列的末尾元素的最小值`，此时长度为i的子序列的末尾元素t1`<d[j]<d[k]`，即`t1<d[k]`，所以d[k]不是最小的，与题设相矛盾，因此可以证明其单调性
> * 无序列表证明单调性有两个好处：1.可以使用二分法；2.数组d的长度即为最长子序列的长度
> * 依次遍历数组nums中的每个元素，并更新数组 d 和 len 的值。如果 nums[i]>d[len] 则更新 len=len+1，否则在 d[1…len]中找满足 d[i−1]<nums[j]<d[i] 的下标 i，并更新 d[i]=nums[j]
> * 时间复杂度：O(nlog⁡n)。数组 nums 的长度为 n，我们依次用数组中的元素去更新 d 数组，而更新 d 数组时需要进行 O(logn) 的二分搜索，所以总时间复杂度为 O(nlogn)
>
> 以输入序列 [0,8,4,12,2] 为例：
>
> * 第一步插入 0，d=[0]；
> * 第二步插入 8，d=[0,8]；
> * 第三步插入 4，d=[0,4]；
> * 第四步插入 12，d=[0,4,12]；
> * 第五步插入 2，d=[0,2,12]

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d(nums.size() + 1, 0);
        int result = 1;
        d[result] = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] > d[result]) {
                result++;
                d[result] = nums[i];
            } else {
                // 在d[1…len]中找满足d[i−1]<nums[j]<d[i]的下标i，并更新d[i]=nums[j]
                // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                int start = 1, end = result, pos = 0; 
                while (start <= end) {
                    int mid = start + (end - start) / 2;
                    if (d[mid] < nums[i]) {
                        pos = mid;
                        start = mid + 1;
                    } else {
                        end = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return result;
    }
};
```



## 674. 最长连续递增序列(E)

[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

### F1 动规

* 时间复杂度：O(n)
* 空间复杂度：O(1)

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        // dp[i]为以i结尾的最长连续
        vector<int> dp(nums.size(), 1);
        int result = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
            result = max(result, dp[i]);
        }
        return result;
    }
};
```

### F2 贪心

* 时间复杂度：O(n)
* 空间复杂度：O(1)

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int result = 1;
        int tmp = 1;
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) tmp++;
            else tmp = 1;
            result = max(result, tmp);
        }
        return result;
    }
};
```



## 718. 最长重复子数组(*)

> 子数组默认是连续的
>
> 子序列即下面的1143题默认是不连续的

给两个整数数组 `nums1` 和 `nums2` ，返回 两个数组中 **公共的** 、长度最长的子数组的长度

<img src="E:\MarkDown\picture\image-20230206153110953.png" alt="image-20230206153110953" style="zoom:50%;" />

[718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

### F1 动态规划

时间复杂度：O(n × m)，n为A长度，m为B长度

空间复杂度：O(n × m)

> 以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i] [j]
>
> 如dp[1] [1]就是以下标0为结尾的nums和以下标0为结尾的nums2的最长长度
>
> 这样对于dp[0] [0]就不管了，从1开始遍历，1就对应nums[0]

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        // 子数组，连续
        // dp[i][j]为nums1中以i-1结尾的数组与nums2中以j-1结尾的数组的最长重复子数组
        vector<vector<int>> dp(nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                result = max(result, dp[i][j]);
            }
        }
        return result;
    }
};
```

滚动数组

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int result = 0;
        vector<int> dp(nums2.size() + 1, 0);
        for (int i = 1; i <= nums1.size(); i++) {
            // 1.注意j的遍历要倒叙，否则会累加前面的结果
            for (int j = nums2.size(); j > 0; j--) {
                if (nums1[i - 1] == nums2[j - 1]) dp[j] = dp[j - 1] + 1;
                // 2.注意不相等的时候要赋0，因为每一层的结果需要覆盖上一轮的结果，无论是0还是新的dp都要重新赋值一遍
                else dp[j] = 0;
                result = max(result, dp[j]);
            }
        }
        return result;
    }
};
```

要是想要用dp[i] [j]表示下标为i和j的序列长度，则需要进行额外的初始化：

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp (nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int result = 0;
        // 要对第一行，第一列经行初始化
        for (int i = 0; i < nums1.size(); i++) if (nums1[i] == nums2[0]) dp[i][0] = 1;
        for (int j = 0; j < nums2.size(); j++) if (nums1[0] == nums2[j]) dp[0][j] = 1;
        for (int i = 0; i < nums1.size(); i++) {
            for (int j = 0; j < nums2.size(); j++) {
                if (nums1[i] == nums2[j] && i > 0 && j > 0) { // 防止 i-1 出现负数
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                result = max(result, dp[i][j]);
            }
        }
        return result;
    }
};
```

### F2 暴力

两层for循环确定两个数组起始位置，然后再来一个循环可以是for或者while，来从两个起始位置开始比较，取得重复子数组的长度

## *1143. 最长公共子序列(~)*

[1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

* 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。

两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

> 公共子序列(字符串)默认不连续
>
> dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i] [j]

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.size(), len2 = text2.size();
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[len1][len2];
    }
};
```

## 1035. 不相交的线(*)

[1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：

* nums1[i] == nums2[j]
* 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

> 不连续的最大子串，与1143. 最长公共子序列完全一样

```cpp
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int result = 0;
        vector<vector<int>> dp(nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                result = max(result, dp[i][j]);
            }
        }
        return result;
    }
};
```

## *53. 最大子数组和(~)*

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) [剑指 Offer 42. 连续子数组的最大和](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

### F1 动态规划

> **dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]**
>
> dp[i]只有两个方向可以推出来：
>
> * dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
> * nums[i]，即：从头开始计算当前连续子序列和

```cpp
class Solution {
public:
    // dp[i] = max(dp[i - 1] + nums[i], dp[i])
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int result = dp[0];  // 重要
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            result = max(result, dp[i]);
        }
        return result;
    }
};
```

### F2 贪心

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
全局最优：选取最大“连续和”

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 注意，可能有负数
        int result = INT_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            count += nums[i];
            result = max(result, count);
            if (count < 0) count = 0;
        }
        return result;
    }
};
```

## ==*编辑距离*==

## 392. 判断子序列

[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

### F1 暴力，更好

时间复杂度 O(m+n)

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int j = 0;
        for (int i = 0; i < t.size() && j < s.size(); i++) {
            if (t[i] == s[j]) j++;
        }
        if (j == s.size()) return true;
        return false;
    }
};
```

对于若干个s，只需要遍历一遍t，然后分别和s们比较一下

### F2 动态规划

编辑距离的入门题目

写法1：与1143.最长公共子序列一样

> **dp[i] [j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i] [j]**。

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int len1 = s.size(), len2 = t.size();
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[len1][len2] == s.size();
    }
};
```

写法2：编辑距离的思路

区别：不相等时删除t中的元素，因此是`dp[i][j]=dp[i][j-1];`

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                // 区别：遇到不相同的，t串删除。
                else dp[i][j] = dp[i][j - 1];
            }
        }
        if (dp[s.size()][t.size()] == s.size()) return true;
        return false;
    }
};

```

* 时间复杂度：O(n × m)
* 空间复杂度：O(n × m)

## 115. 不同的子序列(*)

[115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。

> 注意，题目数据保证答案符合 32 位带符号整数范围，但在dp[i - 1] [j - 1] + dp[i - 1] [j]时可能会超
>
> 1. 在定义dp时使用uint64_t或unsigned long long
> 2. 增加一个判定，if (s[i - 1] == t[i - 1] && (INT_MAX - dp[i - 1] [j - 1] > dp[i] [j - 1])) dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];，然后定义pd时就能用long long了

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int len1 = t.size(), len2 = s.size();
        vector<vector<uint64_t>> dp(len1 + 1, vector<uint64_t>(len2 + 1, 0));
        for (int i = 0; i <= len2; i++) {
            dp[0][i] = 1;
        }
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                // dp[i][j - 1]表示不用s[j - 1]匹配，比如abb中找ab，可以不用第二个b匹配
                // dp[i - 1][j - 1]表示用s[j - 1]匹配
                if (t[i - 1] == s[j - 1]) dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];
                else dp[i][j] = dp[i][j - 1];
            }
        }
        return dp[len1][len2];
    }
};
```



也可以用long long，加个判定

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        // dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。
        vector<vector<long long>> dp(s.size() + 1, vector<long long>(t.size() + 1));
        // dp[0][j]为在空的s里面找t，为0
        // dp[i][0]为在s里找空的t，肯定为1(dp[0][0]为1)
        for (int i = 0; i <= s.size(); i++) dp[i][0] = 1;
        for (int j = 1; j <= t.size(); j++) dp[0][j] = 0;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                // dp[i - 1][j]表示不用s[i-1]进行匹配，即只看s[i-1]前的来匹配
                if (s[i - 1] == t[j - 1] && (INT_MAX - dp[i - 1][j - 1] > dp[i][j - 1])) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j];
            }
        }
        return dp[s.size()][t.size()];
    }
};

```

## 583. 两个字符串的删除操作

[583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

### F1 间接，先求公共子序列

与1143.最长公共子序列完全相同，求出公共子序列后用size减一下就行

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int result = 0;
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                // 不相等时，取前一个序列中的最大的
                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                result = max(result, dp[i][j]);
            }
        }
        return word1.size() + word2.size() - 2 * result;
    }
};
```

### F2 直接求最小步数

与115. 不同的子序列类似

> * dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数
> * 不相等时，删除其中一个`dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1)`
> * 注意初始化是怎么推理的，有点点特殊

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
                // 不相等时，删掉其中的一个
                else dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1);
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

## *72. 编辑距离(~)*

[72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数*  。

你可以对一个单词进行如下三种操作：

* 插入一个字符
* 删除一个字符
* 替换一个字符

> 与583类似
>
> `dp[i][j - 1] + 1`对应插入，即在word1不相等的这个元素后插入这个元素，然后看这个元素和word2前的元素的最少操作数
>
> `dp[i - 1][j] + 1`对应删除，即删除word1中那个不相等的，就可以用word1的上一个和word2比了
>
> `dp[i - 1][j - 1] + 1`对应替换

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
                // 分别对应插入、替换、删除
                else dp[i][j] = min({dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1});
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

## ==*回文*==

## 647. 回文子串(*)

[647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

### F1 暴力

两层for循环，遍历区间起始位置和终止位置，然后还需要一层遍历判断这个区间是不是回文。所以时间复杂度：O(n^3)

```cpp
class Solution {
public:
    bool ish(int i, int j, const string& s) {
        string tmp = s.substr(i, j - i);
        while (i <= j) {
            if (s[i] == s[j]) {
                i++; j--;
            } else return false;
        }
        return true;
    }
    int countSubstrings(string s) {
        // 暴力：找到所有字串
        int count = 0;
        for (int i = 0; i < s.size(); i++) {
            for (int j = i; j < s.size(); j++) {
                if (ish(i, j, s)) count++;
            }
        }
        return count;
    }
};
```

### F2 动态规划

> `dp[i][j]`：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串
>
> <img src="E:\MarkDown\picture\image-20230207102444928.png" alt="image-20230207102444928" style="zoom:30%;" />
>
> 整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。
>
> 当s[i]与s[j]不相等，那没啥好说的了，`dp[i][j]`一定是false。
>
> 当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况
>
> * 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
> * 情况二：下标i 与 j相差为1，例如aa，也是回文子串
> * 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看
>
> 对于遍历顺序，根据`dp[i + 1][j - 1]`计算，以i为行j为列的话，需要从下到上，从左到右

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        // dp[i][j]表示下标位置i开始，j结束的字符串回文串数目
        // i行j列
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), 0));
        int result = 0;
        // 注意遍历顺序
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (j - i <= 1) { // 情况一 和 情况二
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { // 情况三
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return result;
    }
};
```

时间复杂度和空间复杂度都为O(n^2)

### F3 双指针法

> 首先确定回文串，就是找中心然后向两边扩散看是不是对称的就可以了。
>
> **在遍历中心点的时候，要注意中心点有两种情况**。
>
> 一个元素可以作为中心点，两个元素也可以作为中心点。
>
> 那么有人同学问了，三个元素还可以做中心点呢。其实三个元素就可以由一个元素左右添加元素得到，四个元素则可以由两个元素左右添加元素得到。
>
> 所以我们在计算的时候，要注意一个元素为中心点和两个元素为中心点的情况。

空间复杂度更低，为O(1)

```cpp
class Solution {
public:
    int aa(const string& s, int i, int j) {
        int res = 0;
        while (i >= 0 && j < s.size() && s[i] == s[j]) {
            res++;
            i--; j++;
        }
        return res;
    }
    int countSubstrings(string s) {
        int result = 0;
        for (int i = 0; i < s.size(); i++) {
            result += aa(s, i, i);
            result += aa(s, i, i + 1);
        }
        return result;
    }
};
```

## *5. 最长回文子串(~)*

[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        // 一个字符串的首尾相同，且中间部分为回文子串
        // dp[i][j]表示i开头j结尾的是否是回文子串
        // dp[i + 1][j - 1]，遍历顺序从第向上，从前向后
        string tmp = "";
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {  // j >= i
                if (s[i] == s[j]) {
                    if (j - i <= 1 || dp[i + 1][j - 1]) {
                        dp[i][j] = true;
                        if (j - i + 1 > tmp.size()) tmp = s.substr(i, j - i + 1);
                    }
                }
            }
        }
        return tmp;
    }
};
```



与647的几种情况相同

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        // dp[i][j]表示下标位置i开始，j结束的字符串回文串长度
        // dp有数值的表示是回文子串且长度为dp
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        int result = 0;  // 记录最大长度
        int start = 0;  // 记录下标
        // 注意遍历顺序
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (i == j) dp[i][j] = 1;
                    else if (j - i == 1) dp[i][j] = 2;
                    else if (dp[i + 1][j - 1]) {
                        dp[i][j] = dp[i + 1][j - 1] + 2;
                    }
                    // 记录最大长度和对应的下标
                    if (dp[i][j] > result) {
                        result = dp[i][j];
                        start = i;
                    }
                }
            }
        }
        return string(s.begin() + start, s.begin() + result + start);
    }
};
```

## 516. 最长回文子序列(M)

[516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。



与 5.最长回文子串 相同写法

> 与 5.最长回文子串 的区别在于增加了s[i] s[j]不相等时的判定
>
> 如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。
>
> 加入s[j]的回文子序列长度为`dp[i + 1][j]`。
>
> 加入s[i]的回文子序列长度为`dp[i][j - 1]`。

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        // dp[i][j]表示下标位置i开始，j结束的字符串回文串长度
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (j - i <= 1) dp[i][j] = j - i + 1;
                    else if (dp[i + 1][j - 1]) {
                        dp[i][j] = dp[i + 1][j - 1] + 2;
                    }
                }
                // 与5. 最长回文子串的区别在于增加了这个不相等的判定
                // 若不是回文，就删i或删j，即对于aab，判定aa和ab里最大的
                // 这里的"删"，就按遍历顺序反着来，所以对i是+，对j是-
                else dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
            }
        }
        return dp[0][s.size() - 1];
    }
};
```

简洁写法

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        // dp[i][j]表示下标位置i开始，j结束的字符串回文串长度
        // dp有数值的表示是回文子串且长度为dp
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        // 初始化，因为递推公式计算不到 i 和j相同时候的情况。
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
        // 注意遍历顺序
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2;
                else dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
            }
        }
        return dp[0][s.size() - 1];
    }
};
```

# 十三、单调栈

```cpp
stack<int> st;
for (遍历这个数组) {
	if (栈空 || 栈顶元素大于等于当前比较元素) {
		入栈;
	} else {
		while (栈不为空 && 栈顶元素小于当前元素) {
             更新结果;
			栈顶元素出栈;
		}
		当前数据入栈;
	}
}
```

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**

时间复杂度为O(n)

单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是只需要遍历一次。

单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

## 739. 每日温度

[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

> 栈中存放元素下标，result[st.top()] = i - st.top();
>
> 情况1：当前元素小于等于栈顶，则入栈
>情况2：当前元素大于栈顶，栈顶元素出栈并保存结果
> 
> 最后栈中剩下的为遇不到更大的数，就是默认值0

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // 暴力 n^2
        // 单调栈
        vector<int> result(temperatures.size(), 0);
        stack<int> stk;
        stk.push(0);
        for (int i = 1; i < temperatures.size(); i++) {
            while (stk.size() && temperatures[i] > temperatures[stk.top()]) {
                result[stk.top()] = i - stk.top();
                stk.pop();
            }
            stk.push(i);
        }
        return result;
    }
};
```

精简版

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;
        vector<int> result(temperatures.size(), 0);
        for (int i = 0; i < temperatures.size(); i++) {
        	while (!st.empty() && temperatures[st.top()] < temperatures[i]) {
                result[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);
        }
        return result;
    }
};
```

## 496. 下一个更大元素 I(E)

[496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

与739思路相同

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> result(nums1.size(), -1);
        // 关键，用map记录nums1的下标
        unordered_map<int, int> m;
        for (int i = 0; i < nums1.size(); i++) m[nums1[i]] = i;
        st.push(0);
        for (int i = 0; i < nums2.size(); i++) {
            if (nums2[st.top()] >= nums2[i]) st.push(i);
            else {
                while (!st.empty() && nums2[st.top()] < nums2[i]) {
                    // 关键，用count查找nums1中是否有这个数
                    if (m.count(nums2[st.top()]) > 0)
                        result[m[nums2[st.top()]]] = nums2[i];
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

## 503. 下一个更大元素 II(M)

[503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

### F1 扩充nums，取结果后在resize

resize是O(1)的操作，但扩充nums数组相当于多了一个O(n)的操作

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        // 拼接一个新的nums
        vector<int> nums1(nums.begin(), nums.end());
        nums.insert(nums.end(), nums1.begin(), nums1.end());
        // 用新的nums大小来初始化result
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result;

        // 开始单调栈
        stack<int> st;
        for (int i = 0; i < nums.size(); i++) {
            while (!st.empty() && nums[i] > nums[st.top()]) {
                result[st.top()] = nums[i];
                st.pop();
            }
            st.push(i);
        }
        // 最后再把结果集即result数组resize到原数组大小
        result.resize(nums.size() / 2);
        return result;
    }
};
```

### F2 遍历的过程中模拟走了两遍nums

遍历第二遍nums的时候就可以把差的那几个补上了

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result;
        stack<int> st;
        for (int i = 0; i < nums.size() * 2; i++) {
            // 模拟遍历两边nums，注意一下都是用i % nums.size()来操作
            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {
                result[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }   
        return result;
    }
};
```

错误思路：将stack里剩下的取出来，放到vector里，在给赋值，如剩下 1 2 3，就把result[1]、[2]都赋值为3。但显然是错的，3不一定是循环后的最大值
<img src="E:\MarkDown\picture\image-20230207180418728.png" alt="image-20230207180418728" style="zoom:50%;" />

## *42. 接雨水(~)*

[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

### F1 双指针

也算动态规划

此方法更简洁

记录当前位置i左侧和右侧的最大值，然后与i做差

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int size = height.size();
        vector<int> left(size, 0);  // i左边的最大值
        vector<int> right(size, 0);  // i右边的最大值
        int sum = 0;
        for (int i = 1; i < size; i++) {
            left[i] = max(left[i - 1], height[i - 1]);
        }
        for (int i = size - 2; i >= 0; i--) {
            right[i] = max(right[i + 1], height[i + 1]);
        }
        for (int i = 0; i < size; i++) {
            int tmp = min(left[i], right[i]);
            sum += max(0, tmp - height[i]);
        }
        return sum;
    }
};

```

### F2 单调栈

![image-20230208221023062](E:\MarkDown\picture\image-20230208221023062.png)

> 重点在于凹槽的宽，用下标的差来作为凹槽的宽，凹槽(min)左右柱子中较小的作为凹槽的高
>
> 单调栈内元素的顺序，从栈顶到栈底应为从小到大。如果一个元素比栈顶元素要小，就入栈，直到遇到比栈顶元素更大的元素就弹出，来计算凹槽
>
> 对于相同高度的柱子，需要更新栈内的下标，即将第一个柱子的下标弹出，将新的柱子添加到栈中

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.size() <= 2) return 0; // 可以不加
        stack<int> st; // 存着下标，计算的时候用下标对应的柱子高度
        st.push(0);
        int sum = 0;
        for (int i = 1; i < height.size(); i++) {
            if (height[i] < height[st.top()]) {     // 情况一
                st.push(i);
            } else if (height[i] == height[st.top()]) {  // 情况二
                st.pop(); // 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了
                st.push(i);
            } else {                                // 情况三
                while (!st.empty() && height[i] > height[st.top()]) { // 注意这里是while
                    int mid = st.top();
                    st.pop();
                    if (!st.empty()) {
                        int h = min(height[st.top()], height[i]) - height[mid];
                        int w = i - st.top() - 1; // 注意减一，只求中间宽度
                        sum += h * w;
                    }
                }
                st.push(i);
            }
        }
        return sum;
    }
};
```

## 84. 柱状图中最大的矩形

[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

### F1 单调栈

https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html#%E5%8D%95%E8%B0%83%E6%A0%88

再看看

### F2 动态规划/双指针

不怎么懂

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        vector<int> minLeftIndex(heights.size());
        vector<int> minRightIndex(heights.size());
        int size = heights.size();

        // 记录每个柱子 左边第一个小于该柱子的下标
        minLeftIndex[0] = -1; // 注意这里初始化，防止下面while死循环
        for (int i = 1; i < size; i++) {
            int t = i - 1;
            // 这里不是用if，而是不断向左寻找的过程
            while (t >= 0 && heights[t] >= heights[i]) t = minLeftIndex[t];
            minLeftIndex[i] = t;
        }
        // 记录每个柱子 右边第一个小于该柱子的下标
        minRightIndex[size - 1] = size; // 注意这里初始化，防止下面while死循环
        for (int i = size - 2; i >= 0; i--) {
            int t = i + 1;
            // 这里不是用if，而是不断向右寻找的过程
            while (t < size && heights[t] >= heights[i]) t = minRightIndex[t];
            minRightIndex[i] = t;
        }
        // 求和
        int result = 0;
        for (int i = 0; i < size; i++) {
            int sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - 1);
            result = max(sum, result);
        }
        return result;
    }
};
```



# 十四、图论

## 基础概念

> 最短路、最小生成树、网络流建模

[深度优先搜索dfs理论基础](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247505322&idx=1&sn=e19d2e111900a0c8fc2f8f012b0eedac&chksm=f9a1e6fbced66fedb2d83179e74390c7e4393dc2381a5760878bff25da2b347486488f23b34e&scene=178&cur_album_id=2683101719735697410#rd)

```cpp
vector<vector<int>> result; // 保存符合条件的所有路径
vector<int> path; // 起点到终点的路径
void dfs(图，目前搜索的节点) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```

[广度优先搜索BFS](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247505716&idx=1&sn=fa1ba42039a7ddbed406e25f5ac9bd74&chksm=f9a1e465ced66d734b56005477a5802d4e7de56719906761cd1637870a5f2feade02e7ac6487&scene=178&cur_album_id=2683101719735697410#rd)

更适合最短路径问题

<img src="E:\MarkDown\picture\image-20230211115732485.png" alt="image-20230211115732485" style="zoom:40%;" />

```cpp
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }
}
```

## 剑指 Offer 12. 矩阵中的路径

[剑指 Offer 12. 矩阵中的路径](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

dfs

```cpp
class Solution {
public:
    int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};
    bool dfs(vector<vector<char>>& board, string word, int tag, int a, int b) {
        if (a < 0 || a >= board.size() || b < 0 || b >= board[0].size()) return false;
        if (board[a][b] != word[tag]) return false;
        if (tag == word.size() - 1) return true;
        bool res = false;
        board[a][b] = '\0';
        for (int i = 0; i < 4; i++) {
            int x = a + dir[i][0];
            int y = b + dir[i][1];
            res = res || dfs(board, word, tag + 1, a + dir[i][0], b + dir[i][1]);
        }
        board[a][b] = word[tag];
        return res;
    }
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++) {
            for(int j = 0; j < board[0].size(); j++) {
                if(dfs(board, word, 0, i, j)) return true;
            }
        }
        return false;
    }
};
```



## 994. 腐烂的橘子

[994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

BFS

> * 统计新鲜橘子的数量，每次腐烂橘子就fresh--，就能知道是否能让所有橘子腐烂
> * 注意，不是每次while循环都是有效的，即不是每次while都能让橘子腐烂的。只有这次while循环确实让橘子烂了，才count++记录耗时。

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
        // 统计新鲜橘子数量及腐烂橘子坐标
        int fresh = 0;
        queue<pair<int, int>> que;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) fresh++;
                else if (grid[i][j] == 2) que.push({i, j});
            }
        }
        int count = 0;
        while (que.size()) {
            int size = que.size();
            bool tag = false;  // 重点！这个标志位来显示这层遍历是否有产生烂橘子
            for (int i = 0; i < size; i++) {
                auto tmp = que.front(); que.pop();
                for(auto cur : dir) {
                    int x = cur[0] + tmp.first;
                    int y = cur[1] + tmp.second;
                    if (x >= 0 && x <= m - 1 && y >= 0 && y <= n - 1 && grid[x][y] == 1) {
                        grid[x][y] = 2;
                        fresh--;
                        que.push({x, y});
                        tag = true;
                    }
                }
            }
            if (tag) count++;
        }
        if (fresh != 0) return -1;
        return count;
    }
};
```



## 797.所有可能的路径(M)

[797.所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/) [题解](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247505442&idx=1&sn=64b1cfd6ba3c1bb7a69543ca1210a4d9&chksm=f9a1e573ced66c657849ad9accf677e64ee1ac0f3d7219477046e41c2f52a51f47bd58a9f02b&scene=178&cur_album_id=2683101719735697410#rd)

### F1 DFS

```cpp
class Solution {
public:
    vector<vector<int>> result; // 保存符合条件的所有路径
    vector<int> path; // 起点到终点的路径
    void dfs(vector<vector<int>>& graph, int tag) {
        if (tag == graph.size() - 1) {
            result.push_back(path);
            return;
        }
        for (auto i : graph[tag]) {
            path.push_back(i);
            dfs(graph, i); // 递归
            path.pop_back();
        }
    }
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        path.push_back(0);
        dfs(graph, 0);
        return result;
    }
};
```

## *200. 岛屿数量(~)*

[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/) [题解](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247505787&idx=1&sn=285780abe0228bab9d3d5caa7c0b7e34&chksm=f9a1e42aced66d3c68b9d83696ebb3631acdaee7a8f3054489c02c3ef8de1fc04a6af914b7b6&cur_album_id=2683101719735697410&scene=189#wechat_redirect)

### DFS

自写

```cpp
class Solution {
public:
    int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
    int result = 0;
    void dfs(vector<vector<char>>& grid, int x, int y) {
        grid[x][y] = '0';
        for (int i = 0; i < 4; i++) {
            int a = x + dir[i][0];
            int b = y + dir[i][1];
            if (a < 0 || b < 0 || a >= grid.size() || b >= grid[0].size()) continue;
            if (grid[a][b] == '1') dfs(grid, a, b);
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        // dfs，遇到1结果就加一，然后将所有连接的都变为0
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == '1') {
                    result++;
                    dfs(grid, i, j);
                }
            }
        }
        return result;
    }
};
```

随想录版：麻烦

```cpp
class Solution {
public:
    // 定义方向
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    // dfs负责将以x y坐标为起始的岛屿内所有坐标都标记上1
    void dfs(vector<vector<char>>& grid, vector<vector<int>>& visited, int x, int y) {
        for (int i = 0; i < 4; i++) {
            int a = x + dir[i][0];
            int b = y + dir[i][1];
            if (a >= grid.size() || b >= grid[0].size() || a < 0 || b < 0) continue;
            if (visited[a][b] == 0 && grid[a][b] == '1') {
                visited[a][b] = 1;
                dfs(grid, visited, a, b);
            }
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        int h = grid.size();
        int w = grid[0].size();
        vector<vector<int>> visited(h, vector<int>(w, 0));
        int result = 0;
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                if (visited[i][j] == 0 && grid[i][j] == '1') {
                    result++;
                    visited[i][j] = 1;
                    dfs(grid, visited, i, j);
                }
            }
        }
        return result;
    }
};
```

### BFS

自写bfs

```cpp
class Solution {
public:
    // bfs
    int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
    int result = 0;
    void dfs(vector<vector<char>>& grid, int x, int y) {
        queue<pair<int, int>> que;
        que.push({x, y});
        grid[x][y] = '0';
        while (!que.empty()){
            pair<int, int> tmp = que.front(); que.pop();
            int m = tmp.first;
            int n = tmp.second;
            for (int i = 0; i < 4; i++) {
                int a = m + dir[i][0];
                int b = n + dir[i][1];
                if (a < 0 || b < 0 || a >= grid.size() || b >= grid[0].size()) continue;
                if (grid[a][b] == '1') {
                    que.push({a, b});
                    grid[a][b] = '0';
                }
            }
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == '1') {
                    result++;
                    dfs(grid, i, j);
                }
            }
        }
        return result;
    }
};
```

随想录版，麻烦

```CPP
class Solution {
public:
    // 定义方向
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    // 注意，只要加入队列，就进行标记
    void bfs(vector<vector<char>>& grid, vector<vector<int>>& visited, int x, int y) {
        queue<pair<int, int>> que;
        que.push({x, y});
        visited[x][y] == 1;
        while(!que.empty()) {
            pair<int, int> tmp = que.front();
            que.pop();
            int tmpx = tmp.first;
            int tmpy = tmp.second;
            for (int i = 0; i < 4; i++) {
                int a = tmpx + dir[i][0];
                int b = tmpy + dir[i][1];
                if (a < 0 || b < 0 || a >= grid.size() || b >= grid[0].size()) continue;
                if (!visited[a][b] && grid[a][b] == '1') {
                    que.push({a, b});
                    visited[a][b] = 1;
                }
            }
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        int h = grid.size();
        int w = grid[0].size();
        vector<vector<int>> visited(h, vector<int>(w, 0));
        int result = 0;
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                if (visited[i][j] == 0 && grid[i][j] == '1') {
                    result++;
                    bfs(grid, visited, i, j);
                }
            }
        }
        return result;
    }
};
```

## 695. 岛屿的最大面积

[695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/) [题解](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247505965&idx=1&sn=0a632013e27c41081162b3c5ccf24ff4&chksm=f9a1eb7cced6626a6e9d7616a7d7ef6dd423df675fb691ec789900cb02d4142f7a61bc638038&cur_album_id=2683101719735697410&scene=189#wechat_redirect)

### DFS

dfs只处理下一个节点，即在主函数遇到岛屿就计数为1，dfs处理接下来的相邻陆地

```cpp
class Solution {
public:
    // 定义方向
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    int result = 1;
    // dfs负责将以x y坐标为起始的岛屿内所有坐标都标记上1
    void dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int x, int y) {
        for (int i = 0; i < 4; i++) {
            int a = x + dir[i][0];
            int b = y + dir[i][1];
            if (a >= grid.size() || b >= grid[0].size() || a < 0 || b < 0) continue;
            if (visited[a][b] == 0 && grid[a][b] == 1) {
                result++;
                visited[a][b] = 1;
                dfs(grid, visited, a, b);
            }
        }
    }
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int tmp = 0;
        int h = grid.size();
        int w = grid[0].size();
        vector<vector<int>> visited(h, vector<int>(w, 0));
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                if (visited[i][j] == 0 && grid[i][j] == 1) {
                    visited[i][j] = 1;
                    dfs(grid, visited, i, j);
                    tmp = max(tmp, result);
                    result = 1;
                }
            }
        }
        return tmp;
    }
};
```

### BFS

```CPP
class Solution {
public:
    // 定义方向
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    int result = 1;
    void bfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int x, int y) {
        queue<pair<int, int>> que;
        que.push({x, y});
        while (!que.empty()) {
            pair<int, int> cur = que.front(); que.pop();
            int tmpx = cur.first;
            int tmpy = cur.second;
            for (int i = 0; i < 4; i++) {
                int a = tmpx + dir[i][0];
                int b = tmpy + dir[i][1];
                if (a >= grid.size() || b >= grid[0].size() || a < 0 || b < 0) continue;
                if (visited[a][b] == 0 && grid[a][b] == 1) {
                    result++;
                    visited[a][b] = 1;
                    que.push({a, b});
                }
            }
        }
        
    }
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int tmp = 0;
        int h = grid.size();
        int w = grid[0].size();
        vector<vector<int>> visited(h, vector<int>(w, 0));
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                if (visited[i][j] == 0 && grid[i][j] == 1) {
                    visited[i][j] = 1;
                    bfs(grid, visited, i, j);
                    tmp = max(tmp, result);
                    result = 1;
                }
            }
        }
        return tmp;
    }
};
```

## 1020. 飞地的数量(M)

[1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/) [题解](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247506132&idx=1&sn=3d2821cbdbfdb408390a4da1a7a0fe59&chksm=f9a1eb85ced662937726baf0122092e673394747a7598e59f1784013456c4b08c6c8bb58f74b&cur_album_id=2683101719735697410&scene=189#wechat_redirect)

思路：对边界处遍历一遍，遇到与边界相邻的1，就将其变为陆地；最后整个遍历，统计陆地个数

### DFS

```CPP
class Solution {
public:
    // 定义方向
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    int result = 0;
    // 遇到与边界相邻的1，就将其变为陆地
    void dfs(vector<vector<int>>& grid, int x, int y) {
        grid[x][y] = 0;
        result++;
        for (int i = 0; i < 4; i++) {
            int a = x + dir[i][0];
            int b = y + dir[i][1];
            if (a >= grid.size() || b >= grid[0].size() || a < 0 || b < 0) continue;
            if (grid[a][b] == 0) continue;
            dfs(grid, a, b);
        }
    }
    int numEnclaves(vector<vector<int>>& grid) {
        int h = grid.size();
        int w = grid[0].size();
        for (int i = 0; i < w; i++) {
            if (grid[0][i] == 1) dfs(grid, 0, i);
            if (grid[h - 1][i] == 1) dfs(grid, h - 1, i);
        }
        for (int i = 0; i < h; i++) {
            if (grid[i][0] == 1) dfs(grid, i, 0);
            if (grid[i][w - 1] == 1) dfs(grid, i, w - 1);
        }
        result = 0;
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                if (grid[i][j] == 1) {
                    dfs(grid, i, j);
                }
            }
        }
        return result;
    }
};
```

### BFS

仅需要将dfs函数换为bfs

```cpp
class Solution {
public:
    // 定义方向
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    int result = 0;
    // 遇到与边界相邻的1，就将其变为陆地
    void bfs(vector<vector<int>>& grid, int x, int y) {
        queue<pair<int, int>> que;
        que.push({x, y});
        grid[x][y] = 0;
        result++;
        while (!que.empty()) {
            pair<int, int> cur = que.front(); que.pop();
            int tmpx = cur.first;
            int tmpy = cur.second;
            for (int i = 0; i < 4; i++) {
                int a = tmpx + dir[i][0];
                int b = tmpy + dir[i][1];
                if (a >= grid.size() || b >= grid[0].size() || a < 0 || b < 0) continue;
                if (grid[a][b] == 0) continue;
                result++;
                grid[a][b] = 0;
                que.push({a, b});
            }
        }
    }
    int numEnclaves(vector<vector<int>>& grid) {
        int h = grid.size();
        int w = grid[0].size();
        for (int i = 0; i < w; i++) {
            if (grid[0][i] == 1) bfs(grid, 0, i);
            if (grid[h - 1][i] == 1) bfs(grid, h - 1, i);
        }
        for (int i = 0; i < h; i++) {
            if (grid[i][0] == 1) bfs(grid, i, 0);
            if (grid[i][w - 1] == 1) bfs(grid, i, w - 1);
        }
        result = 0;
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                if (grid[i][j] == 1) {
                    bfs(grid, i, j);
                }
            }
        }
        return result;
    }
};
```

## 130. 被围绕的区域

[130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) [题解](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247506306&idx=1&sn=7e4ec5f6f27253467c366e756b7e609f&chksm=f9a1ead3ced663c52ecf675e2441c113b9870aa139e5d21a517820e24202158f46b85b631a34&cur_album_id=2683101719735697410&scene=189#wechat_redirect)

与1020思路相同，先对边界处遍历，将与边界处相连的O都赋值为一个特殊值

之后再对整个区域进行遍历，将特殊值变O，将O变X

**DFS**

```cpp
class Solution {
public:
    // dfs
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    void dfs(vector<vector<char>>& board, int x, int y) {
        board[x][y] = 'Q';
        for (int i = 0; i < 4; i++) {
            int a = x + dir[i][0];
            int b = y + dir[i][1];
            if (a >= board.size() || b >= board[0].size() || a < 0 || b < 0) continue;
            if (board[a][b] == 'X' || board[a][b] == 'Q') continue;
            dfs(board, a, b);
        }
    }
    void solve(vector<vector<char>>& board) {
        int h = board.size();
        int w = board[0].size();
        for (int i = 0; i < w; i++) {
            if (board[0][i] == 'O') dfs(board, 0, i);
            if (board[h - 1][i] == 'O') dfs(board, h - 1, i);
        }
        for (int i = 0; i < h; i++) {
            if (board[i][0] == 'O') dfs(board, i, 0);
            if (board[i][w - 1] == 'O') dfs(board, i, w - 1);
        }
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                if (board[i][j] == 'Q') board[i][j] = 'O';
                else if (board[i][j] == 'O') board[i][j] = 'X';
            }
        }
    }
};
```

## *207.课程表(~)*

[207. 课程表](https://leetcode.cn/problems/course-schedule/)

**bfs/入度表/拓扑排序**

时间复杂度 O(N+M) 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；

<img src="E:\MarkDown\picture\image-20230302164432560.png" alt="image-20230302164432560" style="zoom:67%;" />
<img src="E:\MarkDown\picture\image-20230302164512671.png" alt="image-20230302164512671" style="zoom:67%;" />

用一个变量 count 记录入列的顶点个数，最后判断 count 是否等于总课程数，来判断是否修完所有课程

这里使用了map而不是二维数组，能节省一点空间

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> inDegree(numCourses);  // 入度数组
        unordered_map<int, vector<int>> map;  // key为课号，value为依赖这门课的后续课
        // 构建好入度数组inDegree和依赖关系map
        for (int i = 0; i < prerequisites.size(); i++) {
            inDegree[prerequisites[i][0]]++;  // 当前课程入度值+1
            map[prerequisites[i][1]].push_back(prerequisites[i][0]);  // 添加依赖他的后续课
        }
        // 将入度为0的课放入队列中
        // 因为每次只能选入度为 0 的课，因为它不依赖别的课，是当下能上的课
        queue<int> Qu;
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) Qu.push(i);//所有入度为0的课入列
        }
        int count = 0;
        while (Qu.size()) {
            int selected = Qu.front();Qu.pop();
            count++;  // 记录选课数
            vector<int> toEnQueue = map[selected];  // 获取这门课对应的后续课
            if (toEnQueue.size()) {
                for (auto i : toEnQueue) {
                    inDegree[i]--;
                    if (inDegree[i] == 0) Qu.push(i);  // 如果因此减为0，入列
                }
            }
        }
        if (count == numCourses) return true;
        return false;
    }
};
```

二维数组，只改动了一点

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> inDegree(numCourses);  // 入度数组
        vector<vector<int>> adjacents(numCourses);  // 第一个下标为课号，value为依赖这门课的后续课
        // 构建好入度数组inDegree和依赖关系map
        for (int i = 0; i < prerequisites.size(); i++) {
            inDegree[prerequisites[i][0]]++;  // 当前课程入度值+1
            adjacents[prerequisites[i][1]].push_back(prerequisites[i][0]);  // 添加依赖他的后续课
        }
        // 将入度为0的课放入队列中
        // 因为每次只能选入度为 0 的课，因为它不依赖别的课，是当下能上的课
        queue<int> Qu;
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) Qu.push(i);//所有入度为0的课入列
        }
        int count = 0;
        while (Qu.size()) {
            int selected = Qu.front();Qu.pop();
            count++;  // 记录选课数
            vector<int> toEnQueue = adjacents[selected];  // 获取这门课对应的后续课
            if (toEnQueue.size()) {
                for (auto i : toEnQueue) {
                    inDegree[i]--;
                    if (inDegree[i] == 0) Qu.push(i);  // 如果因此减为0，入列
                }
            }
        }
        if (count == numCourses) return true;
        return false;
    }
};
```

## 210. 课程表 II

[210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

仅增加了个result

```cpp
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> result;
        vector<int> inDegree(numCourses);  // 入度数组
        unordered_map<int, vector<int>> map;  // key为课号，value为依赖这门课的后续课
        // 构建好入度数组inDegree和依赖关系map
        for (int i = 0; i < prerequisites.size(); i++) {
            inDegree[prerequisites[i][0]]++;  // 当前课程入度值+1
            map[prerequisites[i][1]].push_back(prerequisites[i][0]);  // 添加依赖他的后续课
        }
        // 将入度为0的课放入队列中
        // 因为每次只能选入度为 0 的课，因为它不依赖别的课，是当下能上的课
        queue<int> Qu;
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) Qu.push(i);//所有入度为0的课入列
        }
        int count = 0;
        while (Qu.size()) {
            int selected = Qu.front();Qu.pop();
            result.push_back(selected);
            count++;  // 记录选课数
            vector<int> toEnQueue = map[selected];  // 获取这门课对应的后续课
            if (toEnQueue.size()) {
                for (auto i : toEnQueue) {
                    inDegree[i]--;
                    if (inDegree[i] == 0) Qu.push(i);  // 如果因此减为0，入列
                }
            }
        }
        if (count == numCourses) return result;
        return vector<int>();
    }
};
```



## 417.太平洋大西洋水流问题

[417.太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/) [题解](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247506496&idx=1&sn=a5828a57a26020ad039d46dcf94c2f5f&chksm=f9a1e911ced6600736847e93ee06d1d60848f4cdea4f8b4d9bea4ac4288bb4921a6b81aba737&cur_album_id=2683101719735697410&scene=189#wechat_redirect)



# 十五、力扣HOT100

> 按codetop的频率排序

## 206/BM1.反转链表

## 146.LRU 缓存

[146.LRU 缓存](https://leetcode.cn/problems/lru-cache/) [思路参考这个](https://leetcode.cn/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/)

请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构。
实现 LRUCache 类：

* LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
* int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
* void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。

函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

<img src="E:\MarkDown\picture\image-20230211195100023.png" alt="image-20230211195100023" style="zoom:50%;" />

> * list双向链表：
>   	删除操作需要操作节点本身的指针和其前驱节点的指针，因此双向链表才能实现删除操作的O(1)复杂度
> * list<pair<int, int>> 用链表存放key和value
> * unordered_map<int, list<pair<int, int>>::iterator> 用map存放key和链表中与这个key对应的pair 的迭代器，实现O(1)的查找
> * 因此需要值时就用*map[key]，需要迭代器时(如链表想erase)就用map[key]

```cpp
class LRUCache {
    int size;  // 容量
    list<pair<int, int>> cache;  // 链表中存放着key-value
    // 重点，map中存放的是key和对应链表的迭代器
    unordered_map<int, list<pair<int, int>>::iterator> map;
public:
    LRUCache(int capacity):size(capacity) {}
    
    int get(int key) {
        if (map.find(key) == map.end()) return -1;
        // map[key]中存放的是迭代器，解引用出来的就是链表中的一个pair
        auto key_value = *map[key];  // 注意，这里要先保存一下，因为后面mapp[key]指向的迭代器会被删掉
        // 更新
        // 使用迭代器进行删除操作，省略了查找步骤，复杂度O(1)
        cache.erase(map[key]);
        cache.push_front(key_value);
        map[key] = cache.begin();  // 更新Key对应的迭代器
        return key_value.second;
    }
    void put(int key, int value) {
        if (map.find(key) != map.end()) {
            cache.erase(map[key]);
        } else {
            if (cache.size() == size) {
                // map的erase和find的形参都是int
                map.erase(cache.back().first);
                cache.pop_back();
            }
        }
        cache.push_front({key, value});
        map[key] = cache.begin();
    }
    /*
    // 写法2
    void put(int key, int value) {
        if (mapp.find(key) != mapp.end()) {  // 已存在
            // 变更数据值
            (*mapp[key]).second = value;
            get(key);  // 更新位置
        } else {
            // 插入
            cache.push_front({key, value});
            mapp[key] = cache.begin();
            if (cache.size() > size) {
                int tmp = cache.back().first;
                mapp.erase(tmp);
                cache.pop_back();
            }
        }
    }
    */
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

## 3.无重复字符的最长子串

[3.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

## 215.数组中的第K个最大元素

[215.数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

> 请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。比如 1 5 5。因此遍历第一遍找最大值，遍历第二遍并使nums[i]!=max的思路是错误的

### 三路快排

时间复杂度优化后为O(n)
证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」

![image-20230213150226185](E:\MarkDown\picture\image-20230213150226185.png)

优化：

* cur的位置(或者说gt的位置)是倒数第k个元素，即第k大的元素
* 因此如果cur = nums.size() - k，就已经找到了，直接返回
* 若cur > nums.size() - k，则遍历左边的；否则遍历右边的

```cpp
class Solution {
public:
int partition3(vector<int>& nums, int left, int right, int k) {
    // 排序终止，直接返回
	if (left >= right) return nums[k];
	// 随机选择哨兵，不加的话在原数组有序时会超时
	swap(nums[rand() % (right - left + 1) + left], nums[right]);
    int pivot = nums[right];
    // lt和gt指向最后一个小于/大于v的数
    int lt = left - 1;
    int gt = right;
    int cur = left;  // 当前遍历位置
    while (cur < gt) {
		if (nums[cur] < pivot) {
			swap(nums[cur], nums[lt + 1]);
			cur++; lt++;
		}
		else if (nums[cur] > pivot) {
			swap(nums[cur], nums[gt - 1]);
			// 注意，这里cur不能动，因为只是把大于pivot的交换到后面去了，交换到cur的这个是未判断的
			// cur++;
			gt--;
		} else {
			cur++;
		}
    }
    swap(nums[right], nums[gt]);
    // 对此题进行优化
    if (gt == k) return nums[gt];
    else if (gt > k) return partition3(nums, left, lt, k);  // 这里选择lt或gt-1都是可以通过的
    else return partition3(nums, gt + 1, right, k);
}

    int findKthLargest(vector<int>& nums, int k) {
        return partition3(nums, 0, nums.size() - 1, nums.size() - k);
    }
};
```

### 双路快排

```cpp
// pivot选在最右边
int partition2(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    // 随机选择哨兵
    swap(nums[left], nums[rand() % (right - left + 1) + left]);
    int pivot = nums[right];
    int i = left;
    int j = right - 1;
    while (true) {
		while(nums[i] < pivot && i <= right - 1) i++;
		while(j >= left && nums[j] > pivot) j--;
		if (i > j) break;
		swap(nums[i], nums[j]);
		i++;
		j--;
    }
    swap(nums[right], nums[i]);
    // i为当前遍历位置
    partition2(nums, left, i - 1);
    partition2(nums, i + 1, right);
}
```

双路快排参考

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n=nums.size();
        int le=0, ri=n-1;
        while(true){  
            //快排框架
            int i=le, j=ri;
            int idx = rand() % (ri - le +1) + le;//随机选择pivot
            swap(nums[le], nums[idx]);
            while(i<j){
                while(i<j&&nums[j]>=nums[le]) --j;
                while(i<j&&nums[i]<=nums[le]) ++i;
                swap(nums[i], nums[j]);
            }
            swap(nums[i], nums[le]);//nums[le]应处的位置在索引i处

            if(i==n-k) return nums[i];//若恰为倒数第K的位置
            else if(i>n-k) ri=i-1;//将查找范围放在该位置左侧
            else le=i+1;//将查找范围放在该位置右侧
        }
    }
};
```



快速排序的分区思想，快排的思想是一次找出一个数的正确位置，并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。

```cpp
class Solution {
public:
    void quickPartition(vector<int>& nums, int start, int end, int target) {
        // 随机取一个数作为基准
        srand(time(nullptr));
        int random = rand() % (end - start + 1) + start;
        int base = nums[random];
        // 将该数放到待快排区间开头第一个元素
        swap(nums[start], nums[random]);
        int index = start;
        // 从待快排区间的第二个元素开始，依次与base比较，如果大于等于base则将该元素
        // 交换到index + 1位置，index++，使得最终index前面的元素都比base大。
        for (int i = start + 1; i <= end; ++i) {
            if (nums[i] >= base) {
                swap(nums[index + 1], nums[i]);
                index++;
            }
        }
        // base存放在区间开头，现在需要把它交换到index位置，这就是它在整个有序数组中的位置。
        swap(nums[index], nums[start]);
	
        // 如果index小于target，需要在右边区间继续快排查找，否则到在边区间查找，
        // 如果等于已经找到目标值不需要递归，这里这么做优化了传统快排的复杂度。
        if (index < target) {
            quickPartition(nums, index + 1, end, target);
        }
        else if (index > target) {
            quickPartition(nums, start, index - 1, target);
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        quickPartition(nums, 0, nums.size() - 1, k - 1);
        return nums[k - 1];
    }
};
```

### 堆

> 优先队列priority_queue，队头到队尾单调递减，默认是**大顶堆**
>
> 允许在O(lgN)时间复杂度下插入数据，在O(1)时间复杂度下取得容器内最大最小值
>
> 底层实现是堆（一种特殊的二叉树）

#### 容器实现

大顶堆(降序)

<img src="E:\MarkDown\picture\image-20230212095619779.png" alt="image-20230212095619779" style="zoom:50%;" />

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> que;
        for (int i = 0; i < nums.size(); i++) {
            que.push(nums[i]);
        }
        for (int i = 0; i < k - 1; i++) {
            que.pop();
        }
        return que.top();
    }
};
```

小顶堆

<img src="E:\MarkDown\picture\image-20230212100350629.png" alt="image-20230212100350629" style="zoom:50%;" />

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        // 小顶堆，维持小顶堆中的k个数是最大的k个
        priority_queue<int,vector<int>,greater<int>> que;
        for (auto i : nums) {
            // 堆大小到k后，若插入的小于堆顶，就不管；若大于堆顶，则弹出堆顶，把更大的加上
            if (que.size() == k && i <= que.top()) continue;
            else if (que.size() == k && i > que.top()) {
                que.pop();
            }
            que.push(i);
        }
        return que.top();
    }
};
```

#### 手撕

> 这里采用了两种不同的思路
>
> 小顶堆这里采用的是创建了一个k个元素的数组，维持它，最后数组中就是k个最大的，栈顶就是k个元素里最小的
>
> 大顶堆这里采用的是调整k次，得到的值就是需要的元素

小顶堆

```cpp
class Solution {
public:
    // 小顶堆，将大的不断下沉到最后(即最右)
    void adjustHeap(vector<int>& hp, int idx) {
        for (int i = idx; i * 2 + 1 < hp.size();) {
            // i就是根节点索引，t为zuo孩子索引
            int t = i * 2 + 1;
            // 若右孩子存在且小于左孩子，则t变为右孩子的索引
            if (t + 1 < hp.size() && hp[t + 1] < hp[t]) t++;
            // 如果根节点的值小于右孩子，则不管
            if (hp[i] < hp[t]) break;
            // 若父节点大于右孩子，则交换
            swap(hp[i], hp[t]);
            i = t;
        }
    }
    // 建立一个小顶堆
    void buildHeap(vector<int>& hp) {
        // 从最后一个有叶子的父节点开始遍历(如7个节点，则 0 1 2为有叶子的父节点，5个节点，则 0 1)
        for (int i = hp.size() / 2 - 1; i >= 0; i--) adjustHeap(hp, i);
    }
    int findKthLargest(vector<int>& nums, int k) {
        // 从nums中取k个元素
        vector<int> vec(nums.begin(), nums.begin() + k);
        buildHeap(vec);
        for (int i = k; i < nums.size(); i++) {
            // 比堆顶(堆中最小的元素)小，则抛弃
            if (nums[i] < vec[0]) continue;
            // 否则就将其作为堆顶，然后下沉
            vec[0] = nums[i];
            adjustHeap(vec, 0);
        }
        return vec[0];
    }
};
```

大顶堆实现单调递增

```cpp
class Solution {
public:
    // 堆排，大顶堆实现单调递增
    // 调整堆
    void adjust(vector<int>& nums, int index, int size) {
        for (int i = index; i * 2 + 1 < size;) {  // 有左孩子
            int t = i * 2 + 1;
            if (t + 1 < size && nums[t + 1] > nums[t]) t++;
            if (nums[i] > nums[t]) break;
            swap(nums[i], nums[t]);
            i = t;
        }
    }
    int findKthLargest(vector<int>& nums, int k) {
        // 建堆，从最后一个有孩子的结点开始
        for (int i = nums.size() / 2 - 1; i >= 0; i--) {
            adjust(nums, i, nums.size());
        }
        // 排序
        int size = nums.size();
        while (size > nums.size() - k) {
            swap(nums[0], nums[--size]);
            adjust(nums, 0, size);
        }
        return nums[nums.size() - k];
    }
};
```



### 暴力

时间复杂度：O(Nlog⁡N)，这里N是数组的长度，算法的性能消耗主要在排序，std默认使用快速排序，因此时间复杂度为 O(Nlog⁡N)。「快速排序」虽然快，但是「快速排序」在遇到特殊测试用例（「顺序数组」或者「逆序数组」）的时候，递归树会退化成链表，时间复杂度会变成O(N^2)。
空间复杂度：O(logN)，这里认为编程语言使用的排序方法是「快速排序」，空间复杂度为递归调用栈的高度，为log⁡N

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int findKthLargest(vector<int> &nums, int k) {
        int size = nums.size();
        sort(begin(nums), end(nums));
        return nums[size - k];
    }
};
```

## 15.三数之和

## 21.合并两个有序链表

[21.合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) [剑指 Offer 25. 合并两个排序的链表](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

### 递归

![image-20230213180358787](E:\MarkDown\picture\image-20230213180358787.png)

```cpp
class Solution {
public:
    // 递归
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (list1 == nullptr) return list2;
        else if (list2 == nullptr) return list1;
        else if (list1->val < list2->val) {
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        } else {
            list2->next = mergeTwoLists(list1, list2->next);
            return list2;
        }
    }
};
```

### 双指针

```cpp
class Solution {
public:
    // 双指针
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 一定要new一个链表，否则没有指向
        ListNode* resultNode = new ListNode(-1);
        ListNode* resNode = resultNode;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                resultNode->next = list1;
                list1 = list1->next;
            } else {
                resultNode->next = list2;
                list2 = list2->next;
            }
            resultNode = resultNode->next;
        }
        resultNode->next = list1 ? list1 : list2;
        return resNode->next;
    }
};
```

## 33. 搜索旋转排序数组

[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

**二分查找**

将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的

![image-20230213194706935](E:\MarkDown\picture\image-20230213194706935.png)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int mid, left = 0, right = nums.size() - 1;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            if (nums[mid] >= nums[left]) { // 左边有序
                if (target >= nums[left] && target < nums[mid]) right = mid - 1;
                else left = mid + 1;
            } else if (nums[mid] < nums[left]) {  // 右边有序
                if (target > nums[mid] && target <= nums[right])  left = mid + 1;
                else right = mid - 1;
            }
        }
        return -1;
    }
};
```

时间复杂度： O(log⁡n)，其中 n 为 nums 数组的大小。整个算法时间复杂度即为二分查找的时间复杂度 O(log⁡n)

写成递归，麻烦点：

```cpp
class Solution {
public:
    int aa(vector<int>& nums, int left, int right, int target) {
        if (left == right) {
            if (nums[left] == target) return left;
            else return -1;
        }
        if (left > right) return -1;
        int mid = (left + right) / 2;
        if (nums[mid] >= nums[left]) {  // 左侧递增
            if (nums[mid] >= target && nums[left] <= target) return aa(nums, left, mid, target);
            else return aa(nums, mid + 1, right, target);
        } else {  // 右侧递增
            if (nums[mid] <= target && nums[right] >= target) return aa(nums, mid, right, target);
            else return aa(nums, left, mid - 1, target);
        }
    }
    int search(vector<int>& nums, int target) {
        // 将数组二分，一定有一部分是有序递增的
        return aa(nums, 0, nums.size() - 1, target);
    }
};
```



## 23. 合并K个升序链表

## 102.二叉树的层序遍历

## 236.二叉树的最近公共祖先

## 160. 相交链表

## 5.最长回文子串

## BM6 判断链表中是否有环/141.环形链表

## 53.最大子数组和

## 42.接雨水

## 121.买卖股票的最佳时机

## 200.岛屿数量

## 46.全排列

## 1.两数之和

## 31.下一个排列

[31.下一个排列](https://leetcode.cn/problems/next-permutation/)

> 如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。
>
> ![image-20230215210011607](E:\MarkDown\picture\image-20230215210011607.png)

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int j = nums.size() - 1, i = j - 1;
        while (i >= 0) {
            if (nums[i] < nums[j]) break;
            i--; j--;
        } 
        int k = i;
        if (i >= 0) {
            for (k = nums.size() - 1; k >= j ; k--) {
                if (nums[i] < nums[k]) break;
            }
            swap(nums[i], nums[k]);
            // sort(nums.begin() + j, nums.end());
            // reverse时间复杂度更低，O(N)
            reverse(nums.begin() + j, nums.end());
        } else {
            reverse(nums.begin(), nums.end());
            // sort(nums.begin(), nums.end());
        }
    }
};
```

## 124.二叉树中的最大路径和

[124.二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

![image-20230215212353265](E:\MarkDown\picture\image-20230215212353265.png)

> 当前子树能向上提供的最大路径和有三种情况：
>
> * 根节点
> * 根节点+左子树
> * 根节点+右子树
>
> 这就作为我们递归的返回值
>
> 同时，我们也需要计算当前子树的路径和：left + right + root->val，因为可能本子树就最大了，或者还得继续向上探索

```CPP
class Solution {
public:
    int result = INT_MIN;  // 最大路径和
    int aa(TreeNode* root) {
        if (root == nullptr) return 0;
        int left = aa(root->left);
        int right = aa(root->right);
        int curTree = left + right + root->val;  // 当前子树内的路径和
        result = max(result, curTree);
        // 若大于0，子树作为一个分支继续向上传递
        int curBranch = max({0, left, right}) + root->val;
        return ((curBranch > 0) ? curBranch : 0);
    }
    int maxPathSum(TreeNode* root) {
        aa(root);
        return result;
    }
};
```

## 142.环形链表 II

## 148.排序链表

[148.排序链表](https://leetcode.cn/problems/sort-list/)

递归法，时间复杂度可以满足O(nlogn)，但因为使用了递归，空间复杂度为O(logn)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        // fast = head->next时对偶数个才能均分
        ListNode* fast = head->next, *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        // 注意，分解后是两个无序的链表，不能直接用《合并两个排序的链表》
        ListNode* node = slow->next;
        slow->next = nullptr;
        ListNode* firN = sortList(head);
        ListNode* secN = sortList(node);
        return merge(firN, secN);
        
    }
    ListNode* merge(ListNode* firN, ListNode* secN) {
        // 对两个链表进行排序合并
        ListNode* tmp = new ListNode(-1);
        ListNode* result = tmp;
        while (firN && secN) {
            if (firN->val < secN->val) {
                tmp->next = firN;
                firN = firN->next;
            } else {
                tmp->next = secN;
                secN = secN->next;
            }
            tmp = tmp->next;
        }
        tmp->next = firN ? firN : secN;
        return result->next;
    }
};
```

合在一起的写法

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        // fast = head->next时对偶数个才能均分
        ListNode* fast = head->next, *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        // 注意，分解后是两个无序的链表，不能直接用《合并两个排序的链表》
        ListNode* node = slow->next;
        slow->next = nullptr;
        ListNode* firN = sortList(head);
        ListNode* secN = sortList(node);
        
        // 到这里就是对两个链表进行排序了
        ListNode* tmp = new ListNode(-1);
        ListNode* result = tmp;
        while (firN && secN) {
            if (firN->val < secN->val) {
                tmp->next = firN;
                firN = firN->next;
            } else {
                tmp->next = secN;
                secN = secN->next;
            }
            tmp = tmp->next;
        }
        tmp->next = firN ? firN : secN;
        return result->next;
    }
};
```

**迭代法**

空间复杂度O(1)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        ListNode* node = new ListNode(-1);
        node->next = head;
        // 统计链表长度
        int length = 0;
        ListNode* tmp = head;
        while (tmp) {
            length++;
            tmp = tmp->next;
        }
        for (int size = 1; size < length; size = size * 2) {
            ListNode* cur = node->next;
            ListNode* tail = node;  // tail将合并好的更新到node上
            while (cur) {
                // 每次切两部分下来，进行合并
                ListNode* left = cur;  // 左部分起始结点
                ListNode* right = split(cur, size);  // 右部分
                cur = split(right, size);  // 剩下的
                tail->next = merge(left, right);
                while (tail->next) {
                    tail = tail->next;
                }
            }
        }
        return node->next;
    }
    // 将node切出来step
    ListNode* split(ListNode* node, int step) {
        if (node == nullptr) return node;
        ListNode* tmp = node;
        for (int i = 0; i < step - 1; i++) {
            if (node->next == nullptr) break;
            node = node->next;
        }
        ListNode* right = node->next;  // 下个链表的表头
        node->next = nullptr;  // 分割
        return right;

    }
    // 对两个链表进行排序合并
    ListNode* merge(ListNode* firN, ListNode* secN) {
        ListNode* tmp = new ListNode(-1);
        ListNode* result = tmp;
        while (firN && secN) {
            if (firN->val < secN->val) {
                tmp->next = firN;
                firN = firN->next;
            } else {
                tmp->next = secN;
                secN = secN->next;
            }
            tmp = tmp->next;
        }
        tmp->next = firN ? firN : secN;
        return result->next;
    }
};
```

## 300.最长上升子序列

## 20.有效的括号

## 2.两数相加

[2.两数相加](https://leetcode.cn/problems/add-two-numbers/)

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* node = new ListNode(-1);
        ListNode* result = node;
        int tmp = 0;
        while (l1 || l2) {
            int val = tmp;
            if (l1) val += l1->val;
            if (l2) val += l2->val;
            node->next = new ListNode(val % 10);
            tmp = val / 10;
            node = node->next;
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }
        if (tmp) node->next = new ListNode(tmp);
        return result->next;
    }
};
```

## 19.删除链表的倒数第 N 个结点

## 22.括号生成

[22.括号生成](https://leetcode.cn/problems/generate-parentheses/)

**递归**

> left和right为剩下的左右括号数量
>
> 默认前提：left小于等于right才能形成有效的答案

```cpp
class Solution {
public:
    // left和right为剩下的左右括号数量
    vector<string> result;
    void aa(string s, int left, int right) {
        // 终止条件
        if (left == 0 && right == 0) {
            result.push_back(s);
            return;
        }
        // 如果剩下的左右括号数量相等，则下一个必须为左括号
        if (left == right) {
            aa(s + '(', left - 1, right);
        } else {  // else if (left < right)  // 下一个可以是左括号，也可以是右括号
            if (left > 0) aa(s + '(', left - 1, right);
            // 这里是递归！因此这样写可以递归两种情况
            aa(s + ')', left, right - 1);
        }
    }
    vector<string> generateParenthesis(int n) {
        aa("", n, n);
        return result;
    }
};
```

**深度优先遍历**

与递归方法的区别在于，递归法是递归正确的可能，dfs是遍历所有的可能，并剔除一些不满足的结果

![image-20230216163549923](E:\MarkDown\picture\image-20230216163549923.png)

```cpp
class Solution {
public:
    // dfs
    // left和right为剩下的左右括号数量
    // left必须小于等于right
    vector<string> result;
    void aa(string s, int left, int right) {
        if (left == 0 && right == 0) {
            result.push_back(s);
            return;
        }
        if (left > right) return;
        if (left > 0) aa(s + '(', left - 1, right);
        if (right > 0) aa(s + ')', left, right - 1);
    }
    vector<string> generateParenthesis(int n) {
        aa("", n, n);
        return result;
    }
};
```

## 56.合并区间

## 4.寻找两个正序数组的中位数(*没看懂*)

[4.寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

思路1：就是给两个数组排序，然后取中间的

O(m + n)

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int i = 0, j = 0, z= 0;
        int size1 = nums1.size(), size2 = nums2.size();
        vector<double> vec(size1 + size2);
        while (i < size1 && j < size2) {
            if (nums1[i] < nums2[j]) vec[z++] = nums1[i++];
            else vec[z++] = nums2[j++];
        }
        if (i == size1 && j < size2) {
            for (; j < size2; j++) vec[z++] = nums2[j];
        } else {
            for (; i < size1; i++) vec[z++] = nums1[i];
        }
        int size = size1 + size2;
        if (size % 2 == 1) return vec[size / 2];
        else return vec[size / 2] / 2 + vec[size / 2 - 1] / 2;
    }
};
```

思路2：两个数组是有序的，我们只需要遍历到len / 2 + 1处即可，并且可以不用创建数组，用俩标志位即可。但时间复杂度O((m + n) / 2)

思路3：找中位数，即找第k大的数。

> 比如size = 5，则中位数为k = 5/2= 2，即找第2大的数
>
> 同时看两个数组k/2的位置，如果A>B，则B左边的不符合要求，删掉，k = k - (k/2)
>
> https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/

```cpp
class Solution {
public:
    /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 "/" 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */
    int aa(vector<int>& nums1, vector<int>& nums2, int k) {
        int m = nums1.size(), n = nums2.size();
        int i = 0, j = 0;
        while (true) {
            if (i == m) return nums2[j + k - 1];
            if (j == n) return nums1[i + k - 1];
            if (k == 1) return min(nums1[i], nums2[j]);
            // 正常情况
            int newIndex1 = min(i + k / 2 - 1, m - 1);
            int newIndex2 = min(j + k / 2 - 1, n - 1);
            if (nums1[newIndex1] <= nums2[newIndex2]) {
                k -= newIndex1 - i + 1;
                i = newIndex1 + 1;
            }
            else {
                k -= newIndex2 - j + 1;
                j = newIndex2 + 1;
            }
        }
    }
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```



## 76.最小覆盖子串

## 94.二叉树的中序遍历

## 78.子集

## 105.从前序与中序遍历序列构造二叉树

## 155.最小栈

[155.最小栈](https://leetcode.cn/problems/min-stack/)

> 额外维持一个栈，里面保存着当前元素对应的最小元素min(minSt.top(), val)

```cpp
class MinStack {
public:
    stack<int> st;
    stack<int> minSt;
    MinStack() {
    }
    // 每放入一个元素，就同时更新minSt，使其栈顶总是最小的
    void push(int val) {
        st.push(val);
        if (minSt.empty()) minSt.push(val);
        else minSt.push(min(minSt.top(), val));
    }

    void pop() {
        st.pop();
        minSt.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return minSt.top();
    }
};
```

## 98.验证二叉搜索树

## 32.最长有效括号(*)

[32.最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

错误方法：读错题，以为必须()才行，但其实**(())也可以**

```cpp
class Solution {
public:
    // 维持一个stack，如果放入左，栈顶必须为空或为右
    // 如果放入右，则栈顶必须是左
    int longestValidParentheses(string s) {
        if (s.size() == 0) return 0;
        stack<char> st;
        int result = 0;
        for (auto i : s) {
            if (i == '(') {
                if (st.empty() || st.top() == ')') st.push(i);
                else {
                    int size = st.size();
                    result = max(result, size);
                    while (!st.empty()) {
                        st.pop(); 
                    }
                    st.push(i);
                }
            } else {
                if (st.empty()) continue;
                if (st.top() == '(') st.push(i);
                else {
                    int size = st.size();
                    result = max(result, size);
                    while (!st.empty()) {
                        st.pop(); 
                    }
                }
            }
        }
        if (!st.empty() && st.top() == ')') {
            int size = st.size();
            result = max(result, size);
        }
        return result;
    }
};
```

**栈**

> * 维持一个stack，保存下标，通过下标计算长度
> * st.push(-1)，表示最后一个没有被匹配的右括号的下标是-1
> * 在程序中的意义，是因为右括号的情况会先st.pop()，若只有-1，被弹出，则说明没有对应左括号；若有左括号，则弹出左括号，剩下-1方便进行下标的计算
> * 左括号直接放入下标
> * 右括号的话，先出栈
>   * 如果是空栈，则放入栈中，表示**最后一个没有被匹配的右括号的下标**
>   * 若不是空栈，表示匹配，然后下标-栈顶下标就是当前括号为结尾的最长有效字串（如()是2，(())的话中间俩抵消了，就是()，弹出后栈中就一个-1，下标计算为3 - -1 = 4

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        int result = 0;
        st.push(-1);  // 对应()的情况
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
                st.push(i);
            } else {
                st.pop();
                if (st.empty()) st.push(i);
                else result = max(result, i - st.top());
            }
        }
        return result;
    }
};
```

**贪心**

空间复杂度为0

> 首先，从左到右遍历字符串，对于遇到的每个‘(’增加 left，对于')'增加right。left与right相等时，计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当right比left大时，将left和 right同时变回0
>
> 但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 `(()` ，这种时候最长有效括号是求不出来的。因此需要反着再来一遍

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        int left = 0, right = 0;
        int result = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') left++;
            else right++;
            if (left == right) result = max(result, 2 * left);
            if (left < right) {
                left = 0; right = 0;
            }
        }
        left = 0, right = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] == ')') right++;
            else left++;
            if (left == right) result = max(result, 2 * left);
            if (left > right) {
                left = 0; right = 0;
            }
        }
        return result;
    }
};
```

## 234.回文链表

[234.回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

**快慢指针**

时间复杂度O(n)，空间复杂度O(1)

> 通过快慢指针将前半段链表反序，然后与后半段链表比较是否相等

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* fast = head, *slow = head;
        // cur为反序链表的头结点
        ListNode* cur, *tmp = nullptr;
        while (fast != nullptr && fast->next != nullptr) {
            cur = slow;
            fast = fast->next->next;
            slow = slow->next;
            cur->next = tmp;
            tmp = cur;
        }
        // 如果fast不是null，说明是奇数个结点，slow需要再往后移一位，作为后半段正序链表的起点
        if (fast != nullptr) slow = slow->next;
        while (slow) {
            if (cur->val != slow->val) return false;
            slow = slow->next;
            cur = cur->next;
        }
        return true;
    }
};
```

## 322.零钱兑换

## 239.滑动窗口最大值

## 101.对称二叉树

## 70.爬楼梯

## 72.编辑距离

## 543.二叉树的直径

[543.二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

递归，返回值为子树的最大深度，统计值为子树的最大长度

```cpp
class Solution {
public:
    int result = 0;
    // 统计和返回的都是结点数
    int aa(TreeNode* node) {
        if (node == nullptr) return 0;
        int left = aa(node->left);
        int right = aa(node->right);
        result = max(result, left + right + 1);
        return max(left, right) + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        aa(root);
        return result - 1;
    }
};
```

## 128.最长连续序列

[128.最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

**动规**

![image-20230219194703943](E:\MarkDown\picture\image-20230219194703943.png)

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int result = 0;
        int left, right, length;
        unordered_map<int, int> map;
        for (int i : nums) {
            if (!map[i]) {
                left = map[i - 1];
                right = map[i + 1];
                length = left + right + 1;
                result = max(result, length);
                map[i] = length;
                // 重点，通过left和right更新
                map[i - left] = length;
                map[i + right] = length;
            }
        }
        return result;
    }
};
```

unordered_map

时间复杂度为O(n)，通过循环中的if判定，很多元素在遍历时并没有被访问，仅在if判定成功后在while中循环一遍

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int result = 0;
        unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (map[nums[i] - 1] != 1) {
                int sum = 0;
                int cur = nums[i];
                while (map[cur++]) {
                    sum++;
                }
                result = max(result, sum);
            }
        }
        return result;
    }
};
```

unordered_set

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int result = 0;
        unordered_set<int> set;
        for (int i = 0; i < nums.size(); i++) {
            set.insert(nums[i]);
        }
        for (int i = 0; i < nums.size(); i++) {
            if (!set.count(nums[i] - 1)) {
                int sum = 0;
                int cur = nums[i];
                while (set.count(cur)) {
                    sum++;
                    cur++;
                }
                result = max(result, sum);
            }
        }
        return result;
    }
};
```

## 221.最大正方形

[221.最大正方形](https://leetcode.cn/problems/maximal-square/)

**动态规划**

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        // 动态规划，dp[i + 1][j + 1]是以matrix[i][j]为右下角的正方形的最大边长
        // dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
        int result = 0;
        vector<vector<int>> dp(matrix.size() + 1, vector<int>(matrix[0].size() + 1, 0));
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                if (matrix[i][j] == '1') {
                    dp[i + 1][j + 1] = min({dp[i][j + 1], dp[i + 1][j], dp[i][j]}) + 1;
                    result = max(result, dp[i + 1][j + 1]);
                }
            }
        }
        return result * result;
    }
};
```

简化到一维

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        // 动态规划，dp[i + 1][j + 1]是以matrix[i][j]为右下角的正方形的最大边长
        // dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
        int result = 0;
        vector<int> dp(matrix[0].size() + 1, 0);
        for (auto m : matrix) {
            int tmp = 0;  // 记录dp[i][j]，即左上的位置
            for (int j = 0; j < matrix[0].size(); j++) {
                // 不断向右遍历，dp[j + 1]才对应dp[i][j]
                int tag = dp[j + 1];
                if (m[j] == '1') {
                    dp[j + 1] = min({dp[j + 1], dp[j], tmp}) + 1;
                    result = max(result, dp[j + 1]);
                } else {
                    // 一维，必须用0覆盖
                    dp[j + 1] = 0;
                }
                tmp = tag;
            }
        }
        return result * result;
    }
};
```

## 104.二叉树的最大深度

## 64.最小路径和

[64.最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

**动态规划**

```cpp
class Solution {
public:
    // 动规
    // dp[i][j]为移动到i,j位置的最小路径
    // dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]);
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
        dp[1][1] = grid[0][0];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == 1 && j == 1) continue;
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1];
            }
        }
        return dp[m][n];
    }
};
```

一维

```cpp
class Solution {
public:
    // 动规，压缩到一维
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> dp(n + 1, INT_MAX);
        dp[1] = grid[0][0];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == 1 && j == 1) continue;
                dp[j] = min(dp[j], dp[j - 1]) + grid[i - 1][j - 1];
            }
        }
        return dp[n];
    }
};
```

**dfs**

超出时间限制

```cpp
class Solution {
public:
    // 回溯
    int dir[2][2] = {0,1,1,0};
    int result = INT_MAX;
    void aa(vector<vector<int>>& grid, int x, int y, int sum) {
        if (x == grid.size() - 1 && y == grid[0].size() - 1) {
            result = min(result, sum);
            return;
        }
        for (int i = 0; i < 2; i++) {
            int m = x + dir[i][0];
            int n = y + dir[i][1];
            if (m >= grid.size() || n >= grid[0].size()) continue;
            aa(grid, m, n, sum + grid[m][n]);
        }
    }
    int minPathSum(vector<vector<int>>& grid) {
        aa(grid, 0, 0, grid[0][0]);
        return result;
    }
};
```

## 39.组合总和

## 394.字符串解码

[394.字符串解码](https://leetcode.cn/problems/decode-string/)

![image-20230220191556399](E:\MarkDown\picture\image-20230220191556399.png)

时间复杂度O(n),

```cpp
class Solution {
public:
    string decodeString(string s) {
        // 压入的是当前字符串 和 下一个字符串需要遍历的次数
        stack<pair<int, string>> st;
        int num = 0;
        string tmp = "";
        for (int i = 0; i < s.size(); i++) {
            if (s[i] >= '0' && s[i] <= '9') {
                // 数字可能是18等两位数，因此要先乘10
                num *= 10;
                num += s[i] - '0';
            } else if (s[i] == '[') {
                // 压栈，压入 下一个tmp的倍数 和 当前的tmp
                // 这样出栈的时候，就是将当前的tmp乘num倍，加到之前的tmp上，作为新的tmp
                st.push({num, tmp});
                num = 0; tmp = "";
            } else if (s[i] == ']') {
                auto a = st.top(); st.pop();
                string s1 = a.second;
                for (int i = 0; i < a.first; i++) {
                    s1 += tmp;
                }
                tmp = s1;
            } else {
                tmp += s[i];
            }
        }
        return tmp;
    }
};
```

## 240.搜索二维矩阵 II

## 347.前 K 个高频元素

## ==按考察时间补充(做到了频度31)==

## 10.正则表达式匹配(未作)

[10.正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

> `'*'` 匹配零个或多个前面的那一个元素，如abc*，可以表示"ab" "abc" "abccc"，是可以将前面的字符删掉的
>
> ".*"可以匹配任意

**动态规划**

```cpp
```

错误思路

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        // 双指针同时遍历。相等或遇到.，继续；遇到.则看上一个字符与s的是否相等，相等的话向后遍历s直到遇到不一样的，此时在和p的下一个开始比
        int pP = 0;
        for (int sP = 0; sP < s.size(); sP++) {
            if (s[sP] == p[pP] || p[pP] == '.') pP++;
            else if (p[pP] == '*' && p[pP - 1] == s[sP]) {
                while (p[pP] == '*' && p[pP - 1] == s[sP]) {
                    sP++;
                }
                sP--;
                pP++;
            } else if (p[pP] == '*' && p[pP - 1] == '.') {
                // s = "ab", p = ".*"的情况
                if (pP == p.size() - 1) return true;
                // "ab" ".*c"的情况写不下去了
                else if (s){
                    if ()
                }
            } else if (s[sP] != p[pP] && p[++pP] == '*') {
                pP++;
                sP--;
            }
            else return false;
        }
        return true;
    }
};
```

## 560.和为 K 的子数组

## 152.乘积最大子数组

[152.乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

**动态规划**

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int minNum = 1, maxNum = 1;
        int result = INT_MIN;
        for (int i = 0; i < nums.size(); i++) {
            // 小于0时，最小值变最大值，最大值变最小值
            if (nums[i] < 0) swap(maxNum, minNum);
            // 可能存在[0,2]这种中间出现0的情况，要避免maxN和minN一直为0，因此要加max和min
            maxNum = max(maxNum * nums[i], nums[i]);
            minNum = min(minNum * nums[i], nums[i]);
            result = max(result, maxNum);
        }
        return result;
    }
};
```

## 136.只出现一次的数字

[136.只出现一次的数字](https://leetcode.cn/problems/single-number/)

**异或**

> ans相当于`nums[0]^nums[1]^nums[2]^nums[3]^nums[4]....` 然后再根据交换律把相等的合并到一块儿进行异或（结果为0），然后再与只出现过一次的元素进行异或，这样最后的结果就是，只出现过一次的元素（0^任意值=任意值）
>
> <img src="E:\MarkDown\picture\image-20230221192131143.png" alt="image-20230221192131143" style="zoom:50%;" />

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        //  异或，两数相同结果为0，0与任何数异或为数本身
        int tmp = 0;
        for (int num : nums) {
            tmp = tmp ^ num;
        }
        return tmp;
    }
};
```

## 62.不同路径

## 207.课程表

## 139.单词拆分

[139.单词拆分](https://leetcode.cn/problems/word-break/)

## 287. 寻找重复数



# 十六、牛客TOP101

## ==链表==

## BM1 反转链表

[BM1 反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

### 双指针

空间复杂度O(1)，时间复杂度O(n)

```cpp
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
		ListNode* pre = nullptr;
		ListNode* cur = pHead;
		ListNode* tmp;
		while (cur) {
			tmp = cur->next;
			cur->next = pre;
			pre = cur;
			cur = tmp;
		}
		return pre;
    }
};
```

### 栈实现

空间复杂度O(n)，时间复杂度O(2n)

```cpp
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
		// 用栈实现，空间复杂度O(n)，时间复杂度O(2n)
		if (pHead == nullptr) return nullptr;
		stack<ListNode*> st;
		while (pHead != nullptr) {
			st.push(pHead);
			pHead = pHead->next;
		}
		ListNode* node = st.top();
		ListNode* result = node;  // 保存node的开始位置
		st.pop();
		while (!st.empty()) {
			node->next = st.top();
			st.pop();
			node = node->next;
		}
		node->next = nullptr;
		return result;
    }
};

```

### 递归

时间复杂度O(n)

空间复杂度O(n)（栈的深度为n，每次递归的空间复杂度为1）

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
	ListNode* aa(ListNode* pre, ListNode* cur) {
		// 终止条件：cur遍历到末尾空节点，返回pre作为头结点
		if (cur == nullptr) return pre;
		ListNode* node = cur->next;
		cur->next = pre;
		return aa(cur, node);
	}
    ListNode* ReverseList(ListNode* pHead) {
		// 递归实现，空间复杂度O(n)，时间复杂度O(2n)
		if (pHead == nullptr) return nullptr;
		return aa(nullptr, pHead);
    }
};
```

完整程序

```cpp
#include<iostream>
#include<algorithm>
using namespace std;


struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
	// 计数，看一下时间复杂度
	int countn = 0;
    ListNode* reverse(ListNode* pre,ListNode* cur){
        if(cur == nullptr) return pre;
        ListNode* tmp = cur->next;
        cur->next = pre;
        countn++;
        return reverse(cur,tmp);
    }
    ListNode* reverseList(ListNode* head) {
        return reverse(nullptr,head);
    }
};
int main() {
	ListNode* node = new ListNode(2);
	ListNode* head = node;
	for (int i = 0; i < 5; i++) {
		node->next = new ListNode(i);
		node = node->next;
	}
	
	Solution s;
	s.reverseList(head);
	cout << s.countn;
}
```

## BM2 链表内指定区间反转

[BM2 链表内指定区间反转](https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

![image-20230209095739491](E:\MarkDown\picture\image-20230209095739491.png)

### F1 基于反转链表

![image-20230209105211968](E:\MarkDown\picture\image-20230209105211968.png)

> 令left和right分别为要反转区间的头和尾，pre和cur分别为区间前和后的一个结点
>
> 踩坑：对于反转链表的程序，不能直接拿 BM1 中返回ListNode*的程序来用，因为里面的都是临时变量！正确做法是改为void，没有返回值，代入leftNode，经过反转后，就是以rightNode为头，leftNode为尾的链表

时间复杂度O(n)，空间复杂度O(1)

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
    void ReverseList(ListNode* pHead) {
		ListNode* pre = nullptr;
		ListNode* cur = pHead;
		ListNode* tmp;
		while (cur) {
			tmp = cur->next;
			cur->next = pre;
			pre = cur;
			cur = tmp;
		}
    }
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        // 1.设置一个虚拟头结点
        ListNode* dummyNode = new ListNode(-1);
        dummyNode->next = head;

        ListNode* tmp = dummyNode;
        // 2.找到pre和left。其中pre用于反转后的连接
        for (int i = 0; i < m - 1; i++) {
            tmp = tmp->next;
        }
        ListNode* pre = tmp;
        ListNode* leftNode = tmp->next;

        // 3.找到right和cur
        for (int i = 0; i < n - m + 1; i++) {
            tmp = tmp->next;
        }
        ListNode* rightNode = tmp;
        ListNode* cur = tmp->next;

        // 4.将left到right视为一个独立的链表，进行反转
        rightNode->next = nullptr;
        pre->next = nullptr;
        ReverseList(leftNode);

        pre->next = rightNode;
        leftNode->next = cur;

        return dummyNode->next;
    }
};
```

### F2 原地反转(推荐方法)

<img src="E:\MarkDown\picture\image-20230209154207241.png" alt="image-20230209154207241" style="zoom:20%;" />

```cpp
class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        // 1.设置一个虚拟头结点,来避免头节点的分类讨论
        ListNode* dummyNode = new ListNode(-1);
        dummyNode->next = head;
        ListNode* tmp = dummyNode;
        // 2.反转区间的第一个为LeftNode，前一个为pre，后一个为cur
        for (int i = 0; i < m - 1; i++) {
            tmp = tmp->next;
        }
        ListNode* leftNode = tmp->next;
        ListNode* pre = tmp;
        ListNode* cur;
        // 3.不断的把left后面的结点cur移动到pre后面来
        // 循环中pre不变，一直为反转区间的前一个
        for (int i = 0; i < n - m; i++){
            // 向后移动cur
            cur = leftNode->next;
            // 将left移动到cur的后面
            leftNode->next = cur->next;
            // 将cur移动到pre后面
            cur->next = pre->next;
            pre->next = cur;
        }
        return dummyNode->next;
    }
};
```

## *BM3 链表中的节点每k个一组翻转/25.K个一组翻转链表(~)*

[BM3 链表中的节点每k个一组翻转](https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tqId=722&ru=%2Fpractice%2Fb58434e200a648c589ca2063f1faf58c&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295) [25. K个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

F1

<img src="E:\MarkDown\picture\image-20230222112537532.png" alt="image-20230222112537532" style="zoom:20%;" />

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 翻转链表
    ListNode* reverse(ListNode* node) {
        ListNode* pre = nullptr;
        ListNode* cur = node;
        ListNode* next;
        while (cur) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* node = new ListNode(-1);
        node->next = head;
        ListNode* first = node;
        ListNode* second = node;
        while (second) {
            for (int i = 0; i < k && second != nullptr; i++) {
                second = second->next;
            }
            if (second == nullptr) break;
            ListNode* revStart = first->next;
            ListNode* nextStart = second->next;
            // 截断当前链表
            second->next = nullptr;
            first->next = reverse(revStart);
            revStart->next = nextStart;
            first = revStart;
            second = revStart;
        }
        return node->next;
    }
};
```

F2 **递归方法**

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // tail为下个反转区间的开头
        ListNode* tail = head;
        for (int i = 0; i < k; i++) {
            // 如果不足k，就直接返回起始结点
            if (tail == nullptr) return head;
            tail = tail->next;
        }
        // 反转头部到尾部的区间
        ListNode* cur = head;
        ListNode* pre = nullptr;
        ListNode* tmp;
        while (cur != tail) {
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        // 翻转后pre为头结点，head指向原先的头结点，即现在的尾结点
        head->next = reverseKGroup(tail, k);
        return pre;
    }
};
```

## BM4 合并两个排序的链表

[BM4 合并两个排序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

![image-20230209162413745](E:\MarkDown\picture\image-20230209162413745.png)

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
		// 虚拟头结点
        ListNode* head = new ListNode(-1);
		ListNode* tmp = head;
		while (pHead1 || pHead2) {
			// 注意，这个判断要放在前面
			if (pHead1 == nullptr || pHead2 == nullptr) {
				tmp->next = (pHead1 == nullptr) ? pHead2 : pHead1;
				return head->next;
			}
			if (pHead1->val > pHead2->val) 	{
				tmp->next = pHead2;
				pHead2 = pHead2->next;
			} else {
				tmp->next = pHead1;
				pHead1 = pHead1->next;
			}
			tmp = tmp->next;
		}
		return head->next;
    }
};
```

写法2，更简洁

```cpp
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
		// 虚拟头结点
        ListNode* head = new ListNode(-1);
		ListNode* tmp = head;
		while (pHead1 && pHead2) {
			if (pHead1->val > pHead2->val) 	{
				tmp->next = pHead2;
				pHead2 = pHead2->next;
			} else {
				tmp->next = pHead1;
				pHead1 = pHead1->next;
			}
			tmp = tmp->next;
		}
		// 若pHead1不为空，则指向pHead1
		tmp->next = pHead1 ? pHead1 : pHead2;
		return head->next;
    }
};
```

## *BM5 合并k个已排序的链表/23. 合并K个升序链表(~)*

[BM5](https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295) [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

相比BM4，增加了

### F1 顺序合并

第i次合并耗时O(i* n)，因此总的时间复杂度为O((1+K)K/2)=O(k^2 * n)

不符合要求！

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
		// 虚拟头结点
        ListNode* head = new ListNode(-1);
		ListNode* tmp = head;
		while (pHead1 && pHead2) {
			if (pHead1->val > pHead2->val) 	{
				tmp->next = pHead2;
				pHead2 = pHead2->next;
			} else {
				tmp->next = pHead1;
				pHead1 = pHead1->next;
			}
			tmp = tmp->next;
		}
		// 若pHead1不为空，则指向pHead1
		tmp->next = pHead1 ? pHead1 : pHead2;
		return head->next;
    }
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        ListNode* node = nullptr;
        for (int i = 0; i < lists.size(); i++) {
            node = Merge(node, lists[i]);
        }
        return node;
    }
};
```

### F2 归并排序

* 时间复杂度：O(nlog2k)，其中n为所有链表的总节点数，分治为二叉树型递归，最坏情况下二叉树每层合并都是O(n)个节点，因为分治一共有O(log_2k)层
* 空间复杂度：O(log2k)，最坏情况下递归log2k层，需要log2k的递归栈

```cpp
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
		// 虚拟头结点
        ListNode* head = new ListNode(-1);
		ListNode* tmp = head;
		while (pHead1 && pHead2) {
			if (pHead1->val > pHead2->val) 	{
				tmp->next = pHead2;
				pHead2 = pHead2->next;
			} else {
				tmp->next = pHead1;
				pHead1 = pHead1->next;
			}
			tmp = tmp->next;
		}
		// 若pHead1不为空，则指向pHead1
		tmp->next = pHead1 ? pHead1 : pHead2;
		return head->next;
    }
    //划分合并区间函数
    ListNode* divideMerge(vector<ListNode *> &lists, int left, int right){
        if (left > right) return NULL;
        //中间一个的情况
        else if(left == right) return lists[left];
        //从中间分成两段，再将合并好的两段合并
        int mid = (left + right) / 2;
        return Merge(divideMerge(lists, left, mid), divideMerge(lists, mid + 1, right));
    }

    ListNode *mergeKLists(vector<ListNode *> &lists) {
        //k个链表归并排序
        return divideMerge(lists, 0, lists.size() - 1);
    }
};
```

## *BM6 判断链表中是否有环/141.环形链表(~)*

[BM6](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=295&tqId=605&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj) [141.环形链表](https://leetcode.cn/problems/linked-list-cycle/)

142.环形链表 II(M)的青春版（不用判断环的入口了

![image-20230211110525508](E:\MarkDown\picture\image-20230211110525508.png)

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
};
```

## BM7 链表中环的入口结点

同142.环形链表 II(M)

```cpp
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode* fast = pHead;
        ListNode* slow = pHead;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) {
                fast = pHead;
                while (fast != slow) {
                    fast = fast->next;
                    slow = slow->next;
                }
                return fast;
            }
        }
        return nullptr;
    }
};
```

## BM8 链表中倒数最后k个结点

[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

### 快慢指针/双指针

**第一个指针先移动k步，然后第二个指针再从头开始，这个时候这两个指针同时移动，当第一个指针到链表的末尾的时候，返回第二个指针即可**

```cpp
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pHead, int k) {
        ListNode* fast = pHead;
        ListNode* slow = pHead;
        // fast指针先走k步
        for (int i = 0; i < k; i++) {
            if (fast == nullptr) return fast;
            fast = fast->next;
        }
        // 两指针同时走
        while (fast) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

### 栈(复杂了)

```cpp
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pHead, int k) {
        if ((pHead == nullptr )|| (k == 0)) return nullptr;
        stack<ListNode*> st;
        while (pHead) {
            st.push(pHead);
            pHead = pHead->next;
        }
        // 判断栈的元素是否小于k
        if (st.size() < k) return nullptr;
        ListNode* firstNode = st.top();st.pop();
        while (--k) {
            ListNode* tmp = st.top();st.pop();
            tmp->next = firstNode;
            firstNode = tmp;
        }
        return firstNode;
    }
};
```

# 十七、剑指offer

按最近考察时间排序

## 39. 数组中出现次数超过一半的数字

[剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/) [169. 多数元素](https://leetcode.cn/problems/majority-element/)

## 48. 最长不含重复字符的子字符串

[剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 滑窗
        unordered_map<char, int> map;
        int left = -1;
        int result = 0;
        for (int i = 0; i < s.size(); i++) {
            if (map.find(s[i]) != map.end()) {
                left = max(left, map[s[i]]);
            }
            result = max(result, i - left);
            map[s[i]] = i;
        }
        return result;
    }
};
```

## 52. 两个链表的第一个公共节点

[剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

## 54. 二叉搜索树的第k大节点

[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

## 45. 把数组排成最小的数

[剑指 Offer 45. 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

sort

```cpp
class Solution {
public:
    string minNumber(vector<int>& nums) {
        vector<string> result;
        for (auto i : nums) result.push_back(to_string(i));
        sort(result.begin(), result.end(), [](string& a, string& b){ return a + b < b + a; });
        string tmp = "";
        for (auto i : result) tmp += i;
        return tmp;
    }
};
```

自写快排

```cpp
class Solution {
public:
    string minNumber(vector<int>& nums) {
        vector<string> result;
        for (auto i : nums) result.push_back(to_string(i));
        quickSort(result, 0, result.size() - 1);
        string tmp = "";
        for (auto i : result) tmp += i;
        return tmp;
    }
    void quickSort(vector<string>& strs, int l, int r) {
        if(l >= r) return;
        int i = l, j = r;
        while(i < j) {
            while(strs[j] + strs[l] >= strs[l] + strs[j] && i < j) j--;
            while(strs[i] + strs[l] <= strs[l] + strs[i] && i < j) i++;
            swap(strs[i], strs[j]);
        }
        swap(strs[i], strs[l]);
        quickSort(strs, l, i - 1);
        quickSort(strs, i + 1, r);
    }
    // 三路快排
    // void aa(vector<string>& result, int left, int right) {
    //     int tmp = rand() % (right - left + 1) + left;
    //     swap(nums[right], nums[tmp]);
    //     int pivot = nums[right];
    //     int lf = left - 1, rt = right, cur = left;
    //     while (lf < rt) {
    //         if (nums[cur] > pivot) swap(nums[cur], nums[--rt]);
    //         else if (nums[cur] < pivot) swap(nums[cur++], nums[++lf];)
    //         else cur+;
    //     }
    //     swap(nums[right], nums[rt]);
    //     aa(result, left, lf);
    //     aa(result, rt + 1, right);
    // }
};
```

超时方法：回溯

```cpp
class Solution {
public:
static bool cmp(string& a, string& b) {
    return a < b;
}
    vector<string> result;
    string tmp = "";
    void aa (vector<int>& nums, vector<int>& used, int count, string tmp) {
        if (count == nums.size()) {
            result.push_back(tmp);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i] == 0) {
                used[i] = 1;
                aa (nums, used, count + 1, tmp + to_string(nums[i]));
                used[i] = 0;
            }
        }
    }
    string minNumber(vector<int>& nums) {
        // 回溯得到所有结果，再筛？
        vector<int> used(nums.size(), 0);
        aa(nums, used, 0, "");
        sort(result.begin(), result.end(), cmp);
        return result[0];
    }
};
```

## 51. 数组中的逆序对(hard)

[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

超时方法：

```cpp
class Solution {
public:
    int reversePairs(vector<int>& nums) {
        // 每个数大于后面数的总和
        if (nums.size() == 0) return 0;
        int result = 0;
        for (int i = 0; i < nums.size() - 1; i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[i] > nums[j]) result++;
            }
        }
        return result;
    }
};
```

## 36. 二叉搜索树与双向链表

[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

```cpp
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        // 中序遍历，递归的方式思路比较简洁
        int count = 0;  // 统计结点数量
        stack<Node*> st;
        Node* cur = root;
        Node* result = new Node(-1);
        Node* head = result;
        while (cur != nullptr || !st.empty()) {
            if (cur != nullptr) {
                st.push(cur);
                cur = cur->left;
            } else {
                cur = st.top(); st.pop();
                head->right = cur;
                head = head->right;
                count++;
                cur = cur->right;
            }
        }
        Node* pre = head;  // 保存一下最后一个结点
        head->right = result->right;
        
        // 第二轮循环，补全左孩子
        head = result->right;
        while (count--) {
            head->left = pre;
            pre = head;
            head = head->right;
            
        }
        return result->right;
    }
};
```

## 40. 最小的k个数

[剑指 Offer 40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

时间复杂度O(klog(n))

```cpp
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        // 容器，默认大顶堆。和堆顶比较，比堆顶小就弹出堆顶，插入新值
        vector<int> result;
        if (k == 0) return result;
        priority_queue<int> que;
        for (auto i : arr) {
            if (que.size() == k) {
                if (i < que.top()) {
                    que.pop();
                    que.push(i);
                }
            } else {
                que.push(i);
            }
        }
        
        while (!que.empty()) {
            result.push_back(que.top()); que.pop();
        }
        return result;
    }
};
```



## 29. 顺时针打印矩阵

## 42.连续子数组的最大和

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) [剑指 Offer 42. 连续子数组的最大和](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

## 61. 扑克牌中的顺子

[剑指 Offer 61. 扑克牌中的顺子](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

普通的麻烦方法

```cpp
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int count = 0;
        int i = 0;
        for (; i < nums.size();i++) {
            if (nums[i] == 0) count++;
            else break;
        }
        int tmp = nums[i++];
        for (; i < nums.size();i++) {
            if (nums[i] == tmp) return false; // 注意，有重复的
            count -= nums[i] - tmp - 1;
            tmp = nums[i];
        }
        return count >= 0;
    }
};
```

此 5 张牌是顺子的 充分条件 如下：

* 除大小王外，所有牌 无重复；
* 设此 5 张牌中最大的牌为 max ，最小的牌为 min （大小王除外），则需满足：max - min < 5

```cpp
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        unordered_set<int> set;
        int maxN = 0, minN = 14;
        for (auto i : nums) {
            if (i == 0) continue;
            if (set.find(i) != set.end()) return false;
            set.insert(i);
            maxN = max(maxN, i);
            minN = min(minN, i);
        }
        return maxN - minN < 5;
    }
};
```



## 26.树的子结构

[剑指 Offer 26. 树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

> 难点在于找到结点后判断是否为子树

递归

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool recur(TreeNode* A, TreeNode* B) {
        // A中结点B中没有，是子树
        if (B == NULL) return true;
        // B中结点A没有，B不是子树
        if (A == NULL) return false;
        if (A->val != B->val) return false;
        return recur(A->left, B->left) && recur(A->right, B->right);
    }
    // 迭代遍历
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (!A || !B) return false;
        return recur(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
};
```

迭代遍历实现，有点麻烦

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool recur(TreeNode* A, TreeNode* B) {
        // A中结点B中没有，是子树
        if (B == NULL) return true;
        // B中结点A没有，B不是子树
        if (A == NULL) return false;
        if (A->val != B->val) return false;
        return recur(A->left, B->left) && recur(A->right, B->right);
    }
    // 迭代遍历
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (!A || !B) return false;
        stack<TreeNode*> st;
        st.push(A);
        TreeNode* node = st.top();
        while (!st.empty()) {
            node = st.top(); st.pop();
            if (node->val == B->val) {
                if(recur(node, B)) return true;
            }
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return false;
    }
};
```

## 22. 链表中倒数第k个节点

[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

## 09. 用两个栈实现队列

[剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

## 47.礼物的最大价值

[剑指 Offer 47. 礼物的最大价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/)

**动态规划**

```cpp
class Solution {
public:
    // dp[i][j]表示到i j位置的最大价值
    int maxValue(vector<vector<int>>& grid) {
        vector<vector<int>> dp(grid.size() + 1, vector<int>(grid[0].size() + 1, 0));
        for (int i = 1; i <= grid.size(); i++) {
            for (int j = 1; j <= grid[0].size(); j++) {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1];
            }
        }
        return dp[grid.size()][grid[0].size()];
    }
};
```

**dfs**

超出时间限制！

```cpp
class Solution {
public:
    int dir[2][2] = {0, 1, 1, 0};
    int sum;
    int result = 0;
    void dfs(vector<vector<int>>& grid, int x, int y){
        if (x == grid.size() - 1 && y == grid[0].size() - 1) result = max(result, sum);
        for (int i = 0; i < 2; i++) {
            int a = x + dir[i][0];
            int b = y + dir[i][1];
            if (a >= grid.size() || b >= grid[0].size()) continue;
            sum += grid[a][b];
            dfs(grid, a, b);
            sum -= grid[a][b];
        }
    }
    int maxValue(vector<vector<int>>& grid) {
        sum = grid[0][0];
        dfs(grid, 0, 0);
        return result;
    }
};
```

## 60.n个骰子的点数

[剑指 Offer 60. n个骰子的点数](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/)

[题解](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/solution/nge-tou-zi-de-dian-shu-dong-tai-gui-hua-ji-qi-yo-3/)

> n个骰子点数和范围为[n, 6n]，数量为6n - n + 1 = 5n + 1种
>
> <img src="E:\MarkDown\picture\image-20230525100612342.png" alt="image-20230525100612342" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<double> dicesProbability(int n) {
        // dp[i][j]为i枚骰子，投出点数j可能的次数
        // n个骰子点数和范围为[n, 6n]，1个骰子则是[1, 6]，因此所有的可能再加上0为6 * n + 1
        vector<vector<int>> dp(n + 1, vector<int>(6 * n  + 1, 0));
        for (int i = 1; i <= 6; i ++) {
            dp[1][i] = 1;
        }
        for (int i = 2; i <= n; i ++) {
            for (int j = i; j <= 6 * i; j ++) {
                for (int cur = 1; cur <= 6; cur ++) {
                    if (j - cur <= 0) {
                        break;
                    }
                    dp[i][j] += dp[i-1][j-cur];
                }
            }
        }
        // 求出来的是出现的次数，还要除所有点数出现的总次数6^n
        int all = pow(6, n);
        vector<double> result;
        // 最后我们取投n枚筛子，投出[n, 6n]的结果
        for (int i = n; i <= 6 * n; i++) {
            result.push_back(dp[n][i] * 1.0 / all);
        }
        return result;
    }
}; 
```

## 07.重建二叉树

[剑指 Offer 07. 重建二叉树](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)

前序和中序遍历

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.size() == 0 || inorder.size() == 0) return nullptr;
        TreeNode* node = new TreeNode(preorder[0]);
        // 重点，别忘了叶子结点
        if (preorder.size() == 1) return node;
        int lend = 0; // inorder中root的位置，同时也是preorder中左子树结束的位置
        for (int i = 0; i < inorder.size(); i++) {
            if (inorder[i] == preorder[0]) {
                lend = i;
                break;
            }
        }
        vector<int> pleft = vector<int>(preorder.begin() + 1, preorder.begin() + 1 + lend);
        vector<int> ileft = vector<int>(inorder.begin(), inorder.begin() + lend);
        vector<int> pright = vector<int>(preorder.begin() + lend + 1, preorder.end());
        vector<int> iright = vector<int>(inorder.begin() + lend + 1, inorder.end());
        node->left = buildTree(pleft, ileft);
        node->right = buildTree(pright, iright);
        return node;
    }
};
```

还有其他用下标解决的方法

https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/

时间复杂度 O(N) ： 其中 N 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N) 。递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 O(1) ，因此使用 O(N) 时间。

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        this->preorder = preorder;
        for(int i = 0; i < inorder.size(); i++)
            dic[inorder[i]] = i;
        return recur(0, 0, inorder.size() - 1);
    }
private:
    vector<int> preorder;
    unordered_map<int, int> dic;
    TreeNode* recur(int root, int left, int right) { 
        if(left > right) return nullptr;                        // 递归终止
        TreeNode* node = new TreeNode(preorder[root]);          // 建立根节点
        int i = dic[preorder[root]];                            // 划分根节点、左子树、右子树
        node->left = recur(root + 1, left, i - 1);              // 开启左子树递归
        node->right = recur(root + i - left + 1, i + 1, right); // 开启右子树递归
        return node;                                            // 回溯返回根节点
    }
};
```

## 50.第一个只出现一次的字符

[剑指 Offer 50. 第一个只出现一次的字符](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

与 136.只出现一次的数字 类似，但没法用异或的方法

**数组实现，更快**

```cpp
class Solution {
public:
    char firstUniqChar(string s) {
        int a[26] = {};
        for (char i : s) a[i - 'a']++;
        for (char i : s) {
            if (a[i - 'a'] == 1) return i;
        }
        return ' ';
    }
};
```

**哈希表实现**

```cpp
class Solution {
public:
    char firstUniqChar(string s) {
        // 时间复杂度O(2n)，空间最大O(26)
        unordered_map<int, int> map;
        for (auto i : s) map[i]++;
        for (auto i : s) {
            if (map[i] == 1) return i;
        }
        return ' ';
    }
};
```

## 03.数组中重复的数字

[剑指 Offer 03. 数组中重复的数字](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

**unordered_map**

空间复杂度O(n)

```cpp
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map<int, int> map;
        for (int num : nums) {
            if (map[num]) return num;
            map[num]++;
        }
        return -1;
    }
};
```

**原地交换**

<img src="E:\MarkDown\picture\image-20230221212623610.png" alt="image-20230221212623610" style="zoom:50%;" />

```cpp
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int start = 0;
        while (start < nums.size()) {
            // 下标start的数字在正确的位置时，就继续向后遍历
            if (nums[start] == start) {
                start++;
                continue;
            }
            // 若start下标处的数字，已经有一个同样的数字在正确的位置，说明找到了
            if (nums[nums[start]] == nums[start]) return nums[start];
            // 不在正确的位置，则交换位置
            swap(nums[start], nums[nums[start]]);
        }
        return -1;
    }
};
```

## 442. 数组中重复的数据

[442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/)

```cpp
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> result;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] < 0 || nums[i] == i + 1) {
                continue;
            }
            if (nums[nums[i] - 1] == nums[i]) {
                result.push_back(nums[i]);
                nums[i] *= -1;
            }
            // 注意这里，i--，因为在大循环里，而这种情况不应该向下循环
            else swap(nums[nums[i] - 1], nums[i--]);
        }
        return result;
    }
};
```



## *04.二维数组中的查找/240.搜索二维矩阵 II(~)*

[剑指 Offer 04. 二维数组中的查找 ](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/) [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

普通方法

主站中超时，剑指中可AC

```cpp
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if (matrix.size() == 0 || matrix[0].size() == 0) return false;
        for (int i = 0; i < matrix.size(); i++) {
            if (matrix[i][0] > target) break;
            for (int j = 0; j < matrix[0].size() && matrix[i][j] <= target; j++) {
                if (matrix[i][j] == target) return true;
            }
        }
        return false;
    }
};
```

更巧妙的方法

最多O(M+N)，M为行数N为列数

```cpp
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        // 以右上角为起点，向左更小向右更大
        if (matrix.size() == 0 || matrix[0].size() == 0) return false;
        int a = 0, b = matrix[0].size() - 1;
        while (a < matrix.size() && b >= 0) {
            if (matrix[a][b] > target) b--;
            else if (matrix[a][b] < target) a++;
            else return true;
        }
        return false;
    }
};
```

## 28.对称的二叉树

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/) [剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)

# 十八、codetop最近考察

## 414. 第三大的数

[414. 第三大的数](https://leetcode.cn/problems/third-maximum-number/)

1、不计算重复数

2、`-231 <= nums[i] <= 231 - 1`，要用long long

```cpp
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        long long a = LONG_MIN, b = LONG_MIN, c = LONG_MIN;
        for (auto i : nums) {
            if (i > a) {
                c = b; b = a; a = i;
            } else if (i > b && i < a) {
                c = b; b = i;
            } else if (i > c && i < b) {
                c = i;            
            }
        }
        return c == LONG_MIN ? a : c;
    }
};
```



## 179. 最大数

## 54.螺旋矩阵

## 1438. 绝对差不超过限制的最长连续子数组

[1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)

双指针+有序集合

时间复杂度：O(nlog⁡n)，其中 n 是数组长度。向有序集合中添加或删除元素都是 O(logn) 的时间复杂度。每个元素最多被添加与删除一次。

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int left = 0, right = 0;
        int result = 0;
        multiset<int> set;
        while (right < nums.size()) {
            set.insert(nums[right]);
            while (*set.rbegin() - *set.begin() > limit) {
                set.erase(set.find(nums[left]));
                left++;
            }
            result = max(result, right - left + 1);
            right++:
        }
        return result;
    }
};
```

错误方法

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        // 在序列中维持最小和最大值，若超过Limit，保存当前长度
        int minNum = INT_MAX, maxNum = INT_MIN;
        int count = 0, result = 1;
        for (int i = 0; i < nums.size() - 1; i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                minNum = min(minNum, nums[j]);
                maxNum = max(maxNum, nums[j]);
                if (maxNum - minNum > limit) {
                    result = max(result, count);
                    count = 0;
                    break;
                }
                count++;
            }
        }
        result = max(result, count);
        return result;
    }
};
```

## BM3 链表中的节点每k个一组翻转/25.K个一组翻转链表

## 440. 字典序的第K小数字

[440. 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)

> 1 <= k <= n <= 10^9，而int的范围是 -2^31 — 2^31-1 ，即-2147483648—2147483647，2*10^9，正常来说不会越界，但next *10的操作会越界，需要将相关的数据类型改为long

```cpp
class Solution {
public:
    // 得到以tag为前缀的子节点数量(包括tag
    int getCount(int tag, long n) {
        long cur = tag;  // 当前树的前缀
        long next = tag + 1;  // 相邻树的前缀
        int count = 0;  // 统计子节点数量
        while (cur <= n) {
            // 如果当前前缀下节点是满的，即10 ... 19，则count += next - cur = 20 - 10
            // 若不是满的，比如n = 12，1节点下最多到12，则count += 13 - 10 = 3。即1下面有10 11 12三个节点
            count += min(n + 1, next) - cur;
            // 如果说刚刚prefix是1，next是2，那么现在分别变成10和20
            // 1为前缀的子节点增加10个，十叉树增加一层, 变成了两层
            cur *= 10;
            next *= 10;
        }
        return count;
    }
    int findKthNumber(int n, int k) {
        int p = 1;  // 指向第1个数
        int prefix = 1;  // 前缀，或者说p指向的数为prefix，即第p个数为prefix
        while (p < k) {
            int count = getCount(prefix, n);
            // 第k个数在prefix前缀范围内
            if (p + count > k) {
                // 将prefix移动到第一个子节点处
                prefix *= 10;
                // 将指针指向第一个子节点的位置
                p++;
            } else /* if (p + count <= k)*/ {
                // prefix移动到下个前缀处
                prefix++;
                // 将p指向了下个前缀的起点
                p += count;
            }
        }
        return prefix;
    }
};
```

## 补充题24. 双栈排序

猿辅导、美团、字节面试题——双栈排序

**题目描述**

给定一个乱序的栈，设计算法将其升序排列。
ps: 允许额外使用一个栈来辅助操作

> 输入
> [4, 2, 1, 3]
> 输出
> [1, 2, 3, 4]

![image-20230222222756346](E:\MarkDown\picture\image-20230222222756346.png)

```cpp
stack<int> stackSort(stack<int> &stk) {
    stack<int> tmp;
    while (!stk.empty()) {
        int a = stk.top(); stk.pop();
        while (!tmp.empty() && a < tmp.top()) {
            stk.push(tmp.top());
            tmp.pop();
        }
        tmp.push(a);
    }
    return tmp;
}
```

## 454. 四数相加 II

## 103. 二叉树的锯齿形层序遍历

[103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

**层序遍历，直接按下标赋值**

```cpp
class Solution {
public:
    // 层序遍历
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result;
        queue<TreeNode*> que;
        if (root == nullptr) return result;
        int depth = 0;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> tmp(size);
            while (size--) {
                TreeNode* node = que.front(); que.pop();
                // 如果深度是偶数，按正常顺序，下标位置为tmp.size() - size - 1
                // 奇数则按逆序的下标位置
                int tag = depth % 2 == 0 ? tmp.size() - size - 1 : size;
                tmp[tag] = node->val;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(tmp);
            depth++;
        }
        return result;
    }
};
```



**借用deque实现**

(也可以正常的层序遍历，奇数深度时reverse(vec.begin(), vec.end()))

**迭代**

```cpp
class Solution {
public:
    // 层序遍历
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (root == nullptr) return result;
        int depth = 0;
        deque<TreeNode*> que;
        vector<int> tmp;
        que.push_back(root);
        while (!que.empty()) {
            depth++;
            int size = que.size();
            while (size--) {
                if (depth % 2 == 1) {
                    TreeNode* node = que.front(); que.pop_front();
                    tmp.push_back(node->val);
                    if (node->left) que.push_back(node->left);
                    if (node->right) que.push_back(node->right);
                } else {
                    TreeNode* node = que.back(); que.pop_back();
                    tmp.push_back(node->val);
                    if (node->right) que.push_front(node->right);
                    if (node->left) que.push_front(node->left);
                }
            }
            result.push_back(tmp);
            tmp.clear();
        }
        return result;
    }
};
```

**递归**

```cpp
// 递归
class Solution {
public:
    vector<deque<int>> tmp;
    void aa(TreeNode* node, int depth) {
        if (node == nullptr) return;
        if (depth == tmp.size()) tmp.push_back({});
        if (depth % 2 == 1) {
            tmp[depth].push_front(node->val);
        } else {
            tmp[depth].push_back(node->val);
        }
        aa(node->left, depth + 1);
        aa(node->right, depth + 1);
    }
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        aa(root, 0);
        vector<vector<int>> result;
        for (auto i : tmp) {
            result.push_back(vector<int>(i.begin(), i.end()));
        }
        return result;
    }
};
```

## 1143.最长公共子序列

## 912. 排序数组/补充题4. 手撕快速排序/补充题6.手撕堆排序

[912. 排序数组](https://leetcode.cn/problems/sort-an-array/) [补充题4. 手撕快速排序](https://leetcode.cn/problems/sort-an-array)

## 61.旋转链表

[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        // 细节1
        if (k == 0 || head == nullptr) return head;
        // 先套成环，并统计结点数
        ListNode* start = head;
        int count = 1;
        while (start->next) {
            start = start->next;
            count++;
        }
        start->next = head;
        // 找起点和终点
        start = head;
        ListNode* end;
        // 细节2，存在套圈的情况
        k = k % count;
        count = count - k;
        while (count--) {
            end = start;
            start = start->next;
        }
        end->next = nullptr;
        return start;
    }
};
```

## 88. 合并两个有序数组

[88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

比较下标m和n的数，大的放后面

注意[0] 0 [1] 1的情况，即m<0时仅需要交换n

<img src="E:\MarkDown\picture\image-20230223231151221.png" alt="image-20230223231151221" style="zoom:67%;" />

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m + n - 1;
        m--; n--;
        while (n >= 0) {
            // 赋值比swap(nums1[i--], nums1[m--]);更好一点
            if (m >= 0 && nums1[m] > nums2[n]) nums1[i--] = nums1[m--];
            else nums1[i--] = nums2[n--];
        }
    }
};
```

## 332. 重新安排行程

[332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)

## 55. 跳跃游戏

[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

# 十九、模拟题

## 科大讯飞：小红的数字匹配

定义一个“模板串”为一个由数字字符和′?"组成的字符串。我们可以通过将问号替换成数字字符来得到正整数。显然，一个模板串可能会和多个正整数匹配。例如: "1?2"可以和102或者132等正整数匹配。请注意，匹配的正整数不能包含前导零，例如"??1"可以匹配101，但不能匹配001。小红拿到了一个模板串，她想知道，和这个模板串匹配的正整数中，第k小的是多少?

**输入描述**

第一行输入一个正整数t，代表询问次数。接下来的2* t行，每两行为一次询问: 第一行输入一个字符串，仅由数字字符和?'组成。第二行输入一个正整数k，代表询问的是第k小。

1≤t ≤ 10^4 1≤k≤10 ^9

字符串长度不超过30。

**输出描述**

输出t行，每行输出一个答案。如果一共都没有k个匹配的正整数，则输出-1。否则输出第小的匹配的正整数。

<img src="E:\MarkDown\picture\image-20230717230939545.png" alt="image-20230717230939545" style="zoom:50%;" />

思维题。

第k个元素等价于将k的十进制数的每一个数位，依次替换原字符串中的"?"即可。注意处理前导”?“的情况，由于答案不能出现前导0，因此，如果第一个数位为”0“，则+1。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()   {
	int count;
	cin >> count;
	while (count--) {
		string str; cin >> str;
		int k; cin >> k;
         // 统计 ? 数量
		int num = 0;
		for (auto i : str) {
			if (i == '?') num++;
		}
         // 排除不符合的情况
		if ((str[0] == '?' && pow(10, num - 1) * 9 < k) || (str[0] != '?' && pow(10, num) < k) || (str[0] == '0')) {
			cout << -1 << endl;
			continue;
		}
         // 
		string strk = to_string(k - 1);
		reverse(strk.begin(), strk.end());
		
		bool flag = false;
		if (str[0] == '?') flag = true;
		
		for (int i = str.size() - 1, j = 0; i >= 0; i--) {
			if (str[i] == '?') {
				if (j < strk.size()) str[i] = strk[j++];
				else str[i] = '0';
			}
		}
		if (flag) str[0] += 1;
		cout << str << endl;
	}
	return 0;
}
```



# 多线程

## semaphore.h

多线程编程里面需要用到的头文件：semaphore.h

同一个mutex，一般是在同一个线程进行加锁解锁的，如果mutex在a线程加锁，在b线程解锁，那么这就相当于把mutex当成信号量使用了，应该是属于未定义行为

#### int sem\_init(sem\_t \*sem, int pshared, unsigned int value)

> sem_init(&sem_1, 0, 0);

pshared：控制信号量的类型，0表示线程间共享，其它表示进程间共享(参数 pshared > 0 时指定了 sem 处于共享内存区域，所以可以在进程间共享该变量)

value：信号量的初始值

#### int sem\_post(sem\_t \*sem)

是以原子操作的方式给信号量的值加1（V操作），并发出信号唤醒等待线程sem\_wait

#### int sem\_wait(sem\_t \*sem)

以原子操作的方式给信号量的值减1（P操作），如果信号量的值为0函数将会等待，直到有线程增加了该信号量的值使其不再为0

## 1114\. 按序打印

[1114. 按序打印](https://leetcode.cn/problems/print-in-order/)

考点：线程同步，设置两个同步信号量分别实现first和second、second和third方法之间的同步顺序

```cpp
#include <semaphore.h>

class Foo {
public:
    sem_t sem_1, sem_2;
    Foo() {
        sem_init(&sem_1, 0, 0);
        sem_init(&sem_2, 0, 0);
    }

    void first(function<void()> printFirst) {
        printFirst();
        sem_post(&sem_1);
    }

    void second(function<void()> printSecond) {
        sem_wait(&sem_1);
        printSecond();
        sem_post(&sem_2);
    }

    void third(function<void()> printThird) {
        sem_wait(&sem_2);
        printThird();
    }
};
```

## 1115\. 交替打印 FooBar

[1115. 交替打印 FooBar](https://leetcode.cn/problems/print-foobar-alternately/)

生产者消费者问题

```cpp
class FooBar {
private:
    int n;
    mutex mtx;
    condition_variable cv;
    int count;
public:
    FooBar(int n) {
        this->n = n;
        count = 0;
    }

    void foo(function<void()> printFoo) {
        for (int i = 0; i < n; i++) {
            unique_lock<mutex> lock(mtx);
            while (count == 1) {
                cv.wait(lock);
            }
        	// printFoo() outputs "foo". Do not change or remove this line.
        	printFoo();
            count++;
            cv.notify_all();
        }
    }

    void bar(function<void()> printBar) {
        
        for (int i = 0; i < n; i++) {
            unique_lock<mutex> lock(mtx);
            while (count == 0) {
                cv.wait(lock);
            }

        	// printBar() outputs "bar". Do not change or remove this line.
        	printBar();
            count--;
            cv.notify_all();
        }
    }
};
```

解法：双信号量实现线程同步
互斥信号量sem1作用范围是打印foo开始到打印完Bar结束，把这个范围内的两个单独过程看成一个整体过程，不可分割，从而保证了foo和bar为一个整体，使用sem同步信号量保证foo和bar的先后顺序

```cpp
#include <semaphore.h>

class FooBar {
private:
    int n;
    sem_t sem_1, sem_2;
public:
    FooBar(int n) {
        this->n = n;
        sem_init(&sem_1, 0, 1);  // 初始资源设为1
        sem_init(&sem_2, 0, 0);
    }

    void foo(function<void()> printFoo) {
        
        for (int i = 0; i < n; i++) {
            sem_wait(&sem_1);
        	printFoo();
            sem_post(&sem_2);
        }
    }

    void bar(function<void()> printBar) {
        
        for (int i = 0; i < n; i++) {
            sem_wait(&sem_2);
        	printBar();
            sem_post(&sem_1);
        }
    }
};
```

## 1226\. 哲学家进餐

[1226. 哲学家进餐](https://leetcode.cn/problems/the-dining-philosophers/)

<img src="E:\MarkDown\picture\image-20230523182105941.png" alt="image-20230523182105941" style="zoom:50%;" />

考点：多线程和死锁问题解决，怎么实现互斥

对于资源（筷子），应该认为这是五种临界资源，而不是一种临界资源。因为每位哲学家只能使用自己面前的两个筷子。对五只叉子进行资源编号0~4，并且定义第i位哲学家左侧的叉子编号为i，哲学家右侧的叉子编号为（i+1）%5（这里要注意对编号为0的进行特殊处理）

方案一：根据奇偶设置不同的拿取顺序

```cpp
#include<semaphore.h>
class DiningPhilosophers {
public:
    vector<sem_t> vec;
    DiningPhilosophers() {
        vec = vector<sem_t>(5);
        for (int i = 0; i < 5; i++) {
            sem_init(&vec[i], 0, 1);
        }
    }

    void wantsToEat(int i,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
		if (i % 2 == 0) {
            sem_wait(&vec[i]);
            sem_wait(&vec[(i + 1) % 5]);
        } else {
            sem_wait(&vec[(i + 1) % 5]);
            sem_wait(&vec[i]);
        }
        pickLeftFork();
        pickRightFork();
        eat();
        putLeftFork();
        putRightFork();
        sem_post(&vec[(i + 1) % 5]);
        sem_post(&vec[i]);
    }
};
```



方案二，加个拿叉子的信号量

```cpp
#include<semaphore.h>
class DiningPhilosophers {
public:
    sem_t mutex;//互斥信号量
    vector<sem_t> fork;//叉子信号量
    DiningPhilosophers() {
        fork = vector<sem_t>(5);  // 注意这里初始化不能使用（5，0）会报错
        for(int i = 0; i < 5; i++) {
           sem_init(&fork[i], 0, 1);//初始化叉子信号量，值为1
        }
        sem_init(&mutex, 0, 1);//初始化互斥信号量
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
        
        sem_wait(&mutex);//对拿叉子的过程加互斥
        
        // 叉子加锁
        sem_wait(&fork[philosopher]);
        sem_wait(&fork[(philosopher+1)%5]);
        
        pickLeftFork();//拿左边叉子
        pickRightFork();//拿右边叉子
        
        sem_post(&mutex);//拿完叉子后可以释放互斥信号量

        eat();

        putLeftFork();
        putRightFork();

        // 叉子解锁，其他的哲学家可以进餐
        sem_post(&fork[philosopher]);//左边叉子解锁
        sem_post(&fork[(philosopher+1)%5]);//右边叉子解锁       
    }
};
```

# 位运算

## 191. 位1的个数

[191. 位1的个数](https://leetcode.cn/problems/number-of-1-bits/) 

```cpp
// 写法1，
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            if (n & (1 << i)) {
                count++;
            }
        }
        return count;
    }
};

class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while (n != 0) {
            result += (n & 1);
            n = n >> 1;
        }
        return result;
    }
};
```

## 位运算实现swap

> 位运算就是直接对整数在内存中的二进制位进行操作
>
> **常用位运算介绍**
>
> **按位与 &** ：相同位的两个数都为1，则为1
>
> > * 可以用来判断奇偶
> >   一个数&1就是取二进制的末尾，`if ((a & 1) == 1)`符合则为奇数
> > * 可以用 O(1) 时间检测整数 n 是否是 2 的幂次。若是，则N的二进制表示中只有一个1，则可以使用`N & (N - 1)`将N唯一的一个1消去，应该返回0。
>
> **按位或 |** ：相同位只要一个为1即为1
>
> **按位异或 ^** ：相同为0，相异为1
>
> > 交换律
> > 结合律`(a^b)^c == a^(b^c)）`
> > `x^x=0，x^0=x`
>
> **按位取反 ~**
>
> > 正数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数
> >
> > ```cpp
> > int reversal(int a) {
> > 	return ~a + 1;
> > }
> > ```
>
> **左移位运算符 <<** ：将一个运算对象的各二进制位全部左移若干位。若左移时舍弃的**高位不包含1**，则每左移一位，相当于该数乘2
>
> 右移位运算符 >> ：操作数每右移一位，相当于该数除2

```cpp
// 通过异或实现swap
// 1、仅对int型适用
// 2、当a == b时，a b将都变为0，因此要慎用，或者增加一个判定
void swap(int &a, int &b) {
    if (a == b) return;
    a ^= b;  // a^b
    b ^= a;  // b^a^b = a
    a ^= b;  // a^b^a = b
}
```



## 剑指 Offer 65. 不用加减乘除做加法

[剑指 Offer 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

位运算

<img src="E:\MarkDown\picture\image-20230627152345786.png" alt="image-20230627152345786" style="zoom:50%;" />

<img src="E:\MarkDown\picture\image-20230627152410324.png" alt="image-20230627152410324" style="zoom:50%;" />

​	因此只需要不断循环，求 非进位和 和 进位，如果进位>0，就再次循环求非进位和 和 进位的和。

> 这样公式就是：（a^b)  ^  ((a&b)<<1) 即：每次无进位求 + 每次得到的进位数--------我们需要不断重复这个过程，直到进位数为0为止
>
> 对于负数情况，在计算机系统中，数值一律用 **补码** 来表示和存储。**补码的优势：** 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 **同时适用于正数和负数的加法**
>
> 注意这里使用了unsigned，在 C++ 的实现中，当我们赋给带符号类型一个超出它表示范围的值时，结果是 undefined；而当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模的余数。因此，我们可以使用无符号类型来防止溢出。

```cpp
class Solution {
public:
    int add(int a, int b) {
        while (b != 0) {
            unsigned int carry = (unsigned int)(a & b) << 1;
            a = a ^ b;  // a保存无进位和
            b = carry;  // b保存进位，只要有进位就一直循环累加
        }
        return a;
    }
};
```

# 补充题目

## 插入5

![image-20230328173554039](E:\MarkDown\picture\image-20230328173554039.png)

负数转为正数，然后找出最大的数字与最小的数字	相减即可
最大的数字是把5插入到一个位置，使左边的数字全部大于等于5，右边相邻的数字小于5
最小的数字是把5插入到一个位置，使左边的数字全部小于等于5，右边相邻的数字大于5
例如983，最大就是9853，最小就是5983



51/68

```cpp
#include<iostream>
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maximumDifference(int num) {
        if (num == 0) return 45;
        if (num < 0) num *= -1;
        string numS = to_string(num);
        
        string minS = numS;
        // 最小的数字是把5插入到一个位置，使左边的数字全部小于等于5，右边相邻的数字大于5
        for (int i = 0;i < numS.size(); i++) {
			if (minS[i] >= '5') {
				minS.insert(i, "5");  // 插在大于5的前面
                break;
            }
            // 如果到最后了也没有大于5的，如12，则插到最后面，125
            if (i == numS.size() - 1) {
				minS += "5";
            }
        }
        string maxS = numS;
        // 最大的数字是把5插入到一个位置，使左边的数字全部大于等于5，右边相邻的数字小于5
        for (int i = 0;i < numS.size(); i++) {
			if (maxS[i] <= '5') {
				maxS.insert(i, "5");  // 插在小于5的前面
                break;
            }
            // 如果到最后了也没有小于5的，如98，则插到最后面，985
            if (i == numS.size() - 1) {
				maxS += "5";
            }
        }
        int maxNum = stoi(maxS);
        int minNum = stoi(minS);
        return maxNum - minNum;
    }
};
int main() {
	Solution s;
	cout << s.maximumDifference(-23);
}
```

## 1647. 字符频次唯一的最小删除次数

[1647. 字符频次唯一的最小删除次数](https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/)

特斯拉笔试题

```cpp
class Solution {
public:
    int minDeletions(string s) {
        int result = 0;
        int freq[26] = {0};
        for (auto i : s) {
            freq[i - 'a']++;
        }
        set<int> set;  // 通过set去重
        // 按字母的顺序来保证频次，比如aacc，则是删除一个c
        for (int i = 0; i < 26; i++) {
            while (freq[i] > 0 && !set.insert(freq[i]).second) {
                result++;
                freq[i]--;
            }
        }
        return result;
    }
};
```



## Morris 中序遍历

https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/



## 171. Excel 表列序号

[171. Excel 表列序号](https://leetcode.cn/problems/excel-sheet-column-number/)

**进制转换** / 找规律

```cpp
class Solution {
public:
    int titleToNumber(string columnTitle) {
        int result = 0;
        for (int i = 0; i < columnTitle.size(); i++) {
            // 注意，先- 'A'再加，否则会爆int
            result = result * 26 - 'A' + columnTitle[i] + 1;
        }
        return result;
    }
};
```

## 887. 鸡蛋掉落

[887. 鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)

就字节和抖音考过，谷歌已经不考了

> 最好的策略是使用二分查找思路，我先去第 (1 + 7) / 2 = 4 层扔一下：
>
> * 如果碎了说明 F 小于 4，我就去第 (1 + 3) / 2 = 2 层试……
> * 如果没碎说明 F 大于等于 4，我就去第 (5 + 7) / 2 = 6 层试……
>
> 以这种策略，最坏情况应该是试到第 7 层鸡蛋还没碎（F = 7），或者鸡蛋一直碎到第 1 层（F = 0）。然而无论那种最坏情况，只需要试 **log7 向上取整等于 3 次**，比刚才尝试 7 次要少，这就是所谓的至少要扔几次。
>
> PS：这有点像 Big O 表示法计算算法的复杂度。
>
> 实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，现在给你了鸡**蛋个数的限制 K**，直接使用二分思路就不行了。
>
> 比如七层楼，只给一个鸡蛋，就只能从低到高**线性扫描**了
>
> 二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？
>
> 很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。
>
> 如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。
>
> 最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。
>



**动态规划**

> 高于楼层会碎，低于或等于不会碎
> <img src="E:\MarkDown\picture\1601009732-UZCCXJ-file_1601009732120.jpeg" alt="img" style="zoom:50%;" />
>
> 注意，这里n层楼，如三层楼，但f的可能是[0, n]
>
> std::map底层数据结构是红黑树
> std::unordered_map底层是hash
> 而unordered_map没有专门的hash提供给std::pair，因此若想在unordered_map中使用pair，可以写个简答的hash转换一下，这里因为k最大值为100，所以哈希函数直接n * 100 + k即可



**超出时间限制**

```cpp
class Solution {
public:
    // unordered_map<pair<int, int>, int> map;
    unordered_map<int, int> map;
    int superEggDrop(int k, int n) {
        if (k == 1) return n;
        if (n == 0) return 0;
        if (map[n * 100 + k]) return map[n * 100 + k];
        int result = INT_MAX;
		for (int i = 1; i <= n; i++) {
		    result = min(result, max(superEggDrop(k - 1, i - 1), superEggDrop(k, n - i)) + 1);
        }
        map[n * 100 + k] = result;
        return result;
    }
};
```

动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度。

函数本身的复杂度就是忽略递归部分的复杂度，这里 dp 函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。

子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。

所以算法的总时间复杂度是 O(K*N^2), 空间复杂度 O(KN)。



**动态规划+二分法**

函数本身的复杂度就是忽略递归部分的复杂度，这里 dp 函数中用了一个二分搜索，所以函数本身的复杂度是 O(logN)。

子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。

所以算法的总时间复杂度是 O(K*N*logN), 空间复杂度 O(KN)。

```cpp
class Solution {
public:
    // unordered_map<pair<int, int>, int> map;
    unordered_map<int, int> map;
    int superEggDrop(int k, int n) {
        if (k == 1) return n;
        if (n == 0) return 0;
        if (map[n * 100 + k]) return map[n * 100 + k];
        int result = INT_MAX;
        // 二分
        int left = 1, right = n;
        while (left <= right) {
            int mid = (left + right) / 2;
            int a = superEggDrop(k - 1, mid - 1);  // 碎了
            int b = superEggDrop(k, n - mid);
            if (a > b) {
                result = min(result, a + 1);
                right = mid - 1;
            } else {
                result = min(result, b + 1);
                left = mid + 1;
            }
        }
        
        map[n * 100 + k] = result;
        return result;
    }
};
```



还有其他O(kn)的方法



## 1792. 最大平均通过率

[1792. 最大平均通过率](https://leetcode.cn/problems/maximum-average-pass-ratio/)

思路是对的，不知道为啥只能通过第一个示例

```cpp
class Solution {
public:
    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
        // 优先队列中存增量
        // 空间复杂度：O(n)
        // 时间复杂度：O((n + k)logn)
        priority_queue <pair<double, int>> que;
        for (int i = 0; i < classes.size(); i++) {
            que.emplace(double(classes[i][0] + 1) / (classes[i][1] + 1) - double(classes[i][0]) / classes[i][1], i);
        }
        for (int i = 1; i <= extraStudents; i++) {
            auto tmp = que.top(); que.pop();
            classes[tmp.second][0]++; classes[tmp.second][1]++;
            que.emplace((double)(classes[tmp.second][0] + 1) / (classes[tmp.second][1] + 1) - (double)classes[tmp.second][0] / classes[tmp.second][1], tmp.second);
        }
        double sum = 0;
        for (auto i : classes) {
            sum += (double)i[0] / i[1];
        }
        return sum / 3;
    }
};
```

错误思路

```cpp
class aa {
public:
    bool operator()(const pair<double, int> &s1, const pair<double, int> &s2) const { 
        return s1.first > s2.first;
    };
};
class Solution {
public:
    friend aa;
    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
        // 每次补一个到最小的里面，再取最小的补
        // 创建一个vector存放每个班现在的通过率，然后在最低的里面加
        // 空间复杂度：O(n)
        // 时间复杂度：O((n + k)logn)
        priority_queue <pair<double, int>,vector<pair<double, int>>,aa> que;
        for (int i = 0; i < classes.size(); i++) {
            que.emplace(double(classes[i][0]) / double(classes[i][1]), i);
        }
        for (int i = 1; i <= extraStudents; i++) {
            auto tmp = que.top(); que.pop();
            que.emplace(double(++classes[tmp.second][0]) / double(++classes[tmp.second][1]), tmp.second);
        }
        double sum = 0;
        double a = 0, b = 0;
        for (auto i : classes) {
            cout << i[0] << " " << i[1] << endl;
            a += i[0];
            b += i[1];
        }
        // while (!que.empty()) {
        //     auto tmp = que.top(); que.pop();
        //     sum += tmp.first;
        // }
        return a / b;
    }
};
```



## 542. 01矩阵/01 Matrix (M)
![在这里插入图片描述](https://img-blog.csdnimg.cn/52034135989142959c9ea36cc213f75f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16)

F1、自己写的错误解法

思路有问题，这里是判断如果Mat为0，存0，如果为1，存上下左右里dp最小的，周围有0就是0，周围有1就是1里面最小的。但是！！！！！！！第一次循环的时候后面和下面都是默认值啊md
```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        // 填充一圈最大值，中间包围m，构成dp，最后输出中间的m
        int h=mat.size(),w=mat[0].size();
        vector<vector<int>> m(h, vector<int>(w, 0));   // 存放输出结果
        int dp[h+2][w+2];  // 上下左右进行max的扩充
        memset(dp,0x3f,sizeof(dp));
        for(int i=0;i<h;i++){
            for(int j=0;j<w;j++){
                if(mat[i][j]==0) {dp[i+1][j+1]=0;m[i][j]=dp[i+1][j+1];}
                else if(mat[i][j]==1){                   
                    dp[i+1][j+1]=min({dp[i+2][j+1],dp[i][j+1],dp[i+1][j+2],dp[i+1][j]})+1;
                    m[i][j]=dp[i+1][j+1];
                }
            }
        }
        return m;
    }
};
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/dadffee08bf043c5ade365e5e721066d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16)

F2、正确解法

填充的dp为最大值
第一轮左上到右下，取左和上和本身里的最小值；第二轮右下到左上，取下和右和本身里的最小值
![在这里插入图片描述](https://img-blog.csdnimg.cn/46f90b6fd02742b5abc439cc9763530c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16)

```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        // 这个为空的判定，老忘
        if(matrix.empty()) return {};
        int h=mat.size(),w=mat[0].size();
        vector<vector<int>> m(h, vector<int>(w, INT_MAX-1));   // INT_MAX = 2^31-1
        for(int i=0;i<h;i++){
            for(int j=0;j<w;j++){
                if(mat[i][j]==0) m[i][j]=0;
                else{
                    if(j>0) m[i][j]=min(m[i][j],m[i][j-1]+1);//顺序是一行一行的，所以先判断j后判断i
                    if(i>0) m[i][j]=min(m[i][j],m[i-1][j]+1);
                }
            }
            
        }
        for(int i=h-1;i>=0;i--){
            for(int j=w-1;j>=0;j--){
                if(j<w-1) m[i][j]=min(m[i][j],m[i][j+1]+1);
                if(i<h-1) m[i][j]=min(m[i][j],m[i+1][j]+1);
            }
        }
        return m;
    }
};
```





## 413、等差数列划分Arithmetic Slices(M)

![在这里插入图片描述](https://img-blog.csdnimg.cn/d42e825ffc4547d48df11c8df44114a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bqU6ZKf5LqM5LqU,size_20,color_FFFFFF,t_70,g_se,x_16)

F1 自己写的

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n=nums.size();
        if(n<3) return 0;
        int cha=nums[0]-nums[1],a=0,count=1;
        for(int i=1;i<n-1;i++){
            if(cha==nums[i]-nums[i+1]) count++;
            else{
                count=1;
                cha=nums[i]-nums[i+1];
            }
            a+=count-1;// 这里count定义为两个数之间的间隔，比如三个数的等差，count为2。然后c为2，a+1，c变为3，a=3，在原来基础上加了c-1
        }
        return a;
    }
};
```

执行用时 4ms

F2 标准

可以发现，子数组从3->1 4->3 5-> 6，是每多一个，dp+1，然后再累加和。只需要判断前两个和后两个的差是否相等。这里创建了n的数组，填充0，这样的话即使中间断掉，再有三个连续的满足条件的时候，也是从0开始累加。

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n=nums.size();
        if(n<3) return 0;
        vector<int> dp(n,0);
        for(int i=2;i<n;i++){
            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){
                dp[i]=dp[i-1]+1;
            }
        }
        return accumulate(dp.begin(),dp.end(),0);
    }
};
```



# 周赛

## ==第 100 场双周赛==

## 2591. 将钱分给最多的儿童

[2591. 将钱分给最多的儿童](https://leetcode.cn/problems/distribute-money-to-maximum-children/)

20min

```cpp
class Solution {
public:
    int distMoney(int money, int children) {
        if (money < children) return -1;
        if (money == children * 8) return children;
        
        int a = money / 8;  // 有几个能分到8
        int b = money % 8;  // 余数
        
        int cuff = children - a;  // 剩下几个没钱的
        if (a >= children) {  // 情况1，每个人分到8后还多一点
            return children - 1;
        } else if (cuff <= b) {  // 情况2：余数够给剩下的人分
            // 看看会不会有人分到4美元
            if (cuff == 1 && b == 4) return a - 1;  // 只有这一种情况，因为cuff必小于8
            return a;
        } else { // 余数不够剩下的人分
            while (cuff > b) {
                a--;
                b += 8;
                cuff++;
            }
            return a;
        }
    }
};
```

比较普遍的写法，按7分

```cpp
class Solution {
public:
    int distMoney(int money, int children) {
        money -= children; // 每人至少 1 美元
        if (money < 0) return -1;
        int ans = min(money / 7, children); // 初步分配，让尽量多的人分到 8 美元
        money -= ans * 7;
        children -= ans;
        if (children == 0 && money || // 如果有剩的钱，必须找一个前面分了 8 美元的人，分完剩余的钱
            children == 1 && money == 3) // 不能有人恰好分到 4 美元
            --ans;
        return ans;
    }
};
```



## 2592. 最大化数组的伟大值

[2592. 最大化数组的伟大值](https://leetcode.cn/problems/maximize-greatness-of-an-array/)

10min

O(nlogn)

```cpp
class Solution {
public:
    int maximizeGreatness(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        
        int result = 0;
        for (int i = 0, j = 1  ; i < nums.size() && j < nums.size();j++) {
            if (nums[j] > nums[i]) {
                result++;
                i++;  
            }
        }
        
        return result;
    }
};
```

简洁写法

O(nlogn)

```cpp
class Solution {
public:
    int maximizeGreatness(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int i = 0;
        for (auto x : nums) {
            if (x > nums[i]) i++;
        }
        return i;
    }
};
```

O(n)写法，没看懂

![image-20230402155238011](E:\MarkDown\picture\image-20230402155238011.png)

```cpp
class Solution {
public:
    int maximizeGreatness(vector<int> &nums) {
        int mx = 0;
        unordered_map<int, int> cnt;
        for (int x : nums)
            mx = max(mx, ++cnt[x]);
        return nums.size() - mx;
    }
};
```



报错了

```cpp
class Solution {
public:
    long long findScore(vector<int>& nums) {
        vector<int> used(nums.size(), 0);
        int count = 0;  // 统计被标记的个数
        int tag = 0;  // 记录最小值的下标
        int result = 0;
        while (count != nums.size()) {
            for (int i = 0; i < nums.size(); i++) {
                if (used[i] == 0 && nums[i] < nums[tag]) {
                    tag = i;
                }
            }
            result += nums[tag];
            used[tag] = 1;
            count++;
            if (tag < nums.size() - 1) {
                used[tag + 1] = 1;
                count++;
            }
            if (tag > 0) {
                used[tag - 1] = 1;
                count++;
            }
            
        }
        return result;
    }
};
```

## ==第 101 场双周赛==

## 6327. 从两个数字数组里生成最小数字

[6327. 从两个数字数组里生成最小数字](https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/)

给你两个只包含 1 到 9 之间数字的数组 `nums1` 和 `nums2` ，每个数组中的元素 **互不相同** ，请你返回 **最小** 的数字，两个数组都 **至少** 包含这个数字的某个数位。

![image-20230401231621757](E:\MarkDown\picture\image-20230401231621757.png)

**排序后双指针**

10min

时间复杂度：O(mlogm + nlongn + m)

```cpp
class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        // 情况1：有相同数字
        // 情况2：没有相同数字，找最小的组合
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int i = 0, j = 0;
        int tag = -1;
        for (; i < nums1.size() && j < nums2.size();) {
            if (nums1[i] == nums2[j]) {
                tag = i;
                break;
            }
            else if (nums1[i] > nums2[j]) j++;
            else i++;
        }
        if (tag != -1) return nums1[tag];  // 情况1
        // 情况2
        if (nums1[0] > nums2[0]) return nums2[0] * 10 + nums1[0];
        return nums1[0] * 10 + nums2[0];
    }
};
```

**哈希**

时间复杂度O(m + n)，空间复杂度O(10)=O(1)

```cpp
class Solution {
public:
    int minNumber(vector<int>& nums1, vector<int>& nums2) {
        int vec[10] = {0};
        int min1 = 10, min2 = 10, result = 10;
        for (auto i : nums1) {
            vec[i]++;
            min1 = min(min1, i);
        }
        for (auto i : nums2) {
            vec[i]++;
            // 有重复
            if (vec[i] == 2) result = min(result, i);
            min2 = min(min2, i);
        }
        if (result != 10) return result;
        return min(10 * min1 + min2, 10 * min2 + min1);
    }
};
```



## 6328. 找到最大开销的子字符串

[6328. 找到最大开销的子字符串](https://leetcode.cn/problems/find-the-substring-with-maximum-cost/)

给你一个字符串 `s` ，一个字符 **互不相同** 的字符串 `chars` 和一个长度与 `chars` 相同的整数数组 `vals` 。

**子字符串的开销** 是一个子字符串中所有字符对应价值之和。空字符串的开销是 `0` 。

**字符的价值** 定义如下：

* 如果字符不在字符串 chars 中，那么它的价值是它在字母表中的位置（下标从 1 开始）。 	
  * 比方说，`'a'` 的价值为 `1` ，`'b'` 的价值为 `2` ，以此类推，`'z'` 的价值为 `26` 。
* 否则，如果这个字符在 `chars` 中的位置为 `i` ，那么它的价值就是 `vals[i]` 。

请你返回字符串 `s` 的所有子字符串中的最大开销。

![image-20230401231811596](E:\MarkDown\picture\image-20230401231811596.png)

**暴力**

12min

O(M * N + N)

```cpp
class Solution {
public:
    int maximumCostSubstring(string s, string chars, vector<int>& vals) {
        // 1.得到每个字母的价值，O(M*N)
        vector<int> prices(s.size(), 1001);
        for (int a = 0; a < s.size(); a++) {  // 这里可以简化，因为s中有重复字符
            for (int i = 0; i < chars.size(); i++) {
                if (s[a] == chars[i]) {
                    prices[a] = vals[i];
                    break;
                }
            }
            if (prices[a] == 1001) prices[a] = s[a] - 'a' + 1;
        }
        // 2.最大连续和
        int sum = 0;
        int result = 0;
        for (auto i : prices) {
            sum += i;
            result = max(result, sum);
            if (sum < 0) sum = 0;
        }
        return result;
        
    }
};
```

**哈希简化第一步**

O(M + N)

```cpp
class Solution {
public:
    int maximumCostSubstring(string s, string chars, vector<int>& vals) {
        int map[26] = {0};  // 存储每个字母的价值
        int count = 1;
        for (auto& i : map) i = count++; // 设初值为1到26
        for (int i = 0; i < chars.size(); i++) map[chars[i] - 'a'] = vals[i];
        // 最大子数组和
        int sum = 0, result = 0;
        for (auto i : s) {
            sum += map[i - 'a'];
            result = max(result, sum);
            if (sum < 0) sum = 0;
        }
        return result;
    }
};
```

## `6329. 使子数组元素和相等(裴蜀等式，没看懂)`

[6329. 使子数组元素和相等](https://leetcode.cn/problems/make-k-subarray-sums-equal/)            

给你一个下标从 **0** 开始的整数数组 `arr` 和一个整数 `k` 。数组 `arr` 是一个循环数组。换句话说，数组中的最后一个元素的下一个元素是数组中的第一个元素，数组中第一个元素的前一个元素是数组中的最后一个元素。

你可以执行下述运算任意次：

* 选中 `arr` 中任意一个元素，并使其值加上 `1` 或减去 `1` 。

执行运算使每个长度为 `k` 的 **子数组** 的元素总和都相等，返回所需要的最少运算次数。

**子数组** 是数组的一个连续部分。

![image-20230401231840472](E:\MarkDown\picture\image-20230401231840472.png)



```cpp
class Solution {
public:
    long long makeSubKSumEqual(vector<int> &arr, int k) {
        int n = arr.size();
        k = gcd(k, n);  // 最大公约数
        vector<vector<int>> g(k);
        for (int i = 0; i < n; ++i)
            g[i % k].push_back(arr[i]);

        long long ans = 0;
        for (auto &b: g) {
            nth_element(b.begin(), b.begin() + b.size() / 2, b.end());
            for (int x: b)
                ans += abs(x - b[b.size() / 2]);
        }
        return ans;
    }
};
```

## `6330. 图中的最短环(不太懂)`

[6330. 图中的最短环](https://leetcode.cn/problems/shortest-cycle-in-a-graph/)

现有一个含 `n` 个顶点的 **双向** 图，每个顶点按从 `0` 到 `n - 1` 标记。图中的边由二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和 `vi` 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。

返回图中 **最短** 环的长度。如果不存在环，则返回 `-1` 。

**环** 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。

<img src="E:\MarkDown\picture\image-20230401231925094.png" alt="image-20230401231925094" style="zoom: 67%;" /><img src="E:\MarkDown\picture\image-20230401231940184.png" alt="image-20230401231940184" style="zoom:67%;" />

BFS

单个起点的BFS
<img src="E:\MarkDown\picture\image-20230402152226705.png" alt="image-20230402152226705" style="zoom:47%;" />

但从其他起点跑BFS会得到更短的环，因此循环遍历每个点作为起点

```cpp
class Solution {
public:
    int findShortestCycle(int n, vector<vector<int>> &edges) {
        vector<vector<int>> g(n);
        for (auto &e: edges) {
            int x = e[0], y = e[1];
            g[x].push_back(y);
            g[y].push_back(x); // 建图
        }
        /*
        0 1
        1 0, 2
        2 1, 0
        ——————————————
        3 4, 6
        4 3, 5
        5 4, 6
        6 5, 3
        */

        int dis[n]; // dis[i] 表示从 start 到 i 的最短路长度
        auto bfs = [&](int start) -> int {
            // 给dis数组中的全部元素赋值-1
            memset(dis, -1, sizeof(dis));
            dis[start] = 0;
            queue<pair<int, int>> q;
            q.emplace(start, -1);  // 如这里是0入队
            while (!q.empty()) {
                auto [x, fa] = q.front();
                q.pop();
                for (int y: g[x])  // g[0] = {1}，0出队，1入队；下一轮则是1出队，0和2入队
                    if (dis[y] < 0) { // 第一次遇到
                        dis[y] = dis[x] + 1;
                        q.emplace(y, x);
                    } else if (y != fa) // 第二次遇到
                        // 由于是 BFS，后面不会遇到更短的环了
                        return dis[x] + dis[y] + 1;
            }
            return INT_MAX; // 该连通块无环
        };
        int ans = INT_MAX;
        for (int i = 0; i < n; ++i) // 枚举每个起点跑 BFS
            ans = min(ans, bfs(i));
        return ans < INT_MAX ? ans : -1;
    }
};
```

时间复杂度：O(nm)，其中 m 为 edges 的长度。每次 BFS 需要 O(m) 的时间。
空间复杂度：O(n+m)

# 排序



[912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

[](https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485556&idx=1&sn=344738dd74b211e091f8f3477bdf91ee&chksm=fa0e67f5cd79eee3139d4667f3b94fa9618067efc45a797b69b41105a7f313654d0e86949607&scene=21#wechat_redirect)

![image-20230202223501105](E:\MarkDown\picture\image-20230202223501105.png)

也要清楚每个方法具体的比较次数

**冒泡排序**: 每一趟每两个相邻元素都要进行比较，对于 n 个元素的序列，第一趟需要比较 n-1 次，第二趟比较 n-2 次…最后一趟1次，所以一共是 (n-1)+(n-2)+...+1 = **n(n-1)/2** = 10 次。

**选择排序**: 每趟找出最小元素，然后交换到前面位置，对于n个元素的序列，找出最小元素需要比较(n-1)次。第一回合后，序列只剩下(n-1)个元素，下一次找最小元素还需要(n-2)次比较, 最后直到2个元素需要比较1次。所以最后比较次数总共为(n-1)+(n-2)+...+1= **n(n-1)/2**= 10次。

**直接插入排序**: 插入排序基本原理是假定前面i个元素已经排好，接下来将第(i+1)个元素插入到前面的序列中，保证有序。循环插入所有元素，即完成排序。插入第(i+1)元素时，从后往前扫描，寻找比其小的元素。{5,2,3,4,1}-1次->{2,5,3,4,1}-2次->{2,3,5,4,1}-2次->{2,3,4,5,1}-4次->{1,2,3,4,5},所以一共比较1+2+2+4 = 9次。

**归并排序**: 先分解（左图）再归并（右图），一共比较1+1+2+4 = 8次。

![img](E:\MarkDown\picture\332391_1595839985045_39E2432A51EA0863BF79296798ED56FE.png)

![image-20230213125004139](E:\MarkDown\picture\image-20230213125004139.png)

> 排序算法的稳定性：
> 	指若有重复数据时，若这些重复数据的相对次序保持不变，则是稳定的；反之则是不稳定的。
>
> 一般只需要记住，**快排、堆排、选择排序和希尔排序是不稳定的**即可



## xjj

```cpp
#include <bits/stdc++.h>
#include<iostream>
using namespace std;


//打印数据
void print_vec(const vector<int>& vec) {
	for (auto it = vec.begin(); it != vec.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}


// 插入排序 稳定排序  时间复杂度O（n*n），空间复杂度O（1）
void insertSort(vector<int>& vec) {
	// 每次将新元素插入到已排序的有序队列里面
	int n = vec.size();
	for (int i = 1; i < n; i++) {
		if (vec[i] > vec[i - 1]) continue;
		int temp = i;//记录新元素每次交换后的位置
		for (int j = i - 1; j >= 0; j--) {

			if (vec[temp] < vec[j]) {//只要比排序数小，就交换两者位置
				swap(vec[temp], vec[j]);
				temp = j;//记录新元素的位置
			}
			else break;
		}

	}
}


//归并排序 稳定排序 时间复杂度O（n*logn），空间复杂度O（n）
//算法思想
//1、把长度为n的输入序列分成两个长度为n / 2的子序列；
//2、对这两个子序列分别采用归并排序；
//3、 将两个排序好的子序列合并成一个最终的排序序列。
void mergeSort(vector<int>& vec,vector<int> &data,int start,int end) {
	//vec为需要排序的数组，data为放置排序好的子序列的数组，取闭区间[start,end]
	if (start >= end) return;
	int mid = start + (end - start) / 2;
	mergeSort(vec, data, start, mid);
	mergeSort(vec, data, mid + 1, end);

	//p1为前半个数组的头指针，p2为后半个数组的头指针，p为data数组的头指针
	int p1 = start, p2 = mid + 1, p = start;
	//int len = (end - start) * 2;
	for (; p <= end; p++) {
		//这里用if进行判断的时候很重要，容易把情况漏掉
		//刚开始我写成if(p1<=mid&&vec[p1]<vec[p2]){} else{}  ，这样写漏掉了一些情况
		if (p1<=mid&&p2>end) {
			data[p] = vec[p1++];
		}
		else if(p1>mid&&p2<=end){
			data[p] = vec[p2++];
		}
		else {//两个都没越界
			data[p] = vec[p1] > vec[p2] ? vec[p2++] : vec[p1++];
		}
	}
	for (int i = start; i <= end; i++) {
		vec[i] = data[i];
	}

}


// 快速排序 不稳定排序  时间复杂度O（n*log n），空间复杂度O(logn)(递归会使用栈）
//1、选取第一个数为基准
//2、将比基准小的数交换到前面，比基准大的数交换到后面
//3、对左右区间重复第二步，直到各区间只有一个数
void quickSort(vector<int>& vec,int index_start,int index_end) {
	//使用递归 传入整个数组和需要处理的数据起始位置[index_start，index_end]
	
	if (index_end <= index_start) return;//递归终止条件

	int temp = index_start;//选取第一个数为基准
	for (int i = temp + 1; i <= index_end;i++ ) {
		if (vec[i] < vec[temp]) {
			for (int j = i; j > temp; j--) {
				//vec[i]依次和temp开始一直到i-1位置的数进行交换，直到i位置数字换到vec[temp]前面去
				swap(vec[j], vec[j - 1]);//两两交换
				
			}
			temp++;//记录基准数更新后的位置
		}

	}
	quickSort(vec, index_start, temp - 1);
	quickSort(vec, temp + 1, index_end);

}

// 希尔排序 不稳定排序  时间复杂度O（n*n），空间复杂度O（1）
// 插入排序的变种，局部有序
void insert_sort(vector<int>&vec, int gap,int start_index) {//将start_index插入到本组中正确的位置
	int insert_num = vec[start_index];
	int i = start_index - gap;
	for (; i >=0&&vec[i]>insert_num; i=i-gap) {
		vec[i + gap] = vec[i];
	}
	vec[i + gap] = insert_num;
}
void shellSort(vector<int>& vec) {
	
	for (int gap = vec.size() / 2; gap >= 1; gap /= 2) {
		for (int j = gap; j < vec.size(); j++) {
			insert_sort(vec, gap, j);
		}
	}
}





// 计数排序
void countSort(vector<int>& vec) {

}

int main() {
	vector<int> vec{ 10,8,4,6,9,10,123,6,2,14,3,8,5 };

	//cout << "------快速排序-------" << endl;
	//quickSort(vec,0,vec.size()-1);
	//print_vec(vec);

	//cout << "------归并排序-------" << endl;
	//vector<int> data(vec.size(), 0);
	//mergeSort(vec,data,0,vec.size()-1);
	//print_vec(data);

	cout << "------堆排序-------" << endl;
	heapSort(vec);
	print_vec(vec);

	return 0;

}


int main() {
	vector<int> vec1 = {5, 10, 10, -1, -1, 2, 3};
	vector<int> vec = {1, 2, 10, -1, -1, 2, 20};
	TreeNode* root = aa(vec);
	
	/*********************** 解题 ***********************/
	int sum = bb(root);
	
	// 找有没有和为sum/2的子树
	if (sum % 2 == 1) cout << false;
	else {
		cc(root, sum / 2);
		cout << tag;
	}
	
	return 0;
}
```



> 以下实现默认单调递增

## *O(n^2)*

## 冒泡

* 两层循环，不断将大的向左移动；
* 稳定排序，不改变相对位置（前提是nums[j] > nums[j + 1]，而不是 >= ）

* 优化：设定一个临时遍历来标记该数组是否已经有序，如果有序了就不用遍历
* 优化后最好情况的时间复杂度：0(n)

```cpp
void sort(vector<int>& nums) {
    int size = nums.size();
    for (int i = 0; i < size; i++) {
        bool tag = true;
        for (int j = 0; j < size - i - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                tag = false;
                swap(nums[j], nums[j + 1]);
            }
        }
        if (tag == true) break;
    }
}
```

## 选择排序

* 最好和最差情况都是O(n^2)

* 找到数组中最小的元素，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。
* **不稳定排序**，如[5 8 5 2 9]，第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。

```cpp
void sort(vector<int>& nums) {
    for (int i = 0; i < nums.size(); i++) {
        int min = i;
        for (int j = i + 1; j < nums.size(); j++) {
            if (nums[min] > nums[j]) min = j;
        }
        swap(nums[i], nums[min]);
    }
}
```

## 插入排序

* 将数组视为两个区域，即已排序区域和未排序区域。
* 初始化时已排序区域为空。我们将数组中第一个数视为在已排序区域中，然后key从数组中第二个数开始遍历，将每个key插入到已排序区域中合适的位置
* 最好情况O(n)
* 稳定排序

```cpp
void sort(vector<int>& nums) {
    for (int i = 1; i < nums.size(); i++) {
        // 注意，这里必须用key记录nums[i]的值，因为后续会改变i位置的值
		int key = nums[i];
         int j;  // 插入的位置
		for (j = i - 1; j >= 0; j--) {
            if (nums[j] > key) nums[j + 1] = nums[j];
            else break;
        }
        nums[j + 1] = key;  // 插入数据
    }
}
```

## *O(nlog^2n)*


$$
O(nlog^2n)
$$

## 希尔排序(未看)

也称作“缩小增量排序”，是插入排序的一种更高效的改进版本

插入排序对于大规模的乱序数组的时候效率是比较慢的，因为它每次只能将数据移动一位，希尔排序为了加快插入的速度，让数据移动的时候可以实现跳跃移动，节省了一部分的时间开支

```cpp
void sort(vector<int>& nums) {
    for (int i = 1; i < nums.size(); i++) {
		int gap = 1;
		while (gap < nums.size()) {
			gap = gap * 3 + 1;
		}
		while (gap > 0) {
			for (int i = gap; i < nums.size(); i++) {
				int tmp = nums[i];
				int j = i - gap;
				//跨区间排序
				while (j >= 0 && nums[j] > tmp) {
					nums[j + gap] = nums[j];
					j -= gap;
				}
				nums[j + gap] = tmp;
			}
			gap = gap / 3;
		}
    }
}
```

## 归并排序

![image-20230215230605179](E:\MarkDown\picture\image-20230215230605179.png)

![image-20230213124844655](E:\MarkDown\picture\image-20230213124844655.png)

归并算法的核心思想是分治法，就是将一个数组一刀切两半，递归切，直到切成单个元素，然后重新组装合并，单个元素合并成小数组，两个小数组合并成大数组，直到最终合并完成，排序完毕

![image-20230427213326432](E:\MarkDown\picture\image-20230427213326432.png)

merge 方法中只有一个 for 循环，直接就可以得出每次合并的时间复杂度为 O(n) ，而分解数组每次对半切割，属于对数时间 O(log n) ，合起来等于 O(logn * logn) ，也就是说，总的时间复杂度为 O(nlog^2(n)) 

关于空间复杂度，只在最开始申请了一个临时数组，所以空间复杂度为 O(n)。

**排序数组**

```cpp
class Solution {
public:
    // 归并
    void merge(vector<int>& nums, vector<int>& tmp, int start, int mid, int end) {
        // tmp临时数组保存不断更新的nums，使得可以在nums上直接修改
        for (int i = start; i <= end; i++) {
            tmp[i] = nums[i];
        }
        int left = start;  // 左数组起始下标
        int right = mid + 1;  // 右数组起始下标
        for (int i = start; i <= end; i++) {
            // 必须将数组是否遍历完的判定放在前面
            if (left > mid) nums[i] = tmp[right++];  // 左数组已遍历完
            else if (right > end) nums[i] = tmp[left++];  // 右
            else if (tmp[left] > tmp[right]) nums[i] = tmp[right++];
            else nums[i] = tmp[left++];  // tmp[left] <= tmp[right]
        }
    }
    // 分解
    void sort(vector<int>& nums, vector<int>& tmp, int start, int end) {
        if (start >= end) return;
        int mid = start + (end - start) / 2;
        sort(nums, tmp, start, mid);
        sort(nums, tmp, mid + 1, end);
        merge(nums, tmp, start, mid, end);  // 也可以把merge的代码复制到这
    }
    vector<int> sortArray(vector<int>& nums) {
        vector<int> tmp(nums.size());
        sort(nums, tmp, 0, nums.size() - 1);
        return nums;
    }
};
```

**排序链表**

递归法，时间复杂度可以满足O(nlogn)，但因为使用了递归，空间复杂度为O(logn)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        // fast = head->next时对偶数个才能均分
        ListNode* fast = head->next, *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        // 注意，分解后是两个无序的链表，不能直接用《合并两个排序的链表》
        ListNode* node = slow->next;
        slow->next = nullptr;
        ListNode* firN = sortList(head);
        ListNode* secN = sortList(node);
        return merge(firN, secN);
        
    }
    ListNode* merge(ListNode* firN, ListNode* secN) {
        // 对两个链表进行排序合并
        ListNode* tmp = new ListNode(-1);
        ListNode* result = tmp;
        while (firN && secN) {
            if (firN->val < secN->val) {
                tmp->next = firN;
                firN = firN->next;
            } else {
                tmp->next = secN;
                secN = secN->next;
            }
            tmp = tmp->next;
        }
        tmp->next = firN ? firN : secN;
        return result->next;
    }
};
```

合在一起的写法

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        // fast = head->next时对偶数个才能均分
        ListNode* fast = head->next, *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        // 注意，分解后是两个无序的链表，不能直接用《合并两个排序的链表》
        ListNode* node = slow->next;
        slow->next = nullptr;
        ListNode* firN = sortList(head);
        ListNode* secN = sortList(node);
        
        // 到这里就是对两个链表进行排序了
        ListNode* tmp = new ListNode(-1);
        ListNode* result = tmp;
        while (firN && secN) {
            if (firN->val < secN->val) {
                tmp->next = firN;
                firN = firN->next;
            } else {
                tmp->next = secN;
                secN = secN->next;
            }
            tmp = tmp->next;
        }
        tmp->next = firN ? firN : secN;
        return result->next;
    }
};
```

**迭代法**

空间复杂度O(1)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;
        ListNode* node = new ListNode(-1);
        node->next = head;
        // 统计链表长度
        int length = 0;
        ListNode* tmp = head;
        while (tmp) {
            length++;
            tmp = tmp->next;
        }
        for (int size = 1; size < length; size = size * 2) {
            ListNode* cur = node->next;
            ListNode* tail = node;  // tail将合并好的更新到node上
            while (cur) {
                // 每次切两部分下来，进行合并
                ListNode* left = cur;  // 左部分起始结点
                ListNode* right = split(cur, size);  // 右部分
                cur = split(right, size);  // 剩下的
                tail->next = merge(left, right);
                while (tail->next) {
                    tail = tail->next;
                }
            }
        }
        return node->next;
    }
    // 将node切出来step
    ListNode* split(ListNode* node, int step) {
        if (node == nullptr) return node;
        ListNode* tmp = node;
        for (int i = 0; i < step - 1; i++) {
            if (node->next == nullptr) break;
            node = node->next;
        }
        ListNode* right = node->next;  // 下个链表的表头
        node->next = nullptr;  // 分割
        return right;

    }
    // 对两个链表进行排序合并
    ListNode* merge(ListNode* firN, ListNode* secN) {
        ListNode* tmp = new ListNode(-1);
        ListNode* result = tmp;
        while (firN && secN) {
            if (firN->val < secN->val) {
                tmp->next = firN;
                firN = firN->next;
            } else {
                tmp->next = secN;
                secN = secN->next;
            }
            tmp = tmp->next;
        }
        tmp->next = firN ? firN : secN;
        return result->next;
    }
};
```



## *O(nlogn)*

## 快速排序

D:\基础学习\数据结构\数据结构与算法\数据结构与算法之美\极客时间 _ 数据结构与算法之美12--- 排序（下）：如何用快排思想在O(n)内查找第K大元素？

### 单路快排

对数组中下标从left到right之间的一组数据，选择right作为分区点。我们的最终目的是将比nums[right]小的放到左边，大的放到右边，最后将nums[right]放到中间，使得数组分为三部分。最后返回中间位置的下标，以此为基准再对左右数组进行排序

**partition函数图解**

<img src="E:\MarkDown\picture\image-20230212151638689.png" alt="partition函数图解" style="zoom: 67%;" />

我们通过游标i把left到right - 1分成两部分。left到i- 1的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，i到right - 1是“未处理区间”。我们每次都从未处理的区间i到right - 1中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i] 的位置(通过swap实现)

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int partition(vector<int>& nums, int left, int right) {
    // j向后遍历，找比pivot小的，找到了就和i交换，然后i再向后遍历
    // i指向的是比pivot大的
    int i = left;
    int pivot = nums[right];
    for (int j = i; j < right; j++) {
        if (nums[j] < pivot) {
            swap(nums[i], nums[j]);
            i++;
        }
    } 
    swap(nums[i], nums[right]);
    return i;
}
void quick_sort_c(vector<int>& nums, int left, int right) {
	if (left >= right) return;
    int pivot = partition(nums, left, right);
    quick_sort_c(nums, left, pivot - 1);
    quick_sort_c(nums, pivot + 1, right);
}


int main() {
	int n = 5;
	vector<int> nums= {3, 6, 2, 5, 8};
	quick_sort_c(nums, 0, n - 1);
	for (int i : nums) {
		cout << i << endl;
	}
}
```

力扣，超时

```cpp
class Solution {
public:
    int partition(vector<int>& nums, int left, int right) {
        // j向后遍历，找比pivot小的，找到了就和i交换，然后i再向后遍历
        // i指向的是比pivot大的
        int i = left, j = left, pivot = nums[right];
        while (j < right) {
            if (nums[j] < pivot) {
                swap(nums[i], nums[j]);
                i++;
            }
            j++;
        }
        swap(nums[i], nums[right]);
        return i;
    }
    void quick_sort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        int pivot = partition(nums, left, right);
        quick_sort(nums, left, pivot - 1);
        quick_sort(nums, pivot + 1, right);
    }
    vector<int> sortArray(vector<int>& nums) {
        quick_sort(nums, 0, nums.size() - 1);
        return nums;
    }
};
```

时间复杂度：O(nlogn)。但在极端情况下，如本来就是有序的，每次选最后一个元素作为pivot，则需要进行N次分区操作，每次需要扫描n/2个元素，时间复杂度就为O(n^2)

### 随机选择哨兵

导致快排时间复杂度降为O(n^2)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？可以采用随机法：每次从要排序的区间中，随机选择一个元素作为分区点

力扣，超时

```cpp
class Solution {
public:
    int partition(vector<int>& nums, int left, int right) {
        // j向后遍历，找比pivot小的，找到了就和i交换，然后i再向后遍历
        // i指向的是比pivot大的
        // 随机选择哨兵，随机选择一个left到right范围内的，与right交换
        // rand() % (right - left + 1) 生成0到right - left范围内，再+left生成left到right范围内
        swap(nums[right], nums[rand() % (right - left + 1) + left]);
        int i = left, j = left, pivot = nums[right];
        while (j < right) {
            if (nums[j] < pivot) {
                swap(nums[i], nums[j]);
                i++;
            }
            j++;
        }
        swap(nums[i], nums[right]);
        return i;
    }
    void quick_sort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        int pivot = partition(nums, left, right);
        quick_sort(nums, left, pivot - 1);
        quick_sort(nums, pivot + 1, right);
    }
    vector<int> sortArray(vector<int>& nums) {
        quick_sort(nums, 0, nums.size() - 1);
        return nums;
    }
};
```

### 双路快排

对于有**大量重复元素**的数组，使用单路快排会造成pivot左右的数组长度极度不平衡，甚至会退化到O(n^2)

partition 过程使用两个索引值（i、j）用来遍历数组，将 **<v** 的元素放在索引i所指向位置的左边，而将 **>v** 的元素放在索引j所指向位置的右边，**v** 代表标定值。这样对于重复元素，也近乎能将其平分

**图示为pivot选择left**

![image-20230212164430007](E:\MarkDown\picture\image-20230212164430007.png)

从数组左右两边进行扫描，先从左往右找到一个大于基准值的元素，将下标指针记录下来，然后转到从右往左扫描，找到一个小于基准值的元素，交换这两个元素的位置，重复步骤，直到左右两个指针相遇，再将基准值与左侧最右边的元素交换

```cpp
class Solution {
public:
    int partition(vector<int>& nums, int left, int right) {
        // 随机选择哨兵，随机选择一个left到right - 范围内的，与right交换
        swap(nums[right], nums[rand() % (right - left + 1) + left]);
        // 数组两边同时遍历，将小于的放i左，大于的放i右
        int i = left, j = right - 1, pivot = nums[right];
        while (true) {
            while (i <= right - 1 && nums[i] < pivot) i++;
            while (j >= left && nums[j] > pivot) j--;
            if (i >= j) break;
            swap(nums[i], nums[j]);
            i++; j--;
        }
        // 最后i的位置是大于或等于nums[right]即pivot的
        swap(nums[i], nums[right]);
        return i;
    }
    void quick_sort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        int pivot = partition(nums, left, right);
        quick_sort(nums, left, pivot - 1);
        quick_sort(nums, pivot + 1, right);
    }
    vector<int> sortArray(vector<int>& nums) {
        quick_sort(nums, 0, nums.size() - 1);
        return nums;
    }
};
```

简化版

```cpp
class Solution {
public:
    void partition(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        // 随机选择哨兵，随机选择一个left到right - 1范围内的，与right交换
        swap(nums[right], nums[rand() % (right - left + 1) + left]);
        // 数组两边同时遍历，将小于的放i左，大于的放i右
        int i = left, j = right - 1, pivot = nums[right];
        while (true) {
            while (i <= right - 1 && nums[i] < pivot) i++;
            while (j >= left && nums[j] > pivot) j--;
            if (i >= j) break;
            swap(nums[i], nums[j]);
            i++; j--;
        }
        // 最后i的位置是大于或等于nums[right]即pivot的
        swap(nums[i], nums[right]);
        partition(nums, left, i - 1);
        partition(nums, i + 1, right);
    }
    vector<int> sortArray(vector<int>& nums) {
        partition(nums, 0, nums.size() - 1);
        return nums;
    }
};
```

### 三路快排

是双路快速排序的进一步改进版本，三路排序算法把排序的数据分为三部分，分别为小于 v，等于 v，大于 v，v 为标定值，这样三部分的数据中，**等于 v 的数据在下次递归中不再需要排序**，小于 v 和大于 v 的数据也不会出现某一个特别多的情况，通过此方式三路快速排序算法的性能更优

我们分三种情况进行讨论 partiton 过程，i 表示遍历的当前索引位置：

（1）当前处理的元素 e=V，元素 e 直接纳入蓝色区间，同时i向后移一位

![image-20230213093103955](E:\MarkDown\picture\image-20230213093103955.png)

![image-20230213093117752](E:\MarkDown\picture\image-20230213093117752.png)

（2）当前处理元素 e<v，e 和等于 V 区间的第一个位置数值进行交换，同时索引 lt 和 i 都向后移动一位

![image-20230213093146087](E:\MarkDown\picture\image-20230213093146087.png)

（3）当前处理元素 e>v，e 和 gt-1 索引位置的数值进行交换，同时 gt 索引向前移动一位

![image-20230213093210050](E:\MarkDown\picture\image-20230213093210050.png)

最后当 i=gt 时，结束遍历，同时需要把 v 和索引 lt 指向的数值进行交换，这样这个排序过程就完成了，然后对 <V 和 >V 的数组部分用同样的方法再进行递归排序

> 递增和递减的区别仅是改变这个符号：nums[cur] > pivot

```cpp
class Solution {
public:
void partition3(vector<int>& nums, int left, int right) {
	if (left >= right) return;
	swap(nums[rand() % (right - left + 1) + left], nums[right]);
    int pivot = nums[right];
    // lt和gt指向最后一个小于/大于pivot的数
    int lt = left - 1;
    int gt = right;
    int cur = left;  // 当前遍历位置
    while (cur < gt) {
		if (nums[cur] < pivot) {
			swap(nums[cur], nums[lt + 1]);
			cur++; lt++;
		} else if (nums[cur] > pivot) {
			swap(nums[cur], nums[gt - 1]);
			gt--;
		} else {
			cur++;
		}
    }
    // lt和gt指向最后一个小于/大于pivot的数
    swap(nums[right], nums[gt]);
    partition3(nums, left, lt);
    // swap后gt的位置是等于pivot的，gt+1才是最后一个大于pivot的数
    partition3(nums, gt + 1, right);
}
    vector<int> sortArray(vector<int>& nums) {
        partition3(nums, 0, nums.size() - 1);
        return nums;
    }
};
```



## 堆排序

> cpp中堆的实现是优先队列priority_queue，队头到队尾单调递减
>
> 允许在O(lgN)时间复杂度下插入数据，在O(1)时间复杂度下取得容器内最大最小值
>
> 底层实现是堆（一种特殊的二叉树）

### 堆的伪代码

```cpp
// 堆的伪代码

// 先看父节点与左右孩子索引的关系
// 索引0不用
// 父节点的索引
int parent(int root) {
    return root / 2;
}
// 左孩子的索引
int left(int root) {
    return root * 2;
}
// 右孩子的索引
int right(int root) {
    return root * 2 + 1;
}

// 如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行下沉
// 如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的上浮。
// 操作是互逆等价的，但是最终我们的操作只会在堆底和堆顶进行（等会讲原因），显然堆底的「错位」元素需要上浮，堆顶的「错位」元素需要下沉
void swim(int x) {  // 上浮
    while (x > 1 && x > parent(x)) {
        swap(parent(x), x);
        x = parent(x);
    }
}
void sink(int x) {  // 下沉
    while(left(x) <= size) {
        int max = left(x);
        if (right(x) <= size && right(x) > max) max = right(x);
        // 如果x最大，就不用下沉了
        if (max < x) break;
        swap(x,max);
        x= max;
    }
}
// 插入和删除元素的时间复杂度为 O(logK)，K 为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在 sink 或者 swim 上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 log 级别
void insert(key e) {
    size++;
    pq[size] = e;
    swim(size);  // 上浮
}
void delete() {
	// 先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置
    Key max = pq[i];
    swap(1, size);
    pq[size] = null;
    size--;
    sink(1);
    return max;
}
```

时间复杂度O(nlgn)

### 容器实现

小顶堆(堆顶到堆低为增序)实现增序

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int size = nums.size();
        // 默认使用less，为大顶堆，堆顶为最大值
        // 使用greater将其变为小顶堆
        priority_queue<int, vector<int>, greater<int>> que;
        for (int i = 0; i < size; i++) {
            que.push(nums[i]);
        }
        vector<int> result;
        for (int i = 0; i < size; i++) {
            result.push_back(que.top());que.pop();
		}
        return result;
    }
};
```

### 手撕堆排

初始化建堆的时间复杂度为 O(n)，建完堆以后需要进行 n−1 次调整，一次调整（即 `maxHeapify`） 的时间复杂度为O(logn)，那么 n - 1 次调整需要O(n logn)的时间复杂度



> 这里的两个实现都是从最后一个有叶子结点的父节点开始遍历，采用**上浮**操作
>
> 大小顶堆的差别仅在于adjustHeap是将最小的还是最大的放到栈顶。最后给数组排序的时候，将栈顶这个最大/最小的元素与栈底交换，然后size--，再上浮最大/最小的元素
>
> 当然，这里采用下沉更合适，如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行下沉。用下沉实现单调递增，就可以省略一个swap操作

![image-20230212100823807](E:\MarkDown\picture\image-20230212100823807.png)

**小顶堆**实现**单调递减**序列

思路：维持一个小顶堆(不断上浮)，将

首先从最后一个有叶子的父节点开始递减遍历，使得堆顶为最小元素

之后将堆顶这个最小元素放到数组末尾，数组size--，从size不断缩小的小顶堆中不断得到最小的堆顶，放到数组后面。这里小顶堆的作用就是得到当前堆的最小元素，这样就可以实现一个单调递减的序列

```cpp
class Solution {
public:
    // 单调递减序列，用小顶堆实现
    // 小顶堆内元素单调递增
    // adjustHeap需要使用swin上浮，将最小的上浮到栈顶，
    void adjustHeap(vector<int>& hp, int idx, int size) {
        // int i = idx;
        // while ( i * 2 + 1 < size;) {
        for (int i = idx; i * 2 + 1 < size;) {
            // i就是根节点索引，t为zuo孩子索引
            int t = i * 2 + 1;
            // 若右孩子存在且小于左孩子，则t变为右孩子的索引
            if (t + 1 < size && hp[t + 1] < hp[t]) t++;
            // 如果根节点的值小于右孩子，则不管
            if (hp[i] < hp[t]) break;
            // 若父节点大于右孩子，则交换
            swap(hp[i], hp[t]);
            i = t;
        }
    }
    // 建立一个小顶堆
    void buildHeap(vector<int>& hp) {
        // 从最后一个有叶子的父节点开始遍历(如7个节点，则 0 1 2为有叶子的父节点，5个节点，则 0 1)
        for (int i = hp.size() / 2 - 1; i >= 0; i--) adjustHeap(hp, i, hp.size());
    }
    vector<int> sortArray(vector<int>& nums) {
        buildHeap(nums);
        int size = nums.size();
        for (int i = nums.size() - 1; i > 0; i--) {
            // 将最小的元素即堆顶放到末尾
            swap(nums[0], nums[i]);
            adjustHeap(nums, 0, --size);
        }
        return nums;
    }
};
```

**大顶堆**实现**单调递增**序列

```cpp
class Solution {
public:
    // 单调递增序列，用大顶堆(堆内单调递减)实现
    // adjustHeap采用的也是上浮，将最大的放到栈顶，同时对堆进行调整
    // 因为建立好的堆，总是父节点大于子结点。我们将最大的堆顶进行交换后，第一次比较就能得到更新size后的新堆的堆顶了。但我们还要继续循环，对堆进行调整，保证整个堆始终维持父节点大于子结点的特性
    void adjustHeap(vector<int>& hp, int idx, int size) {
        for (int i = idx; i * 2 + 1 < size;) {
            // i就是根节点索引，t为zuo孩子索引
            int t = i * 2 + 1;
            // 若右孩子存在且大于左孩子，则t变为右孩子的索引
            if (t + 1 < size && hp[t + 1] > hp[t]) t++;
            // 如果根节点的值大于右孩子，则不管
            if (hp[i] > hp[t]) break;
            // 若父节点小于右孩子，则交换
            swap(hp[i], hp[t]);
            i = t;
        }
    }
    vector<int> sortArray(vector<int>& nums) {
        // 建立一个大顶堆
        // 从最后一个有叶子的父节点开始遍历(如7个节点，则 0 1 2为有叶子的父节点，5个节点，则 0 1)
        for (int i = nums.size() / 2 - 1; i >= 0; i--) adjustHeap(nums, i, nums.size());
        // 排序
        int size = nums.size();
        while (size > 0) {
            swap(nums[0], nums[--size]);
            adjust(nums, 0, size);
        }
        //for (int i = nums.size() - 1; i > 0; i--) {
        //    // 将最大的元素即堆顶放到末尾
        //    swap(nums[0], nums[i]);
        //    adjustHeap(nums, 0, --size);
        //}
        return nums;
    }
};
```

## *O(n + k)*

实际为O(2n + k)，k指数据量，取决于数据中最大值与最小值的差

暑期实习的主要好处是可以转正，其次才是实习经历，因此也可以日常。只是想增加面试经验的话，面日常实习也一样，反正都去不了

提前批前还能准备四个月，3 4 5 6，不能实习的话把项目好好做做

## 计数排序

> * 找到数组中的最大最小值，按其差作为size构建数组arr
>
> * 遍历数据，将数据的出现次数填入arr中对应的下标位置中
>
> * 遍历 arr ，将数据依次取出即可
>
> ![image-20230224114954082](E:\MarkDown\picture\image-20230224114954082.png)

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        // 找最大最小值
        int maxNum = INT_MIN;
        int minNum = INT_MAX;
        for (int i : nums) {
            maxNum = max(maxNum, i);
            minNum = min(minNum, i);
        }
        // 计数
        vector<int> tmp(maxNum - minNum + 1, 0);
        for (int i : nums) {
            tmp[i - minNum]++;
        }
        // 按顺序取出，即排序O(k)
        vector<int> result;
        for (int i = 0; i < tmp.size(); i++) {
            while (tmp[i]--) {
                result.push_back(i + minNum);
            }
        }
        return result;
    }
};
```

**扩展：稳定排序**

有一个需求就是当对成绩进行排名次的时候，如何在原来排前面的人，排序后还是处于相同成绩的人的前面。

解题的思路是对 countArr 计数数组进行一个变形，变来和名次挂钩，我们知道 countArr 存放的是分数的出现次数，那么其实我们可以算出每个分数的最大名次，就是将 countArr 中的每个元素顺序求和。这样4对应第三名，而5对应第五名，这样在逆序遍历的时候，位于后面的5的名次就是5，位于前面的5名次就是4，这就实现了稳定排序的功能

![image-20230224145623344](E:\MarkDown\picture\image-20230224145623344.png)



程序未改

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        // 找最大最小值
        int maxNum = INT_MIN;
        int minNum = INT_MAX;
        for (int i : nums) {
            maxNum = max(maxNum, i);
            minNum = min(minNum, i);
        }
        // 计数
        vector<int> tmp(maxNum - minNum + 1, 0);
        for (int i : nums) {
            tmp[i - minNum]++;
        }
        // 顺序累加
        for (int i = 1; i < tmp.size(); i++) {
            tmp[i] += tmp[i - 1];
        }
        // 按顺序取出，即排序O(k)
        vector<int> result;
        for (int i = tmp.size() - 1; i >= 0; i--) {
            // ...
        }
        return result;
    }
};
```



## 桶排序(未看)

计数排序的升级版



## *O(n×k)*

## 基数排序(未看)

















































