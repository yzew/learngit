返回上一目录cd ..



vs code插件
Bookmarks：
Ctrl+alt+K 创建或消除书签
 ctrl+alt+j 跳转到前一个书签
 ctrl+alt+l 跳转到后一个书签



自动关机

Shutdown -s -t 7200

2H

取消

shutdown -a





pycharm使多行代码同时左移

 鼠标选中多行代码后，同时按住shift+Tab键，一次左移四个字符



实例分割json

```python
"""
get semantic or instance segmentation annotations from coco data set.
if semantic: use line35、38
if instance: use line36、39
"""
from PIL import Image
import imgviz
import argparse
import os
import tqdm
import shutil
import numpy as np
from pycocotools.coco import COCO
 
def save_colored_mask(mask, save_path):
    lbl_pil = Image.fromarray(mask.astype(np.uint8), mode="P")
    colormap = imgviz.label_colormap()
    lbl_pil.putpalette(colormap.flatten())
    lbl_pil.save(save_path)
 
def main(args):
    annotation_file = os.path.join(args.input_dir, 'annotations', 'instances_{}.json'.format(args.split))
    os.makedirs(os.path.join(args.input_dir, 'SegmentationClass'), exist_ok=True)
    os.makedirs(os.path.join(args.input_dir, 'JPEGImages'), exist_ok=True)
    coco = COCO(annotation_file)
    catIds = coco.getCatIds()
    imgIds = coco.getImgIds()
    empty_anno = []
    print("catIds len:{}, imgIds len:{}".format(len(catIds), len(imgIds)))
    for imgId in tqdm.tqdm(imgIds, ncols=100):
        img = coco.loadImgs(imgId)[0]
        annIds = coco.getAnnIds(imgIds=img['id'], catIds=catIds, iscrowd=None)
        anns = coco.loadAnns(annIds)
        if len(annIds) > 0:
            # mask = coco.annToMask(anns[0]) * anns[0]['category_id']
            mask = coco.annToMask(anns[0])
            for i in range(len(anns) - 1):
                # mask += coco.annToMask(anns[i + 1]) * anns[i + 1]['category_id']
                mask += coco.annToMask(anns[i + 1]) * (i + 2)
            img_origin_path = os.path.join(args.input_dir, args.split, img['file_name'])
            img_output_path = os.path.join(args.input_dir, 'JPEGImages', img['file_name'])
            seg_output_path = os.path.join(args.input_dir, 'SegmentationClass',
                                           img['file_name'].replace('.jpg', '.png'))
            shutil.copy(img_origin_path, img_output_path)
            save_colored_mask(mask, seg_output_path)
        else:
            empty_anno.append(imgId)
    print("No annotations images:", empty_anno)
    print("The number is ", len(empty_anno))
 
def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--input_dir", default="/dataset/coco", type=str,
                        help="input dataset directory")
    parser.add_argument("--split", default="val2017", type=str,
                        help="train2017 or val2017")
    return parser.parse_args()
 
if __name__ == '__main__':
    args = get_args()
    main(args)
```





```
# v为需要查看数据类型的变量
print(type(v))

    
import torch
import numpy as np  

# 通用
x=torch.arange(12)  # 生成tensor类型的数组    
a1 = np.array([1,2,3,4],dtype=np.complex128)  
print(a1)  
print("数据类型",type(a1))           #打印数组数据类型  
print("数组元素数据类型：",a1.dtype) #打印数组元素数据类型  
print("数组形状：",a1.shape)         #打印数组形状  
print("数组的维度数目",a1.ndim)      #打印数组的维度数目  

# numpy专用    
print("数组元素总数：",a1.size)      #打印数组尺寸，即数组元素总数 

+# 互转
A=x.numpy()
B=torch.tensor(A)
```



批量阈值处理？

![image-20211013175629356](D:\MarkDown\picture\image-20211013175629356.png)



```c++
import cv2
import numpy as np
import os

imgdir=r'D:/XXX/00'#原图片文件夹
outdir = r'D:/XXX/11'#输出的文件夹

def Threshold(imgpath):
      img=cv2.imread(imgpath)
      gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) 
      img255 = np.zeros_like(gray, dtype='uint8')
      for i in range(gray.shape[0]):
            for j in range(gray.shape[1]):
                if gray[i, j] > 190: #自己定
                      img255[i, j] = 255
      return img255
     
 filelist=os.listdir(imgdir)
 for item in filelist:
       if item.endswith('_predict.png'):#这里网络输出的文件名,格式为'0_predict.png'
             imgpath = imgdir + os.sep + item
             #print(imgpath)
             dst=Threshold(imgpath)
             outfilepath=os.path.join(outdir, os.path.basename(item))
             cv2.imwrite(outfilepath, dst)
```



将jpg_path文件夹中与base_path相同的文件，移动到jpg1_path

```python
import json
import os
import shutil

def main():
    base_path = "C:\\Users\\yzew\\Desktop\\a\\"
    filelist = os.listdir(base_path)
    #os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。这个列表以字母顺序。 它不包括 ‘.’ 和’…’即使它在文件夹中。
    print(len(filelist))#输出json文件的数目
    jpg_path= "C:\\Users\\yzew\\Desktop\\label_look\\datasets2\\cut\\images\\"#想要移动文件所在的根目录
    jpglist = os.listdir(jpg_path)

    jpg1_path= "C:\\Users\\yzew\\Desktop\\b\\"#移动后的文件夹

    for name in filelist:
        # os.path.splitext(“文件路径”) 分离文件名与扩展名；默认返回(fname,fextension)元组，可做分片操作
        filename = os.path.splitext(name)[0]
        #filename_suffix = os.path.splitext(name)[1]
        for name1 in jpglist:
            jpgname = os.path.splitext(name1)[0]#文件名
            jpgname_suffix = os.path.splitext(name1)[1]#扩展名
            fullname = jpg_path + jpgname + jpgname_suffix#原文件的全部路径名
            if jpgname==filename:#判断是否相等
                shutil.move(fullname,jpg1_path)
                

if __name__ == '__main__':
    main()

```



自动划分训练集与验证集

```python
import os
import random 

# 图片地址
segfilepath=r'./VOCdevkit/VOC2007/SegmentationClass'
# 文件保存地址
saveBasePath=r"./VOCdevkit/VOC2007/ImageSets/Segmentation/"
 
trainval_percent=1
# 9:1
train_percent=0.9

temp_seg = os.listdir(segfilepath)
total_seg = []
for seg in temp_seg:
    if seg.endswith(".png"):
        total_seg.append(seg)

num=len(total_seg)  
list=range(num)  
tv=int(num*trainval_percent)  
tr=int(tv*train_percent)  
trainval= random.sample(list,tv)  
train=random.sample(trainval,tr)  
 
print("train and val size",tv)
print("traub suze",tr)
ftrainval = open(os.path.join(saveBasePath,'trainval.txt'), 'w')  
ftest = open(os.path.join(saveBasePath,'test.txt'), 'w')  
ftrain = open(os.path.join(saveBasePath,'train.txt'), 'w')  
fval = open(os.path.join(saveBasePath,'val.txt'), 'w')  
 
for i  in list:  
    name=total_seg[i][:-4] 
    if i in trainval:  
        ftrainval.write(name+'.jpg'+'\n' )  
        if i in train:  
            ftrain.write(name+'.jpg'+'\n' )  
        else:  
            fval.write(name+'.jpg'+'\n' )  
    else:  
        ftest.write(name+'.jpg'+'\n' )  
  
ftrainval.close()  
ftrain.close()  
fval.close()  
ftest .close()

```



批量裁剪图片

<img src="D:\MarkDown\picture\image-20211025230807643.png" alt="image-20211025230807643" style="zoom:50%;" />



```python
# coding: utf-8
from PIL import Image
import os
import os.path
import numpy as np
#import cv2


#本程序的功能：批量裁剪图片的大小

#指明被遍历的文件夹
#rootdir = r'C:\\Users\\yzew\\Desktop\\data\\images\\'
rootdir = r'C:\\Users\\yzew\\Desktop\\data\\labels\\'
for parent, dirnames, filenames in os.walk(rootdir):#遍历每一张图片
    for filename in filenames:
        ext = os.path.splitext(filename)
        print('parent is :' + parent)
        print('filename is :' + filename)
        currentPath = os.path.join(parent, filename)
        print('the fulll name of the file is :' + currentPath)
   
        img = Image.open(currentPath)
        print (img.format, img.size, img.mode)
        #img.show()
        #box1 = (976, 0, 2000, 1024)#设置左、上、右、下的像素b
        #box1 = (0, 976, 1024, 2000)#设置左、上、右、下的像素c
        box1 = (976, 976, 2000, 2000)#设置左、上、右、下的像素d
        image1 = img.crop(box1) # 图像裁剪
        #image1.save(r"C:\\Users\\yzew\\Desktop\\label_look\\datasets2\\cut\\images\\"+ext[0]+'d'+'.jpg') #存储裁剪得到的图像
        image1.save(r"C:\\Users\\yzew\\Desktop\\label_look\\datasets2\\cut\\labels\\"+ext[0]+'d'+'.png') #存储裁剪得到的图像
```







遍历文件，resize

```python
# coding: utf-8
from PIL import Image
import os
import os.path
import numpy as np
#import cv2



p = "C:\\Users\\yzew\\Desktop\\data\\labels\\"
#获取该目录下所有文件，存入列表中
fileList=os.listdir(p)
n=0
for i in fileList:
    img = Image.open(p+i)
    img=img.resize((2000,2000),0)
    img.save(p+i)
```



生成文件名

cd /d D:\ultrasound-nerve-segmentation\
cd C:\Users\yzew\Desktop\label_look\datasets
dir images /s /b >0.txt
dir 正面电池label裁剪 /s /b >1.txt



遍历文件夹中的图片，对图片遍历每个像素，将不是黑色(0)的部分都变为白色(255)。

注意输出是单通道还是**三通道**问题

```python
import cv2
import os
import numpy as np


# 0是黑色
# 遍历所有像素，不为0的赋255
p = "C:\\Users\\yzew\\Desktop\\label_look\\datasets2\\SegmentationClass\\"
#获取该目录下所有文件，存入列表中
fileList=os.listdir(p)
for i in fileList:
  if os.path.isfile(p+i):
    img = p+i
    image = cv2.imread(img)
    info = image.shape
    height = info[0]
    width = info[1]
    # 这里默认会转为3通道
    dst = np.zeros((height, width, 3), np.uint8)

    for h in range(0, height):
      for j in range(0, width):
        (b, g, r) = image[h, j]
        if (b,g,r)!=(0,0,0):#黑色
            image[h, j] = (255,255,255)#白色
        dst[h, j] = image[h, j]

    cv2.imwrite("C:\\Users\\yzew\\Desktop\\label_look\\datasets2\\image2hb\\" + i, dst)
```

将有白色部分的标签提取出来。注意这里输出是三通道的要转成单通道

```python
import cv2
import os
import numpy as np


# 0是黑色
# 遍历所有像素，不为0的赋255
p = "C:\\Users\\yzew\\Desktop\\label_look\\datasets2\\cut\\labelsL\\"
#获取该目录下所有文件，存入列表中
fileList=os.listdir(p)
for i in fileList:
  if os.path.isfile(p+i):
    img = p+i
    image = cv2.imread(img)
    info = image.shape
    height = info[0]
    width = info[1]
    count=0
    for h in range(0, height):
      for j in range(0, width):
        (b, g,r) = image[h, j]
        if (b, g,r)!=(0,0,0):#黑色
            count=count+1
    if(count>0):
        cv2.imwrite("C:\\Users\\yzew\\Desktop\\a\\" + i,image)
```







遍历文件，改名

```python

import os
from PIL import Image

p = "C:\\Users\\yzew\\Downloads\\Deep-Learning-master\\Pytorch-Seg\\lesson-2\\data\\train\\image\\"
#获取该目录下所有文件，存入列表中
fileList=os.listdir(p)
n=0
for i in fileList:
    if os.path.isfile(p+i):
      #设置旧文件名（就是路径+文件名）
      oldname=p+ fileList[n]   # os.sep添加系统分隔符
      #设置新文件名
      m = p+fileList[n].replace('_mask','')
      os.rename(oldname,m)   #用os模块中的rename方法对文件改名
      n+=1
```



图片格式转换，包括图片jpg、png互转及通道转换等

P模式的图其实是彩图，表示通过调色板，存储256中颜色。而L模式的图其实只存储亮度，不存储颜色，所以两个标签其实是存在差异的。

调色板图像中每个像素为0~255中的一个数，代表颜色索引，而调色板图像本身还会存储一个叫调色板（palette）的数据结构, 最多存储256组rgb颜色。图像中的每一个像素，通过颜色索引， 可以在调色板中获得相应的颜色。

对应索引：

[[ 0 0 0]
[128 0 0]
[ 0 128 0]
[128 128 0]
[ 0 0 128]
[128 0 128]
[ 0 128 128]
[128 128 128]
[ 64 0 0]
[192 0 0]
[ 64 128 0]
[192 128 0]
[ 64 0 128]
[192 0 128]
[ 64 128 128]
[192 128 128]
[ 0 64 0]
[128 64 0]
[ 0 192 0]
[128 192 0]
[ 0 64 128]
[128 64 128]
[ 0 192 128]
[128 192 128]
[ 64 64 0]
[192 64 0]
[ 64 192 0]
[192 192 0]
[ 64 64 128]

```python
from PIL import Image
import os
import string
from matplotlib import pyplot as plt

path = "C:\\Users\\yzew\\Downloads\\Deep-Learning-master\\Pytorch-Seg\\lesson-2\\data\\train\\image\\"
# 最后要加双斜杠，不然会报错

filelist = os.listdir(path)

for file in filelist:
	ext = os.path.splitext(file)
	whole_path = os.path.join(path, file)
	#img = Image.open(whole_path)  # 打开图片img = Image.open(dir)#打开图片
	#img = img.convert("RGB")  # 将一个4通道转化为rgb三通道
	#img = img.convert("P")
	#img.save(path + file)
	if ext[1] == '.jpg':
		newext = '.png'
		filename = ext[0] + newext
		oldfile = os.path.join(path, file)
		newfile = os.path.join(path, filename)
		os.rename(oldfile, newfile)
'''
PIL包含九种不同模式：1，L，P，RGB，RGBA，CMYK，YCbCr,I，F
使用Image.convert()，可以在这九中模式中进行切换。
模式1为二值图像，非黑即白。
模式L为灰度图像。
RGB就是通常说的三原色。
RGBA就是上例上的在三原色的基础上增加了一个alpha通道。
'''
```



通过API接口实现大部分图片的批量图像分割



```python
# 调用API接口 tC8jddQB8ZagqbS16e6hyzjX
# 无背景人像图，位深度为32位，mask图，位深度为8位
# 跑的时候关闭代理服务器
# cd /d H:\mydataset\maskAPI
# python mask.py -path C:\Users\Administrator\Desktop\2\
# 批量生成一个文件夹的mask图
import argparse
import requests
import shutil, os
import cv2
import numba
from PIL import Image


# 带numba加速计算，请安装numba
# pip install numba
@numba.jit
def png2mask(img):
    shape = img.shape
    width = shape[0]
    height = shape[1]
    for y in range(height):
        for x in range(width):
            color = img[x, y]
            if color[3] == 0:
                img[x, y] = [0, 0, 0, 255]
            else:
                img[x, y] = [255, 255, 255, 255]
    return img

##################################################
# 封装成交互式
# python csvcp.py -path "H:/mydataset/mydataset/train/"
parser = argparse.ArgumentParser(description="Demo of argparse")
parser.add_argument('-path','--p')
args = parser.parse_args()
##################################################
p = args.p

# 下面第一二行遍历文件夹中文件
os.scandir(p)
for item in os.scandir(p):
    m = item.name
    response = requests.post(
    'https://api.remove.bg/v1.0/removebg',
    files={'image_file': open(p+m, 'rb')},
    data={'size': 'auto'},
    headers={'X-Api-Key': 'chztUmWAHRPADMVdqDUTBpre'},)
    '''
    我
    2402193334@qq.com tC8jddQB8ZagqbS16e6hyzjX
    2966132122@qq.com fp2pTMFukeohYwMev88hSJqB   a 
    2984242741@qq.com wWgoHzBZHdv7WVCPD3TaKDj3
    李祎
    1597904349@qq.com W1sExbEceDAmUK7jMsh8KQ9H 已用
    2651511165@qq.com R6QhWK5idKcdrz8LasFTRfWM pver
    1727442633@qq.com T2QLoMdayUWs3rLNWvuMmkHg over
    1039387096@qq.com xKjXj6tvnWmqMSYkRDDQ6p19 over
    姜慧
    2768301613@qq.com xsPtjX9sJYErvTZdZManqMo3 over
    2330916827@qq.com chztUmWAHRPADMVdqDUTBpre

    '''
    if response.status_code == requests.codes.ok:
        with open(m+'_fg.png', 'wb') as out:
            out.write(response.content)
    else:
        print("Error:", response.status_code, response.text)

    # 无背景png图转mask
    if __name__ == '__main__':
        img = cv2.imread(m+'_fg.png', -1)
        img_copy = img.copy()
        result = png2mask(img_copy)
        image = Image.fromarray(result)
        # 转8位位深度
        image = image.convert('L')
        image.save(m+'.png')
    # 生成位置默认是工程位置，移动到数据集位置
    os.chdir('H:\\mydataset\\maskAPI')
    shutil.move('H:\\mydataset\\maskAPI\\'+m+'_fg.png', 'C:/Users\Administrator\Desktop/3/'+'fg')
    shutil.move('H:\\mydataset\\maskAPI\\'+m+'.png', 'C:/Users\Administrator\Desktop/3/'+'mask')

```





csv组合

```python
import pandas as pd
from pandas import DataFrame
import shutil, os
import argparse

##################################################
# 封装成交互式
# cd /d H:\mydataset\csvcompose
# python csvcp.py -p "D:\BackgroundMatting\Background-Matting-master\Data_adobe/"
parser = argparse.ArgumentParser(description="Demo of argparse")
parser.add_argument('-p','--name')
args = parser.parse_args()
csv_path = args.name
##################################################

###################################################
# 只需改动csv地址，默认名字fg.csv和mask.csv
#csv_path = "H:/mydataset/mydataset/train/"
###################################################


f1 = pd.read_csv(csv_path + '01.csv')
f2 = pd.read_csv(csv_path + '02.csv')
file = [f1, f2]
all_data = pd.concat(file, axis=1)
all_data.to_csv("11" + ".csv", index=0, sep=',')
# 生成位置默认是工程位置，移动到数据集位置
os.chdir('H:\\mydataset\\csvcompose')
shutil.move('H:\\mydataset\\csvcompose\\11.csv', csv_path)
```



将mask和原图结合，输出fg

```python
import cv2
from PIL import Image
import numpy as np
import requests
import shutil, os

'''
使用示例
mm = MatteMatting("input.jpg", "mask.jpg")
mm.save_image("output.png", mask_flip=True) # mask_flip是指蒙版翻转，即把白色的变成黑色的，黑色的变成
'''

##################################################
# 封装成交互式
# conda activate tensorflow-gpu
# cd /d H:\mydataset\masktofg
# python mask.py -path "D:\BackgroundMatting\Background-Matting-master\sample_data\input/" -img 0002_img -mask 0002_masksDL
import argparse
parser = argparse.ArgumentParser(description="Demo of argparse")
parser.add_argument('-path','--p')
parser.add_argument('-img','--i')
parser.add_argument('-mask','--m')
args = parser.parse_args()
##################################################

class UnsupportedFormat(Exception):
    def __init__(self, input_type):
        self.t = input_type

    def __str__(self):
        return "不支持'{}'模式的转换，请使用为图片地址(path)、PIL.Image(pil)或OpenCV(cv2)模式".format(self.t)


class MatteMatting():
    def __init__(self, original_graph, mask_graph, input_type='path'):
        """
        将输入的图片经过蒙版转化为透明图构造函数
        :param original_graph:输入的图片地址、PIL格式、CV2格式
        :param mask_graph:蒙版的图片地址、PIL格式、CV2格式
        :param input_type:输入的类型，有path：图片地址、pil：pil类型、cv2类型
        """
        if input_type == 'path':
            self.img1 = cv2.imread(original_graph)
            self.img2 = cv2.imread(mask_graph)
        elif input_type == 'pil':
            self.img1 = self.__image_to_opencv(original_graph)
            self.img2 = self.__image_to_opencv(mask_graph)
        elif input_type == 'cv2':
            self.img1 = original_graph
            self.img2 = mask_graph
        else:
            raise UnsupportedFormat(input_type)

    @staticmethod
    def __transparent_back(img):
        """
        :param img: 传入图片地址
        :return: 返回替换白色后的透明图
        """
        img = img.convert('RGBA')
        L, H = img.size
        color_0 = (255, 255, 255, 255)  # 要替换的颜色
        for h in range(H):
            for l in range(L):
                dot = (l, h)
                color_1 = img.getpixel(dot)
                if color_1 == color_0:
                    color_1 = color_1[:-1] + (0,)
                    img.putpixel(dot, color_1)
        return img

    def save_image(self, path, mask_flip=False):
        """
        用于保存透明图
        :param path: 保存位置
        :param mask_flip: 蒙版翻转，将蒙版的黑白颜色翻转;True翻转;False不使用翻转
        """
        if mask_flip:
            img2 = cv2.bitwise_not(self.img2)  # 黑白翻转
        image = cv2.add(self.img1, img2)
        image = Image.fromarray(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))  # OpenCV转换成PIL.Image格式
        img = self.__transparent_back(image)
        img.save(path)

    @staticmethod
    def __image_to_opencv(image):
        """
        PIL.Image转换成OpenCV格式
        """
        img = cv2.cvtColor(np.asarray(image), cv2.COLOR_RGB2BGR)
        return img

p = args.p
i = args.i
m = args.m
mm = MatteMatting(p+i+'.png', p+m+'png')
mm.save_image(i+"_fg.png", mask_flip=True)  # mask_flip是指蒙版翻转，即把白色的变成黑色的，黑色的变成白色的
# 生成位置默认是工程位置，移动到数据集位置
os.chdir('H:\\mydataset\\masktofg')
shutil.move('H:\\mydataset\\masktofg\\'+i+'_fg.png', 'D:\\BackgroundMatting\\Background - Matting - master\\sample_data\\maskout')




# cd /d H:\mydataset\maskAPI
# python mask.py -path E:\onlyimg\yourdataset\foods/
# 批量生成一个文件夹的mask图

```





maskcompose，没看懂是干嘛的

```python
import json
import cv2
import matplotlib.pyplot as plt
import numpy as np
import argparse
tmp = {}

#####################################
# 封装成交互式
# python maskcp.py -p "E:/onlyimg/yourdataset/foods/" -m 20200501_124933
parser = argparse.ArgumentParser(description="Demo of argparse")
parser.add_argument('-p','--pm')
parser.add_argument('-m','--mm')
args = parser.parse_args()
path = args.pm
m = args.mm
#######################################

#######################################################
# 只需改动这两个参数
#path = "E:/onlyimg/yourdataset/foods/"
# m是文件名
#m = '20200501_124933'

#######################################################
js = m+".json"
imgp = m+".jpg"
maskt = m + ".png"
# with open("./20200501_121152.json", "r") as f:
with open(path + js, "r") as f:

    tmp = f.read()

tmp = json.loads(tmp)

points = tmp["shapes"][0]["points"]
points = np.array(points, np.int32)

img = cv2.imread(path + imgp)
# BGR->RGB
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

##########box = tmp["shapes"][1]["points"]
#############box = np.array(box, np.int32)

mask = np.zeros_like(img)

######cv2.rectangle(img, (box[0][0], box[0][1]), (box[1][0], box[1][1]), (125, 125, 125), 2)
# cv2.polylines(img, [points], 1, (0,0,255))
cv2.fillPoly(mask, [points], (255, 255, 255))
img_add = cv2.addWeighted(mask, 0.3, img, 0.7, 0)
cv2.imwrite(path + maskt, mask)
plt.imshow(img_add)
```

