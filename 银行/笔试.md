> ### 测评中逻辑和智力测评部分是计算初筛分数的
>
> 这个是今年和某司HR聊天的时候知道的，实际上测评当中只有逻辑推理，图形判断那些智力检测题目是有分数，并作为进面参考的，其他性格测试那些基本不做参考。当然，除了极个别公司HRBP、HRG将其他性格测试题作为参考，这里就不点名了~



> 光大
>
> 笔试：
>
> 一个半小时，50min行测+40min语言
>
> 行测（言语分析、数学计算、资料分析、图形推理等）
>
> 计算机部分可以选择语言，c++就只考c++相关，sizeof考的比较多
>
> AI面：
>
> AI面试共6题，每题在看完题后有一次录制的机会，录制完成后还有两次重新录制的机会，相当于一共有3次机会，每次机会之间有30s时间可以思考，思考好了再点重新录制就好了。
>
> 昨天刚刚收到光大证券的AI面经通知，我今天下午就面试了，岗位是金融科技岗
> AI面试共有5道题，每题两分钟，给你15s思考时间
>
> > **你愿意和10个鸭子体型的熊战斗还是1个熊体型的鸭子战斗，请说明理由**
>
> 和10个鸭子体型的熊吧。虽然需要关注于多个目标，但每个都不会对自己造成太大的伤害，可以逐个解决。而对于熊题型的鸭子，虽然只需要专注于这一个目标，但受一次伤就会很严重，每次失误都会有很大的风险。
>
> > **你做过的最疯狂的事情是什么？**
>
> ​	研究生阶段的话有个事，就是刚入学不到一个学期的时候，我们老师沟通了一个图像分割的项目，本来是打算交给我们研一新生，来慢慢边学边做的，结果当时那个公司就突然要求几天内对他们的数据预跑一个结果，如果还可以的话就交给我们去做。然后当时我们导师觉得时间太紧了，和我们研究方向又不符，打算直接放掉这个项目。但我和我同门当时就直接接下了，说交给我们。然后那两天就开始疯狂加班，先读了很多综述，对图像分割这个方向有了大致的了解，又开始找一些baseline来复现，在他们提供的数据集上进行实验，最后迭代了几版代码后跑出来了个还能看的结果，顺利接下了这个项目。
>
> > **你正在负责一个项目，领导突然和你说一个需求需要进行改动，你会怎么做？**
>
> ​	作为一个项目负责人，我会先对改动的需求进行详细的了解，搞清楚修改的原因和方向；然后我会立即开个组会，进行任务下发，同时让组员依据自己负责的部分，预估是否能按期完成等；最后就定期根据工作进展对任务进行调整，保证项目能按期完成，并及时向领导汇报工作进展。
>
> > **过去2到3年期间，你制定的最大的学习或者工作目标是什么？怎么去行动的，目前取得了什么成果？**
>>
> > **你这一年为自己制订过什么目标，为什么？**
> 
> ​	这两到三年的话，制定的最大的学习目标就是自学后端开发方向相关的技术栈。
>​	为什么：一个是因为个人本科期间就学过一些后端开发相关的课程，然后对这个方向比较感兴趣，因此在研究生阶段就进行了相应的学习计划。另一个是后端开发的岗位更多，无论到时候想去哪个城市，都能找到工作。
> 
> ​	因为深度学习的话都是大实验室的再找相关的工作，因为他们老师都会给安排大厂实习，然后也有师兄导师带着发论文。我们就是发论文的热情不高，竞争力差，研一就直接开始看c++了
>
> ​	首先是进行前期的调研，了解这个方向需要学哪些内容，然后相对应可以投递哪些岗位。确定具体的方向后，再开始制定学习计划，根据每一部分内容的学习量和难度分配时间，最后再做一些相关项目进行巩固。
>​	最后就在不耽误实验室科研的情况下，自学完了后端开发方向的技术栈，并独立完成了两个相关的项目
> 
> 
>
> 
>
> > **你所负责的项目中由于甲乙两个人产生误会，出现问题，导致项目耽搁，此时你会怎么做？**
>
> ​	首先先了解一下事情经过，看到底是因为什么原因产生的误会。然后这毕竟是误会嘛，都是可以解决的，就先分别对两个人讲一下这个事，让他们互相体谅一下，了解一下他们生气的点在哪里，然后在和另一个人沟通。一个团队经常在一起工作，可以说是一家人了，矛盾和误会都是可以解决的。最后再把他们聚在一起，互相道个歉就行了
>
> > **从有经验的人那里学习到了有助于工作和专业成长的知识、思路和方法吗？学到了什么？做了什么总结？**
> 
> ​	导师
>
> ​	就有段时间，论文的创新点难以复现，
>
> > **最近学习了什么新技能，举例说明**
>
> 最近的话，就是前段时间有个开发图形界面的需求，需要给一个深度学习的一个项目做一个界面，实现一些功能，我就学了下怎么做一个 GUI。当时选择了Tkinter，Python的一个标准 GUI 库，
>
> > **曾经在学习和工作中不满于现状的情况？怎么处理的？成效如何？**
>
> 
> 
> > **最近工作学习遇到了什么难点，你是如何完善的**
>
> 论文中创新点
>
> 8、自我介绍
>
> 9、读一段英文
>
> 除了读英文是一分钟内完成，其他都是两分钟内完成，且每次重新录制都是两分钟重新计时的，不是倒计时，还挺人性化的。面对镜头和面对真人的感觉真的很不一样，面对镜头感觉更紧张，会语无伦次，建议有空可以练习一下。
>
> **1.** 办公楼电梯效率问题/住户反应电梯运行效率不高，你怎么解决？
>
> **2.** 你负责销毁一车过期的面包，前面有一群饥饿的人，记者赶来，你怎样处理好面包和饥饿的人，同时不让记者报道面包过期了？
>
> 5、说一项你从零开始学习的技能，怎么学的？难点是什么？怎么攻克的？
>
> 7、 最有成就感的事情
>
> 14.他人影响团队进度的情况
>
> 之后就是说一段中文和一段英文就ok了

浦发：还考语文

有的还考申论

邮储在秋招的时候还考银行的固有知识，考了五道，还有时事政治题目五个



中行暑期实习笔试：共2h10min

综合题70，包括行测、计算题、数学题等

技术题70，包括一道c++，几道java，一道python，一道深度学习，还要数据库、计算机组成原理；

英语题若干，单选+选词填空+阅读



招行暑期实习的笔试：
30min50道英语题，包括单词和阅读理解；
55min60道行测，包括语文、数学、图推、思维题；
3min给30张图片找不同，找出相同那张。一张看6s就行；视觉追踪，给定3-5个小球，一堆球在运动，锁定给定的几个球。

# 英语

小编整理了一些银行英语笔试答题需要注意的点

**有顺序地阅读：**



  1)先看标题-看罢标题，对全篇文章应有一个大约的了解;



  2)段落题目-知道每段的大概内容，您也能从中推断文章的内容;



 3)看较深色或额外涂黑的字-这也可帮助了解文章内容;



  4)看图片-有时候看图片比看整段文字更有用。因此，先看图片、图表等等可令您更了解内容;



  5)看指引-如不看指引，您可能不知道应以何种方式回答问题。有时候指引也会包含一些关于文章的资料;



  6)看例句-例句不单可令您了解如何正确回答问题，也可在一两句之内令您对文章有一个大概的了解，因此看例句绝不是浪费时间的事;



  7)最后，看问题令您了解阅读文章时应留意什么。



**清楚文章和问题的方式和分布**



  　阅读测验的问题有时在的前面或后面。您必须清楚：测验的3部分是哪里开始，哪里完结;每部分有多少问题，哪里开始，哪里完结;应如何分配每部分的时间;应先回答哪些问题。

**清楚答案的位置**



  　很多时候您不用详细阅读整篇文章也能找到答案。首先您可找出问题的关键字或句，然后找出所有在文章出现的关键字或句。看每个关键字句的前和后寻找答案，按顺序一个一个找，直至找到答案为止。

**收窄寻找范围**



  　首先您看明白每一组例句问题和最后一条问题，之后再在测验文章内找出例句问题问及哪一段的位置和最后一条问题在文章内的位置，然后您会发现通常整组问题的答案都是在文章例句问题的位置和最后一条问题的位置中间找到。用这个方法，您可省掉不少时间。

**注意文字或句子的形式变化**



  　在文章中寻找答案的难度很多时候会看您对字句的形式变化的认识能力。您需注意3种不同形式：



  　第一种：同义、相同的字



  　第二种：同义、相似的字



  　第三种：同义、有很大差异的变化例句：问题句文章句

**细心分析深奥词汇**



  　您也许不会认识测验中的每一个字，就算是土生土长的西方人也很难认识所有TOEIC考试的字汇，在平时练习时您应用字典学习每一个遇到的生字，但在正式考试时您是不能用字典的，因此您应学会猜测，当然最理想是您可猜到字词的意思，但这并不容易做得到。如您不能猜出意思的话，您可试估计这字词是正面的(positive)还是负面的(negative)，这对您认识文章的意思和作者的意图很有帮助。

**留意数字**



  　数字的位置是最容易找的，如问题有提及过，用寻找关键字的方法找答案。记着，数字有时候也可用英语表达出来。



  　希望这些可以对大家有所帮助，最后祝愿大家都可以成功上岸!

# 行测

## 图形推理

> 行测可以看蓝蓝银行下载的那部分，也可以刷牛客的题库，还有咸鱼卖的北森题库

牛友[海康的娃](https://www.nowcoder.com/discuss/353158314110427136?sourceSSR=users)有**图形推理**真题可以看；

第五套开始未作

是不是两个图形叠加或者去除？求同存异

最后一个图形是不是前面图形的组合？

奇数项为开放图形，偶数项为封闭图形

找规律，有圆？有角？整体的线段数？从第一项到最后一项的线段数递增？空白部分？**封闭区域数量**？有多少部分组成？旋转关系(整体旋转/局部旋转/以中心为轴旋转)？公共边？交点个数？笔画个数？

面积上的规律，比如空白部分面积小于黑色部分面积

每项图形由左右两部分组成，前项图形的右部分是后项图形的左部分

对于那种立体的展开图，有时候根据答案反推比较块

图形的种类的数量

## 排序

**快排、堆排、选择、希尔是不稳定的**

冒泡和插入最好情况O(n)

快排最坏情况O(n^2)

希尔、归并、快排、堆排都是O(n logn)

****

![image-20230213125004139](E:\MarkDown\picture\image-20230213125004139.png)

> 排序算法的稳定性：
> 	指若有重复数据时，若这些重复数据的相对次序保持不变，则是稳定的；反之则是不稳定的。
>
> 一般只需要记住，**快排、堆排、选择排序和希尔排序是不稳定的**即可

# 408

牛客可刷，也可以直接在csdn上看

https://blog.csdn.net/qq_44111805/article/details/124475981

# Java

<img src="E:\MarkDown\picture\image-20230513123915546.png" alt="image-20230513123915546" style="zoom:50%;" />

str1指向常量池中的字符串；str2是通过StringBuilder类new出的对象，指向堆。故为false 



<img src="E:\MarkDown\picture\image-20230513145320379.png" alt="image-20230513145320379" style="zoom: 50%;" />

没有异常:try-finally 
有异常：try-catch-finally 
当遇到return后，先执行finally，再return，如果在finally中return了，就直接return。   



<img src="E:\MarkDown\picture\image-20230513145533165.png" alt="image-20230513145533165" style="zoom:50%;" />





<img src="E:\MarkDown\picture\image-20230513145653934.png" alt="image-20230513145653934" style="zoom:60%;" />

**编译看左边，运行看右边。**意思编译时候，看左边有没有该方法，运行的时候结果看 **new**  的对象是谁，就调用的谁。 





<img src="E:\MarkDown\picture\image-20230513145728902.png" alt="image-20230513145728902" style="zoom:50%;" />







![image-20230513145951856](E:\MarkDown\picture\image-20230513145951856.png)







<img src="E:\MarkDown\picture\image-20230513150017524.png" alt="image-20230513150017524" style="zoom:67%;" />

# 设计模式

> reference：
>
> [设计模式（全 23 种） | 爱编程的大丙 (subingwen.cn)](https://subingwen.cn/design-patterns/#1-前言)
>
> [一文打尽设计模式(C++实现)_墨1024的博客-CSDN博客](https://blog.csdn.net/leacock1991/article/details/111713017)
>
> 华为.md
>
> [牛客网专项练习——设计模式](https://www.nowcoder.com/exam/intelligent?questionJobId=10&tagId=21002)



![image-20230426115946446](E:\MarkDown\picture\image-20230426115946446.png)





![image-20230426105547184](E:\MarkDown\picture\image-20230426105547184.png)

这要靠测试





![image-20230426105612015](E:\MarkDown\picture\image-20230426105612015.png)





![image-20230426105702552](E:\MarkDown\picture\image-20230426105702552.png)

文字题，单例模式对于需要频繁创建和销毁的对象，可以提高系统的性能。





![image-20230426110212552](E:\MarkDown\picture\image-20230426110212552.png)

模板方法模式

**何时使用**：有一些通用的方法时
**方法**：将通用算法抽象出来
**优点**：封装不变部分，扩展可变部分；提取公共部分代码，便于维护；行为由父类控制，子类实现
**缺点**：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大
**使用场景**：有多个子类共有的方法，且逻辑相同；重要的、复杂的方法，可以考虑作为模板方法；重构时，模板方法模式是一个经常使用到的模式，把相同的代码抽取到父类中，通过钩子函数约束其行为
**应用实例**：做试卷，大家题目都是一样的，只是答案不同；对于汽车，车从发动到停车的顺序是相同的，不同的是引擎声、鸣笛声等
**注意事项**：为防恶意操作，一般模板方法都加上final关键字



![image-20230426110528259](E:\MarkDown\picture\image-20230426110528259.png)

1、简单工厂模式中包含判断什么对象的逻辑，而工厂方法模式则需要调用者判断要实例化什么具体类型的工厂进而创建出想要的对象。当增加新类时，简单工厂模式需要修改工厂类，而工厂方法模式不需要，因此**工厂方法模式遵守了开闭原则，而简单工厂模式没遵守**。  

2、简单工厂模式因为采用了静态方法，所以不利于继承，而工厂方法模式恰恰相反，需要利用到继承来从抽象工厂中派生出各种各样的具体工厂。 



![image-20230426120606587](E:\MarkDown\picture\image-20230426120606587.png)

代理模式





![image-20230426110643770](E:\MarkDown\picture\image-20230426110643770.png)

行为类模式使用继承在类间来分配行为，比如模板方法模式，解释器模式。





![image-20230426123326213](E:\MarkDown\picture\image-20230426123326213.png)





![image-20230426132513883](E:\MarkDown\picture\image-20230426132513883.png)





![image-20230426132641507](E:\MarkDown\picture\image-20230426132641507.png)

跟线程池一样，使用单例模式



![image-20230426133536698](E:\MarkDown\picture\image-20230426133536698.png)



<img src="E:\MarkDown\picture\image-20230426133625263.png" alt="image-20230426133625263" style="zoom:67%;" />

B. 前半句对，后半句错。不高效率，因为请求会动态传递，若责任链长，则时间多，请求效率低   





![image-20230426133742044](E:\MarkDown\picture\image-20230426133742044.png)



![image-20230426133758272](E:\MarkDown\picture\image-20230426133758272.png)





![image-20230426133921331](E:\MarkDown\picture\image-20230426133921331.png)



![image-20230426142911641](E:\MarkDown\picture\image-20230426142911641.png)





![image-20230426143201328](E:\MarkDown\picture\image-20230426143201328.png)

# C

<img src="E:\MarkDown\picture\image-20230728171301315.png" alt="image-20230728171301315" style="zoom:50%;" />

合法，enum aa中包含5 6 7 三个数，这里将5转换为了aa中的a

<img src="E:\MarkDown\picture\image-20230728171917764.png" alt="image-20230728171917764" style="zoom:50%;" />

这里Test b();声明了个返回Test的函数...

# C++

> **基类指针指向派生类对象，实函数与虚函数的调用问题**

基类指针指向派生类对象，基类与派生类含有同名同参的函数，调用函数应该调用哪个，当函数有虚函数时又该调用哪个？

* 基类指针pBase指向派生类对象basePlus时，基类与派生类都含有同名同参函数且是一虚（virtual）一实，pBase调用他们中的实函数
* 基类与派生类都含有同名同参函数，且都是实函数时，调用的是基类的函数。
* 基类与派生类都含有同名同参函数，且都是虚函数时，调用的是派生类的函数。
  



<img src="E:\MarkDown\picture\image-20230510180645448.png" alt="image-20230510180645448" style="zoom:50%;" />

静态变量分为局部静态变量和全局静态变量，全局静态变量是全局变量。



![image-20230510180821173](E:\MarkDown\picture\image-20230510180821173.png)

这个怎么说呢，主函数里的静态变量，在主函数退出后是会被释放的。其他函数中的不会。但相对其他选项来说，B是错误的



![image-20230510181129818](E:\MarkDown\picture\image-20230510181129818.png)

B是错误的，引用`int * const b = a;`是一个指针常量，指向不能改



![image-20230510181331556](E:\MarkDown\picture\image-20230510181331556.png)

p[0]表示第一个对象，可以直接调用GetX()





<img src="E:\MarkDown\picture\image-20230510181953642.png" alt="image-20230510181953642" style="zoom:57%;" />

  1处，正确形式是：pcNewWelcome=(char*)malloc(strlen(pcWelcome) * sizeof(char)) ,但是逻辑上strlen()统计字符个数，不含结尾符'\0'，所以这样子分配会少一个字节。 

  3处，由1处，既然新分配的空间少了一个字节，你用原来的来复制到新的里？能装下吗？不能。 



![image-20230510182208197](E:\MarkDown\picture\image-20230510182208197.png)

只能写，且要么新创，要么清0，原有内容直接没了。写操作后不能读，写后能读的是w+，"w+"先建立文件并进行写操作后，"w+"可以从头开始读

![image-20230510182200699](E:\MarkDown\picture\image-20230510182200699.png)





![image-20230508223527848](E:\MarkDown\picture\image-20230508223527848.png)

对于内置类型而言，new仅仅是分配内存，除非后面显示加(),相当于调用它的构造函数，对于自定义类型而言，只要一调用new，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化，即使后面没有加()  





<img src="E:\MarkDown\picture\image-20230508224544422.png" alt="image-20230508224544422" style="zoom:60%;" />

B：要判断一个双精度



浮点数：if( abs(f) <= 1e-15 )。由于双精度丢失，所以只能够采用比较两个差绝对值是否小于一个很小的数字来确定。 

```cpp
int main()
{

    int i = 1;
    printf("%d,%d\n", ++i, ++i);    //3,3
    printf("%d,%d\n", ++i, i++);    //5,3
    printf("%d,%d\n", i++, i++);    //6,5
    printf("%d,%d\n", i++, ++i);    //8,9
    system("pause");
    return 0;
}
```

首先是函数的入栈顺序从右向左入栈的，计算顺序也是从右往左计算的，不过都是**计算完以后在进行的压栈操作**：输出时从栈顶开始

* 对于第5行代码，首先执行++i，返回值是i，这时i的值是2，再次执行++i，返回值是i，得到i=3，将i压入栈中，此时i为3，也就是压入3，3；
* 对于第6行代码，首先执行i++，返回值是原来的i，也就是3，再执行++i，返回值是i，依次将3，5压入栈中得到输出结果
* 对于第7行代码，首先执行i++，返回值是5，再执行i++返回值是6，依次将5，6压入栈中得到输出结果
* 对于第8行代码，首先执行++i，返回i，此时i为8，再执行i++，返回值是8，此时i为9，依次将i，8也就是9，8压入栈中，得到输出结果。 





<img src="E:\MarkDown\picture\image-20230508231816083.png" alt="image-20230508231816083" style="zoom:57%;" />

对于枚举类型，**全局变量时初始化为0，局部变量时初始化为随机值。** 





<img src="E:\MarkDown\picture\image-20230508230700645.png" alt="image-20230508230700645" style="zoom:57%;" />

内联函数也可以在类内声明，类外定义，声明可以不加inline，但类外的这个定义必须加上inline







![image-20230209180512932](E:\MarkDown\picture\image-20230209180512932.png)

![image-20230209180415389](E:\MarkDown\picture\image-20230209180415389.png)

![image-20230209180447546](E:\MarkDown\picture\image-20230209180447546.png)



![image-20230209181142273](E:\MarkDown\picture\image-20230209181142273.png)

![image-20230209181050362](E:\MarkDown\picture\image-20230209181050362.png)

![image-20230209172152984](E:\MarkDown\picture\image-20230209172152984.png)

![image-20230209172221010](E:\MarkDown\picture\image-20230209172221010.png)

![image-20230209174112516](E:\MarkDown\picture\image-20230209174112516.png)

赋值运算满足右结合律，靠右的赋值运算`j = 0`作为靠左的赋值运算符的右侧运算对象，`i=j=0`是正确的，都被赋值为0。但在作为条件语句的时候，先将j=0赋值给i，再判断赋值的结果是否为真。此时为0

![image-20230209175430574](E:\MarkDown\picture\image-20230209175430574.png)

![image-20230209175558631](E:\MarkDown\picture\image-20230209175558631.png)

![image-20230209175004693](E:\MarkDown\picture\image-20230209175004693.png)

***

![image-20230209174804692](E:\MarkDown\picture\image-20230209174804692.png)

![image-20230209172055055](E:\MarkDown\picture\image-20230209172055055.png)

![image-20230209172108657](E:\MarkDown\picture\image-20230209172108657.png)

![image-20230209172125335](E:\MarkDown\picture\image-20230209172125335.png)









# 网络基础



<img src="E:\MarkDown\picture\image-20230512161509165.png" alt="image-20230512161509165" style="zoom:77%;" />

​	TTL值全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间。TTL设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。

TTL=1说明路由器处理后TTL=0，需要丢弃

但还有一种情况，就是目的地址是自己，就自己处理了。所以这个题不明确。



![image-20230502121909568](E:\MarkDown\picture\image-20230502121909568.png)

A类地址:0开头，   1.0.0.0 - 126.0.0.0
B类地址:10开头， 128.0.0.0 - 191.255.255.255
C类地址:110开头，192.0.0.0 - 223.255.255.255 



![image-20230502121428979](E:\MarkDown\picture\image-20230502121428979.png)

默认c类是255.255.255.0，分了子网掩码后，192=11000000，子网有两位，2^ 2=4组子网，剩下6个位是主机，2^6 * 4 = 248，因此四个子网一共248个主机



![image-20230502121709153](E:\MarkDown\picture\image-20230502121709153.png)

计算机网络的协议主要由**语义、语法和交换规则**三部分组成，即协议三要素：

![image-20230502112910551](E:\MarkDown\picture\image-20230502112910551.png)

广域网（WAN）：网络跨越国界、洲界，甚至遍及全球范围。
**局域网（LAN）**：分布于一个间房、每个楼层、整栋楼及楼群之间等，范围一般在2km以内，最大距离不超过10km。主要用来构建一个单位的内部网络，例如办公室网络、办公大楼内的局域网学校的校园网、工厂的企业网、大公司及科研机构的园区网等。通常采用有线的方法连接起来。
城域网（MAN）：规模局限在一座城市的范围内。
个人区域网（PAN）：一般指家庭一台或多台电脑所使用的网络



![image-20230502112951496](E:\MarkDown\picture\image-20230502112951496.png)



![image-20230502112040649](E:\MarkDown\picture\image-20230502112040649.png)

MAC地址共六个字节！！！



![image-20230502112131098](E:\MarkDown\picture\image-20230502112131098.png)

ARP协议是根据IP地址找MAC地址
RARP协议则是反向地址转换协议，根据IP地址获得MAC地址
ICMP是Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。



![image-20230502111201245](E:\MarkDown\picture\image-20230502111201245.png)



![image-20230502112341403](E:\MarkDown\picture\image-20230502112341403.png)

# 招行技术类

![image-20230425123055086](E:\MarkDown\picture\image-20230425123055086.png)



![image-20230425123608894](E:\MarkDown\picture\image-20230425123608894.png)

**节点度**是指和该节点相关联的边的条数，又称关联度
节点的入度是指进入该节点的边的条数；
节点的出度是指从该节点出发的边的条数。

赫夫曼树，别名“哈夫曼树”、“最优树”以及“最优二叉树”

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

![image-20230425123345420](E:\MarkDown\picture\image-20230425123345420.png)



![image-20230425124039551](E:\MarkDown\picture\image-20230425124039551.png)

# 图形推断

![image-20230621203927530](E:\MarkDown\picture\image-20230621203927530.png)







B 只有B的小灰球在凹处



![image-20230506102338677](E:\MarkDown\picture\image-20230506102338677.png)







![image-20230506102346499](E:\MarkDown\picture\image-20230506102346499.png)





![image-20230506102455257](E:\MarkDown\picture\image-20230506102455257.png)



![image-20230506102504832](E:\MarkDown\picture\image-20230506102504832.png)



<img src="E:\MarkDown\picture\image-20230506102527363.png" alt="image-20230506102527363" style="zoom:80%;" />





![image-20230506102557736](E:\MarkDown\picture\image-20230506102557736.png)





![image-20230506102637525](E:\MarkDown\picture\image-20230506102637525.png)





![image-20230506102645479](E:\MarkDown\picture\image-20230506102645479.png)





![image-20230506102841678](E:\MarkDown\picture\image-20230506102841678.png)



![image-20230506102910775](E:\MarkDown\picture\image-20230506102910775.png)

但有的说这个答案有点牵强

![image-20230506102920371](E:\MarkDown\picture\image-20230506102920371.png)





![image-20230506103035649](E:\MarkDown\picture\image-20230506103035649.png)







![image-20230506103044603](E:\MarkDown\picture\image-20230506103044603.png)



![image-20230506103119902](E:\MarkDown\picture\image-20230506103119902.png)



![image-20230506103132178](E:\MarkDown\picture\image-20230506103132178.png)





![image-20230506103225964](E:\MarkDown\picture\image-20230506103225964.png)





![image-20230506103253387](E:\MarkDown\picture\image-20230506103253387.png)



![image-20230506104602293](E:\MarkDown\picture\image-20230506104602293.png)



![image-20230506104640659](E:\MarkDown\picture\image-20230506104640659.png)





![image-20230506104811699](E:\MarkDown\picture\image-20230506104811699.png)





![image-20230506104819979](E:\MarkDown\picture\image-20230506104819979.png)



<img src="E:\MarkDown\picture\image-20230506104916001.png" alt="image-20230506104916001" style="zoom:80%;" />





![image-20230506104925677](E:\MarkDown\picture\image-20230506104925677.png)





![image-20230506105053956](E:\MarkDown\picture\image-20230506105053956.png)



![image-20230506105101615](E:\MarkDown\picture\image-20230506105101615.png)



![image-20230506105224367](E:\MarkDown\picture\image-20230506105224367.png)



![image-20230506105233849](E:\MarkDown\picture\image-20230506105233849.png)



![image-20230506115351863](E:\MarkDown\picture\image-20230506115351863.png)





![image-20230506115402985](E:\MarkDown\picture\image-20230506115402985.png)



![image-20230506115612744](E:\MarkDown\picture\image-20230506115612744.png)



![image-20230506115620902](E:\MarkDown\picture\image-20230506115620902.png)



![image-20230506115726835](E:\MarkDown\picture\image-20230506115726835.png)



B 这种展开图，反推会比较方便



![image-20230506115827647](E:\MarkDown\picture\image-20230506115827647.png)





![image-20230506115856688](E:\MarkDown\picture\image-20230506115856688.png)



![image-20230506115926739](E:\MarkDown\picture\image-20230506115926739.png)





![image-20230506115946039](E:\MarkDown\picture\image-20230506115946039.png)



![image-20230506120106021](E:\MarkDown\picture\image-20230506120106021.png)



![image-20230506120118117](E:\MarkDown\picture\image-20230506120118117.png)



![image-20230506120201950](E:\MarkDown\picture\image-20230506120201950.png)





![image-20230506120211755](E:\MarkDown\picture\image-20230506120211755.png)





<img src="E:\MarkDown\picture\image-20230506183321959.png" alt="image-20230506183321959" style="zoom:50%;" />





![image-20230506183335028](E:\MarkDown\picture\image-20230506183335028.png)





<img src="E:\MarkDown\picture\image-20230506183428549.png" alt="image-20230506183428549" style="zoom:50%;" />





![image-20230506183440076](E:\MarkDown\picture\image-20230506183440076.png)





<img src="E:\MarkDown\picture\image-20230506183522561.png" alt="image-20230506183522561" style="zoom:50%;" />





![image-20230506183531803](E:\MarkDown\picture\image-20230506183531803.png)





<img src="E:\MarkDown\picture\image-20230506183731796.png" alt="image-20230506183731796" style="zoom:50%;" />







![image-20230506183740292](E:\MarkDown\picture\image-20230506183740292.png)





<img src="E:\MarkDown\picture\image-20230506183959405.png" alt="image-20230506183959405" style="zoom:50%;" />





![image-20230506184009320](E:\MarkDown\picture\image-20230506184009320.png)







<img src="E:\MarkDown\picture\image-20230506184155609.png" alt="image-20230506184155609" style="zoom:50%;" />





![image-20230506184142590](E:\MarkDown\picture\image-20230506184142590.png)









# 行测

同比 = （本期 - 上期）/ 上期





![image-20230424233333344](E:\MarkDown\picture\image-20230424233333344.png)

持有期收益 =【年现金股利额 + （股票卖出额 - 股票买入额）/ 股票持有年数】/ 股票买入额

   r = [0.88 + (57.50 - 52.68) / 1] / 52.68 = (0.88+4.82)/52.68=0.1082，即10.82%，最接近10.8% 





![image-20230424234449394](E:\MarkDown\picture\image-20230424234449394.png)

用二进制法表示十进制数：1-15 (2^4 =16>15，所以四个就行)

左边是二进制，右边是对应得十进制       

 0001    1 
 0010    2 
 0011    3 
 0100    4 
 0101    5
 0110    6 
 0111    7 
 1000    8
 1001    9
 1010    10
 1011    11
 1100    12 
 1101    13
 1110    14
 1111    15

用二进制数字当做15瓶水的编号，第一只老鼠尝首位为0的，第二只尝第二位为0，第三只第三位0，第四只第四位0    假如除了第一只之外都死了，那有毒的可乐为1000，其他同理，所以4只就够了 



# java

<img src="E:\MarkDown\picture\image-20230512210352384.png" alt="image-20230512210352384" style="zoom:50%;" />



**Java一维数组有两种初始化方法**
**1、静态初始化** 

`int array[] = new int[]{1,2,3,4,5} `

或者 `int array[] = {1,2,3,4,5} `

需要**注意**的是，写成如下形式也是**错误**的 `int array[] = new int[5]{1,2,3,4,5} `

**2、动态初始化**

`int array[] = new int[5]; array[0] = 1; array[1] = 2; array[2] = 3; array[3] = 4; array[4] = 5; ` 

静态与动态初始化的区别就在于，前者是声明的时候就初始化，后者是先声明，再动态初始化。收起 





<img src="E:\MarkDown\picture\image-20230512210715945.png" alt="image-20230512210715945" style="zoom:50%;" />



创建go()方法，在go()方法中实现Runnable接口创建线程并重写run()方法，然后创建Thread实例，用start()方法开启线程。





<img src="E:\MarkDown\picture\image-20230512210819919.png" alt="image-20230512210819919" style="zoom:50%;" />

B错在final所修饰的成员变量只能赋值一次，可以在类方法中赋值，也可以在声明的时候直接赋值

# spring

<img src="E:\MarkDown\picture\image-20230512222419173.png" alt="image-20230512222419173" style="zoom:67%;" />



![image-20230512222522422](E:\MarkDown\picture\image-20230512222522422.png)



@ComponentScan注解默认规则是对当前包及其子包中的Bean进行扫描。



<img src="E:\MarkDown\picture\image-20230512222556678.png" alt="image-20230512222556678" style="zoom:67%;" />



<img src="E:\MarkDown\picture\image-20230512222631695.png" alt="image-20230512222631695" style="zoom:67%;" />

拦截器需实现HandlerInterceptor接口，而WebMvcConfigurer接口是MVC配置类要实现的接口。



<img src="E:\MarkDown\picture\image-20230512222912491.png" alt="image-20230512222912491" style="zoom:67%;" />



<img src="E:\MarkDown\picture\image-20230512222937708.png" alt="image-20230512222937708" style="zoom:67%;" />

Spring容器中Bean包含五种作用域：singleton、prototype、request、session、globalSession。



<img src="E:\MarkDown\picture\image-20230512223033252.png" alt="image-20230512223033252" style="zoom:70%;" />

在Spring MVC中实现上传功能，主要依赖MultipartHttpServletRequest从读取请求中的文件，然后对读取到的MultipartFile类型进行处理。



<img src="E:\MarkDown\picture\image-20230512223245077.png" alt="image-20230512223245077" style="zoom:70%;" />





![image-20230512223321183](E:\MarkDown\picture\image-20230512223321183.png)

Spring MVC拦截器包含三个方法：preHandle()、postHandle()、afterCompletion()。

# 算法题

## 分蛋糕

有两种蛋糕，榴莲蛋糕和冰淇淋蛋糕，其中榴莲蛋糕被分成了 a 块，冰淇淋蛋糕被分成了 b 块。总共有 n 个盘子，每种蛋糕能够整除均分到各个盘子里，要求一个盘子里面不能含有两种蛋糕，每个盘子至少含有2块蛋糕，所有的蛋糕必须放到盘子里面去。求一个盘子里最少有多少块蛋糕。不能做到的话返回 0

示例1

输入例子：

```
2,5,4
```

输出例子：

```
4
```

例子说明：

```
榴莲蛋糕被分成了5块，冰淇淋蛋糕被分成了4块，分别放到2个盘子里面去，1个盘子5块榴莲蛋糕，1个盘子4块冰淇淋蛋糕，1个盘子里最少4块蛋糕，返回4
```

示例2

输入例子：

```
5,3,2
```

输出例子：

```
0
```

例子说明：

```
榴莲蛋糕被分成了3块，冰淇淋蛋糕被分成了2块，分别放到5个盘子里面去，要求每个盘子至少含有2块蛋糕，无法做到，返回0
```

```cpp
class Solution {
public:
    int minCake (int n, int a, int b) {
        int minV = INT_MAX;
        for (int i = 1; i < n; i++) {
            if (aa(i, a) && aa(n - i, b)) {
                minV = min({minV, a / i, b / (n - i)});
            }
        }
        if (minV == INT_MAX) return 0;
        return minV;
    }
    bool aa(int i, int a) {
        if (a >= i * 2 && a % i == 0) return true;
        return false;
    }
};
```





























