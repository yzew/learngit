# 操作系统

**操作系统的载入**

​	操作系统一开始放在硬盘(磁盘)上，而计算机工作需要取址执行，需要将操作系统的代码载入到内存里，否则没法取址执行。这一步工作由BOOTSECT.s完成；而setup负责完成OS启动前的设置。最后他执行了一条指令，令硬件进入保护模式



****

**寄存器、CPU L1/L2/L3 Cache(|kæʃ|) 都属于存储设备，区别在哪？**

* 寄存器是CPU为了运算，必须要有的临时存放数据的器件，作用是存储计算时的数据；
* cache即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器，是为了弥补CPU和内存的速度上的差异设置的缓存。计算机系统中Cache的引入，降低了内存访问时延，也大幅提升内存访问带宽，在目前的内存技术条件下，以比较经济的手段大幅度地提升了系统的整体性能。但会带来共享数据的cache一致性问题。
* 寄存器是中央处理器的一部分，是CPU内部的组件，包括通用寄存器、程序计数器、指令寄存器等；Cache并不是每个CPU都有的，也在CPU内部，**CPU Cache**，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。通常会分为 **L1、L2、L3 三层**，其中 L1 Cache 通常分成「数据缓存」和「指令缓存」，L1 是距离 CPU 最近的，因此它比 L2、L3 的读写速度都快、存储空间都小。







**异步**

> 比如回收内存的方式中，后台内存回收就是异步的，直接内存回收是同步的

​	同步，就是调用某个东西时，调用方得等待这个调用返回结果才能继续往后执行。异步和同步相反，调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回调函数来处理这个调用（异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。

​	异步指的是让CPU暂时搁置当前请求的响应,处理下一个请求,当通过轮询或其他方式得到回调通知后,再开始运行。多线程将异步操作放入另一线程中运行，通过轮询或回调方法得到完成通知,但是完成端口，由操作系统接管异步操作的调度，通过硬件中断，在完成时触发回调方法，**此方式不需要占用额外线程**。

![image-20230218093201643](E:\MarkDown\picture\image-20230218093201643.png)



## **SMP与NUMA架构**

​	SMP架构，即对称多处理(Symmetrical Multi-Processing) |sɪˈmetrɪk(ə)l|，这种系统也被称为一致存储访问结构（UMA，Uniform Memory Access），多个CPU共享相同的物理资源，如总线、内存、IO、操作系统等，每个CPU访问内存所用的时间都是相同的。但多个CPU都通过一个总线访问内存，总线压力会很大，且每个CPU可用带宽会减少。

​	NUMA 结构，即非一致存储访问结构（Non-uniform memory access，NUMA）。将GPU分组，每组有独立的内存、IO等

![image-20230218095637040](E:\MarkDown\picture\image-20230218095637040.png)



NUMA架构中有很多NUMA节点，内存中使用`struct pglist_data`这个数据结构来描述NUMA节点，用大小为MAX_NUMNODES，类型为`struct pglist_data`的全局数据node_data[]来管理所有的NUMA节点。而`struct pglist_data`中`struct page`类型的数组`*node_mem_map`指向了NUMA节点内的物理内存页

```cpp
typedef struct pglist_data {
    // NUMA 节点id
    int node_id;
    // 指向 NUMA 节点内管理所有物理页 page 的数组
    struct page *node_mem_map;
    // NUMA 节点内第一个物理页的 pfn
    unsigned long node_start_pfn;
    // NUMA 节点内所有可用的物理页个数（不包含内存空洞）
    unsigned long node_present_pages;
    // NUMA 节点内所有的物理页个数（包含内存空洞）
    unsigned long node_spanned_pages; 
    // 保证多进程可以并发安全的访问 NUMA 节点
    spinlock_t node_size_lock;
        .............
}

```





## **单位换算**

**1GB = 2^10 MB = 1024 MB = 2^20 KB = 2^30 B**

1B = 1byte = 8bits 一个字节为8位

在 32 位机器上，指针的寻址范围为 2^32，所能表达的虚拟内存空间为 4 GB。所以在 32 位机器上进程的虚拟内存地址范围为：0x0000 0000 - 0xFFFF FFFF。0x0000 0000中一个0代表2^4，一共能表示 2^32



## **LRU(Least recently used)算法**

对应小林4.5

文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：

* **active_list** 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；
* **inactive_list** 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；

越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。

传统的 LRU 算法存在两个问题：

* **「预读失效」导致缓存命中率下降**
  会使得操作系统在读磁盘的时候额外多读一些到内存中，但最后这些数据也没有用到
* **「缓存污染」导致缓存命中率下降**
  批量读数据的时候，可能把热点数据挤出去









**信号量**

* *P 操作*：将 `sem` 减 `1`，相减后，如果 `sem < 0`，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；
* *V 操作*：将 `sem` 加 `1`，相加后，如果 `sem <= 0`，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；

如资源量是2，则俩线程进入工作后，sem就为0了，此时再有线程，sem变为-1，这个线程就进入等待状态。如果前面的俩线程中有一个好了，执行V，此时Sem = 0，则唤醒那个等待的线程

![PV 操作的算法描述](E:\MarkDown\picture\17-操作系统PV算法描述.jpg)

将sem设为**1**，就可以实现**互斥**；将sem设为**0**，就可以实现**同步**

同步：
![img](E:\MarkDown\picture\19-互斥信号量同步实现-吃饭例子.jpg)

妈妈一开始询问儿子要不要做饭时，执行的是 `P(s1)` ，相当于询问儿子需不需要吃饭，由于 `s1` 初始值为 0，此时 `s1` 变成 -1，表明儿子不需要吃饭，所以妈妈线程就进入等待状态。

当儿子肚子饿时，执行了 `V(s1)`，使得 `s1` 信号量从 -1 变成 0，表明此时儿子需要吃饭了，于是就唤醒了阻塞中的妈妈线程，妈妈线程就开始做饭。

接着，儿子线程执行了 `P(s2)`，相当于询问妈妈饭做完了吗，由于 `s2` 初始值是 0，则此时 `s2` 变成 -1，说明妈妈还没做完饭，儿子线程就等待状态。

最后，妈妈终于做完饭了，于是执行 `V(s2)`，`s2` 信号量从 -1 变回了 0，于是就唤醒等待中的儿子线程，唤醒后，儿子线程就可以进行吃饭了





thread

join()函数是一个等待线程完成函数，主线程需要等待子线程运行结束了才可以结束（注意不是才可以运行，运行是并行的），如果打算等待对应线程，则需要细心挑选调用join()的位置

detach()函数称为分离线程函数，是子线程的分离函数，当调用该函数后，线程就被分离到后台运行，主线程不需要等待该线程结束才结束。通常称分离线程为守护线程(daemon threads)



## 1.

<img src="E:\MarkDown\picture\image-20221209193244071.png" alt="image-20221209193244071" style="zoom: 33%;" />





通过管道将一个程序的输出传递到另一个文件中

将命令用管道链接起来，将一个程序的输出作为另一个程序的输入

```
./a.out | python3 seven-seg.py
```



wget

GNU Wget(常常简称为wget）是一个网络上进行下载的简单而强大的自由软件

```
wget http://jyywiki.cn/pages/OS/2022/demos/hanoi-r.c
```

上述命令将会下载一个名字hanoi-r.c的文件，并保存到当前文件夹（打开终端的所在文件夹）



再用vi打开

```
vi hanoi-r.c
```



ls

查看当前目录下文件



gdb

是 Linux 下常用的程序调试器

实际场景中，GDB 更常用来调试 C 和 C++ 程序。一般来说，GDB主要帮助我们完成以下四个方面的功能：

1. 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
2. 在某个指定的地方或条件下暂停程序。
3. 当程序被停住时，可以检查此时你的程序中所发生的事。
4. 在程序执行过程中修改程序中的变量或条件，将一个bug产生的影响修正从而测试其他bug。



syscall

内核提供用户空间程序与内核空间进行交互的一套标准接口，这些接口让用户态程序能**受限**访问硬件设备，比如申请系统资源，操作设备读写，创建新进程等。用户空间发生请求，内核空间负责执行，这些接口便是用户空间和内核空间共同识别的桥梁，这里提到两个字“受限”，是由于为了保证内核稳定性，而不能让用户空间程序随意更改系统，必须是内核对外开放的且满足权限的程序才能调用相应接口。

在用户空间和内核空间之间，有一个叫做Syscall(系统调用, system  call)的中间层，是连接用户态和内核态的桥梁。这样即提高了内核的安全型，也便于移植，只需实现同一套接口即可。Linux系统，用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。对于每个系统调用都会有一个对应的系统调用号，比很多操作系统要少很多。

安全性与稳定性：内核驻留在受保护的地址空间，用户空间程序无法直接执行内核代码，也无法访问内核数据，通过系统调用

性能：Linux上下文切换时间很短，以及系统调用处理过程非常精简，内核优化得好，所以性能上往往比很多其他操作系统执行要好。



PC

​	PC(Program Counter,PC)程序计数器/指令计数器。用来存放当前欲执行指令的地址，它与主存的MAR之间有一条直接通路，且具有自加1的功能，即可形成下一条指令的地址。

是用于存放下一条指令所在单元的地址的地方



glibc 和 libc

glibc 和 libc 都是 Linux 下的 C 函数库。 
 libc 是 Linux 下的 ANSI C 函数库；glibc 是 Linux 下的 GUN C 函数库。



 

## 2.操作系统中的程序

![image-20221211162735241](E:\MarkDown\picture\image-20221211162735241.png)

>**gdb程序调试器，一个debug工具**
>
>gdb启动程序的三种方式：run start starti
>
>* run -- Start debugged program.
>
>开始执行程序，如果没有设置断点，不会停下。
>
>* start -- Start the debugged program stopping at the beginning of the main procedure.
>
>开始执行程序，在main 函数处会停下来
>
>* starti -- Start the debugged program stopping at the first instruction.
>
>开始执行程序，在第一条指令处会停下来

```
1.进入调试状态：
gdb a.out
2.在第一条指令处停下来
starti
3.输入starti后，输出告诉我们是ld-linux-x86-64.so(加载器)加载了libc，完成初始化
```

![image-20221211163702784](E:\MarkDown\picture\image-20221211163702784.png)

1.main()的开始和结束并不是整个程序的开始和结束，参照hello-goodbye.c

通过constructor和destructor，我们就可以在main函数执行前和后打印

```c
#include <stdio.h>

__attribute__((constructor)) void hello() {
  printf("Hello, World\n");
}

// See also: atexit(3)
__attribute__((destructor)) void goodbye() {
  printf("Goodbye, Cruel OS World!\n");
}

int main() {
}
```

2.这个也可以改成别的.so，比如复制ld-linux-x86-64.so的内容，改个名叫rtfm.so也可以



![image-20221211163539551](E:\MarkDown\picture\image-20221211163539551.png)

对于这个问题的回答，我们可以使用Trace工具

![image-20221211164543724](E:\MarkDown\picture\image-20221211164543724.png)

通过strace ./hello-goodbye，就可以看到所有的系统调用：

先通过execve调用 -> 进行各种各样的系统调用 -> 退出

![image-20221211164759753](E:\MarkDown\picture\image-20221211164759753.png)





![image-20221211165109510](E:\MarkDown\picture\image-20221211165109510.png)

1.可以通过strace -f gcc a.c看编译器是怎样完成一个编译过程，`strace -f gcc a.c &| vim -`或`strace -f gcc a.c |& vim -`将内容放到vim中看看

2.grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来

3.也可以通过strace看图形界面会调用什么

![image-20221211170840275](E:\MarkDown\picture\image-20221211170840275.png)

总结

![image-20221211170912311](E:\MarkDown\picture\image-20221211170912311.png)

如果一个程序不访问系统调用，那就只能计算；如果访问系统调用，则是操作系统上的程序，即通过syscall指令进行系统调用，操作系统提供实现所有功能的API

## 3.多处理器编程（线程库；现代处理器和宽松内存模型）

![image-20221212164320486](E:\MarkDown\picture\image-20221212164320486.png)

c语言程序相当于一个状态机，每次执行一条语句，从一个状态到另一个状态：
全局变量、堆区中malloc分配的对象，都是共享状态；
程序在执行的时候有一个栈，由栈帧frame组成，每个帧里都有局部变量和PC；

编译器：将C语言的状态机转换为一个机器对应的状态机



<img src="E:\MarkDown\picture\image-20221212180420514.png" alt="image-20221212180420514" style="zoom:50%;" />

![image-20221212164538127](E:\MarkDown\picture\image-20221212164538127.png)

并发和并行

**并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。**

并发是看似同时干很多事，实际是操作系统将时间片轮流分配给各个任务。多个任务之间是抢占资源的

**并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。**

系统要有多个CPU才会出现并行。在有多个CPU的情况下，才会出现真正意义上的『同时进行』，并行的多个任务之间不相互抢占资源


<img src="E:\MarkDown\picture\image-20221212164550082.png" alt="image-20221212164550082" style="zoom:47%;" />

不同线程有自己的栈帧链



![image-20221212164559742](E:\MarkDown\picture\image-20221212164559742.png)

当前线程调用join，则会被堵塞，直到其他线程都执行完

因为代码中使用了pthread线程库，因此编译时需要增加-lpthread
`gcc a.c -lpthread`



![image-20221212164608980](E:\MarkDown\picture\image-20221212164608980.png)

这个双线程程序会交替出现a和b，可以是一个cpu的多线程，也可以是两个CPU执行两个线程



![image-20221212164620337](E:\MarkDown\picture\image-20221212164620337.png)

通过Trace可以发现，创建线程使用的是clone这个系统调用

```c
// shm-test.c
#include "thread.h"

int x = 0;

void Thello(int id) {
  usleep(id * 100000);
  printf("Hello from thread #%c\n", "123456789ABCDEF"[x++]);
}

int main() {
  for (int i = 0; i < 10; i++) {
    create(Thello);
  }
}
```

输出#1 ... #9 #A，共享内存



证明线程有独立的堆栈

最后得到一个栈帧的大小是8192KB，即1024*8=8MB，线程的一个栈是8M

```c
// stack-probe.c 
#include "thread.h"

// 定义成线程局部的变量，每个线程都有一个副本
// __thread是GCC内置的线程局部存储设施
__thread char *base, *cur; // thread-local variables
__thread int id;

// noinline：通知编译器强制不内联这个函数。可以方便我们在二进制代码里看到这函数是怎么实现的
// objdump to see how thread-local variables are implemented
__attribute__((noinline)) void set_cur(void *ptr) { cur = ptr; }
__attribute__((noinline)) char *get_cur()         { return cur; }

void stackoverflow(int n) {
  set_cur(&n);
  if (n % 1024 == 0) {
    // sz就是一个栈帧的大小
    int sz = base - get_cur();
    printf("Stack size of T%d >= %d KB\n", id, sz / 1024);
  }
  stackoverflow(n + 1);
}

void Tprobe(int tid) {
  id = tid;
  // 这里取了个地址。局部变量是保存在栈上的，然后把这个地址给了base
  base = (void *)&tid;
  // stackoverflow无限制的创建栈帧
  stackoverflow(0);
}

int main() {
  setbuf(stdout, NULL);
  // 创建了四个线程
  for (int i = 0; i < 4; i++) {
    create(Tprobe);
  }
}
```



![image-20221212164640854](E:\MarkDown\picture\image-20221212164640854.png)

本课提供的thread.h的API，就是把pthread这个比较复杂的线程库进行了封装，调用了pthread_join和pthread_create等函数

`man 7 pthreads`可以查看pthread的手册

`man 3 pthread_create`可以查看这个函数的实现



<img src="E:\MarkDown\picture\image-20221212164658334.png" alt="image-20221212164658334" style="zoom:50%;" />

![image-20221212164712212](E:\MarkDown\picture\image-20221212164712212.png)

两个线程同时调用这个函数，如第一个线程先走到第一个if分支里，判断钱够了；此时第二个线程也走到第一个if分支里，也判断钱够了。

```cpp
// alipay.c
#include "thread.h"

unsigned long balance = 100;

void Alipay_withdraw(int amt) {
  if (balance >= amt) {
    usleep(1); // unexpected delays
    balance -= amt;
  }
}

void Talipay(int id) {
  Alipay_withdraw(100);
}

int main() {
  create(Talipay);
  create(Talipay);
  join();
  printf("balance = %lu\n", balance);
}
```

如果两个线程按顺序执行，那是0，但若同时进了if判断有钱了，会输出2^64-100，是因为整数溢出，变成了补码

![image-20221212164732571](E:\MarkDown\picture\image-20221212164732571.png)

即使是使用汇编的addl指令加一，也不行

```c
// sum.c
#include "thread.h"
#define N 100000000
long sum = 0;
void Tsum() {
  for (int i = 0; i < N; i++) {
    sum++;
  }
}

// 汇编生成add指令，也不行
void Tsum1() {
  for (int i = 0; i < N; i++) {
    asm volatile("add $1, %0": "+m"(sum));
    // sum++;
  }
}

// 再加上一条带lock的指令就好了，这个后面会讲。但问题是程序的运行速度会显著下降
void Tsum2() {
  for (int i = 0; i < N; i++) {
    asm volatile("lock add $1, %0": "+m"(sum));
    // sum++;
  }
}

int main() {
  create(Tsum);
  create(Tsum);
  join();
  printf("sum = %ld\n", sum);
}
```



![image-20221212164739460](E:\MarkDown\picture\image-20221212164739460.png)

![image-20221212164745770](E:\MarkDown\picture\image-20221212164745770.png)

但print语句就是正确的结果，没有print到一半就干别的了。读手册`man 3 printf`可以发现，printf的属性中是有Thread safety的，可以保证原子性

![image-20221212164751457](E:\MarkDown\picture\image-20221212164751457.png)

lock和unlock之间就是临界区；

把大任务分割为小任务后，交给一个个thread去执行



<img src="E:\MarkDown\picture\image-20221212164803337.png" alt="image-20221212164803337" style="zoom:50%;" />

![image-20221212164811973](E:\MarkDown\picture\image-20221212164811973.png)

即`gcc -01 sum.c -lpthread`

![image-20221212164821031](E:\MarkDown\picture\image-20221212164821031.png)

编译器的基本假设是，按顺序的、单线程的程序来优化代码。编译器对系统调用不做优化，但对内存是可以优化的，如x+1;x+1;会被优化为x+2;是 **最终一致** 的

对于o1，是将sum放到寄存器(r)里，然后中间做了很多次操作得到N，然后在寄存器里+N，再放回sum中。因此在o1的情况下，两个线程里的sum一开始都是0，放入寄存器里的也都是0，进行一系列操作后都得到N=10000，然后寄存器里+N，再放回sum中，此时写入sum的就都是100000

对于o2，是就优化为了一条add语句



对于while (!done)的语句，编译器假设程序是顺序的，会被编译器优化为if (!done) while (1);这会造成很大的问题！！！！！！！本来是等着别的程序更改done，就能跳过死循环的，结果这一直在循环！！！

如果不想让编译器去优化：

![image-20221212164827107](E:\MarkDown\picture\image-20221212164827107.png)

> volatile关键字
>
> C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的 memory barrier（内存屏障）。这是 BS 在 "The C++ Programming Language" 对 volatile 修饰词的说明：
>
> > volatile说明符是对编译器的一个提示，一个对象可能会以语言没有指定的方式改变其值，因此必须避免激进的优化。
>
> 遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：`int volatile vInt; `当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
>
> volatile 指出vInt是随时可能发生变化的，每次使用它的时候必须从vInt的地址中读取，因而编译器生成的汇编代码会重新从vInt的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从vInt读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从vInt里面读。这样以来，如果vInt是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。

```c
// 原程序
extern int done;

void join() {
    while (!done);
}

// 修改其为barrier
extern int done;

void join() {
    while (!done) {
        // 加入这条语句后，就会每次都读一下done，看看也没有别的程序来改内存的值
        asm volatile("":::"memory");
    }
}

// 另一种修改方法
extern int volatile done;

void join() {
    while (!done);
}
```





最大的麻烦：

<img src="E:\MarkDown\picture\image-20221212164834152.png" alt="image-20221212164834152" style="zoom:50%;" />

![image-20221212164847191](E:\MarkDown\picture\image-20221212164847191.png)

根据我们的推测，对于T1、T2两个线程，我们都做了内存屏障。执行T1，会输出1，0，执行T2，会输出0，1，先执行T1再执行T2或先执行T2再执行T1，都会输出1，1。不存在0，0的状态

```c
// mem-ordering.c
#include "thread.h"

int x = 0, y = 0;

// 原子对象，相当于一个开关
atomic_int flag;

#define FLAG atomic_load(&flag)
#define FLAG_XOR(val) atomic_fetch_xor(&flag, val)
#define WAIT_FOR(cond) while (!(cond)) ;

 __attribute__((noinline))
void write_x_read_y() {
  int y_val;
  asm volatile(
    "movl $1, %0;" // x = 1
    "movl %2, %1;" // y_val = y
    : "=m"(x), "=r"(y_val) : "m"(y)
  );
  printf("%d ", y_val);
}

 __attribute__((noinline))
void write_y_read_x() {
  int x_val;
  asm volatile(
    "movl $1, %0;" // y = 1
    "movl %2, %1;" // x_val = x
    : "=m"(y), "=r"(x_val) : "m"(x)
  );
  printf("%d ", x_val);
}

void T1(int id) {
  while (1) {
    WAIT_FOR((FLAG & 1));  // 先判断自己的开关有没有被推上去
    write_x_read_y();  // 执行这个写x读y
    FLAG_XOR(1);  // 把开关推下去
    
  }
}

void T2() {
  while (1) {
    WAIT_FOR((FLAG & 2));
    write_y_read_x();
    FLAG_XOR(2);
  }
}

void Tsync() {
  while (1) {
    x = y = 0;
    __sync_synchronize(); // full barrier
    usleep(1);            // + delay
    assert(FLAG == 0);  // 确保开关都是关的
    FLAG_XOR(3);  // 异或3，将0，0变为1，1，同时打开两个开关
    // T1 and T2 clear 0/1-bit, respectively
    WAIT_FOR(FLAG == 0);
    printf("\n"); fflush(stdout);
  }
}

int main() {
  create(T1);
  create(T2);
  create(Tsync);
}
```

./a.out | head -n 10

显示输出结果的前10行

./a.out | head -n 100000 | sort | uniq -c

可以对100000行输出的结果排序然后统计

输出：

```c
789080 0 0
206442 0 1
  4170 1 0
   388 1 1
```

**可以发现，实际的输出有0 0状态！！！！！！！！！**

原因：



![image-20221212164856302](E:\MarkDown\picture\image-20221212164856302.png)

处理器内部会维护一个uop的池子，是一个有向无环图，池子中有数据之间的依赖关系图(如有覆盖写的关系等，就不会被改变顺序)以及指令的执行顺序等。

从一个时钟周期中取出多条指令，同时执行。每个μop都有拿来、分配、执行、提交/委托四个阶段



这种更微小的指令的执行，就会造成出现0 0这种奇怪的现象

![image-20221212164907848](E:\MarkDown\picture\image-20221212164907848.png)

满足单处理器 **最终内存一致性**，在多处理器间会发生即时可见性的丧失

比如写入x=1时cache miss（cache中当前并没有缓存该变量，故发生cache miss, 于是从主内存中加载该变量进入其cache），就会执行下一条指令，此时读到的x=0，就会出现x y都为0的现象

![image-20221212164924894](E:\MarkDown\picture\image-20221212164924894.png)

除了共享内存，每个线程都有一个buffer，写入到buffer中，延迟任意长时间后才写入memory

![image-20221212164937122](E:\MarkDown\picture\image-20221212164937122.png)

* 可以在两条写入命令间加入mfence指令可以保证内存写入到共享内存后，才执行下一条指令
* 也可以使用原子指令

<img src="E:\MarkDown\picture\image-20221212164949064.png" alt="image-20221212164949064" style="zoom:50%;" />

![image-20221212164957641](E:\MarkDown\picture\image-20221212164957641.png)

## 4.理解并发程序执行

![image-20221221171430313](E:\MarkDown\picture\image-20221221171430313.png)



<img src="E:\MarkDown\picture\image-20221221171441996.png" alt="image-20221221171441996" style="zoom:50%;" />

![image-20221221171455406](E:\MarkDown\picture\image-20221221171455406.png)



![image-20221221171504151](E:\MarkDown\picture\image-20221221171504151.png)

如果不是UNLOCK，就goto retry继续等待

问题是，一开始是解锁。第一个线程发现是解锁，然后从if判断跳转到locked=LOCK，但此时还未执行lock，还是unlock的；此时第二个线程执行，判断后发现unlock，于是也跳转到locked=LOCK。此时程序是解锁状态，而两个线程都到了locked=LOCK这一步，无论执行哪个，都将lock，但此时两个线程都可以进行操作，我们这个锁就形同虚设了。

根本原因是这个load lock+store lock的操作没法原子的完成。如果能一步就加载锁然后一下锁上，就是可以的

![image-20221221171512087](E:\MarkDown\picture\image-20221221171512087.png)

![image-20221221171525552](E:\MarkDown\picture\image-20221221171525552.png)



![image-20221221171537373](E:\MarkDown\picture\image-20221221171537373.png)

PC=1就是在程序的第一行

![image-20221221171548812](E:\MarkDown\picture\image-20221221171548812.png)



<img src="E:\MarkDown\picture\image-20221221171556810.png" alt="image-20221221171556810" style="zoom:50%;" />

![image-20221221171607683](E:\MarkDown\picture\image-20221221171607683.png)

![image-20221221171620096](E:\MarkDown\picture\image-20221221171620096.png)

通过我们写的model-checker.py，就可以实现让电脑生成状态。model-checker.py是如何实现的？

使用了python的一个特性——>Generator

![image-20221221171627197](E:\MarkDown\picture\image-20221221171627197.png)

yield就可以创建一个状态机，g保存了状态，g.next就是沿着状态机不断执行

model-checker.py就可以通过yield和next得到每个线程执行后的状态


<img src="E:\MarkDown\picture\image-20221221212524530.png" alt="image-20221221212524530" style="zoom:80%;" />

![image-20221221171642506](E:\MarkDown\picture\image-20221221171642506.png)



![image-20221221171656526](E:\MarkDown\picture\image-20221221171656526.png)

![image-20221221171706978](E:\MarkDown\picture\image-20221221171706978.png)



<img src="E:\MarkDown\picture\image-20221221171714910.png" alt="image-20221221171714910" style="zoom:50%;" />

![image-20221221171724138](E:\MarkDown\picture\image-20221221171724138.png)



![image-20221221171733428](E:\MarkDown\picture\image-20221221171733428.png)



![image-20221221171740462](E:\MarkDown\picture\image-20221221171740462.png)



<img src="E:\MarkDown\picture\image-20221221171748971.png" alt="image-20221221171748971" style="zoom:50%;" />

![image-20221221171756476](E:\MarkDown\picture\image-20221221171756476.png)



## 5.并发控制：互斥（自旋锁、互斥锁和futex

![image-20221225165525460](E:\MarkDown\picture\image-20221225165525460.png)



<img src="E:\MarkDown\picture\image-20221225165535743.png" alt="image-20221225165535743" style="zoom:50%;" />

![image-20221225165548173](E:\MarkDown\picture\image-20221225165548173.png)

![image-20221225165558214](E:\MarkDown\picture\image-20221225165558214.png)

![image-20221225165608330](E:\MarkDown\picture\image-20221225165608330.png)

### 自旋锁

<img src="E:\MarkDown\picture\image-20221225165618239.png" alt="image-20221225165618239" style="zoom:50%;" />

![image-20221225165626625](E:\MarkDown\picture\image-20221225165626625.png)

计算机系统提供的机制：

![image-20221225165636277](E:\MarkDown\picture\image-20221225165636277.png)

```c
// sum-atomic.c 原子指令实现sum
#include "thread.h"
#define N 100000000
long sum = 0;
void Tsum() {
  for (int i = 0; i < N; i++) {
     // 在内联汇编的前面加了个lock，保证其他的任务不会影响sum
    asm volatile("lock addq $1, %0": "+m"(sum));
  }
}

int main() {
  create(Tsum);
  create(Tsum);
  join();
  printf("sum = %ld\n", sum);
}

// load和store就是将一个变量读出来，再将另一个变量写进去
// 这就相当于原子的交换指令
int xchg(volatile int *addr, int newval) {
  int result;
    // xchg就是个负责交换的原子指令。所以这里不加lock也行
  asm volatile ("lock xchg %0, %1"
    : "+m"(*addr), "=a"(result) : "1"(newval));
  return result;
}
```



![image-20221225165650958](E:\MarkDown\picture\image-20221225165650958.png)

当有人想上厕所时，先让其他同学都停住，然后看看桌子上是否有🔑，有的话xchg，进厕所后再让其他同学继续行动

因此通过硬件提供原子指令的xchg，就可以实现自旋锁：

![image-20221225165716159](E:\MarkDown\picture\image-20221225165716159.png)

下面的代码是更精简的代码

![image-20221225165732516](E:\MarkDown\picture\image-20221225165732516.png)



![image-20221225165747122](E:\MarkDown\picture\image-20221225165747122.png)

cache使得lock指令的实现变得更加困难，缓存一致性是个重要的问题。因此每个cache必须通过总线连起来，改变其中一个的同时，其他cache里的这个变量也必须同时改变

![image-20221225165756401](E:\MarkDown\picture\image-20221225165756401.png)

![image-20221225165807885](E:\MarkDown\picture\image-20221225165807885.png)



![image-20221225165816935](E:\MarkDown\picture\image-20221225165816935.png)



![image-20221225165825722](E:\MarkDown\picture\image-20221225165825722.png)



![image-20221225165842276](E:\MarkDown\picture\image-20221225165842276.png)



<img src="E:\MarkDown\picture\image-20221225165858175.png" alt="image-20221225165858175" style="zoom:50%;" />

![image-20221225165907139](E:\MarkDown\picture\image-20221225165907139.png)



![image-20221225165916232](E:\MarkDown\picture\image-20221225165916232.png)



![image-20221225165925590](E:\MarkDown\picture\image-20221225165925590.png)





![image-20221225165942595](E:\MarkDown\picture\image-20221225165942595.png)



![image-20221225165951890](E:\MarkDown\picture\image-20221225165951890.png)



<img src="E:\MarkDown\picture\image-20221225165959943.png" alt="image-20221225165959943" style="zoom:50%;" />

![image-20221225170007804](E:\MarkDown\picture\image-20221225170007804.png)



![image-20221225170016673](E:\MarkDown\picture\image-20221225170016673.png)



![image-20221225170038313](E:\MarkDown\picture\image-20221225170038313.png)



<img src="E:\MarkDown\picture\image-20221225170046762.png" alt="image-20221225170046762" style="zoom:50%;" />

![image-20221225170100873](E:\MarkDown\picture\image-20221225170100873.png)



## 6.并发控制：同步











