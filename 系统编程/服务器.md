第二章 Linux多进程开发

## 2.9 waitpid函数

![在这里插入图片描述](E:\MarkDown\picture\50cec2b071d14632b7eec54b503fa369.png)
由于子进程一直没有结束，所以 这里是非阻塞的，父进程会一直输出语句
非阻塞会一直往下面运行程序，不会一直停在waitpid
![在这里插入图片描述](E:\MarkDown\picture\2cf9bbfc7c4c451e8e1e8abb78244284.png)

默认阻塞就把opition那里改成0，默认阻塞的情况父进程只会输出一条语句，子进程会一直输出  
阻塞情况下会一直运行waitpid  
![在这里插入图片描述](E:\MarkDown\picture\d6c88347f0d54456ae25ebf7363ced53.png)  
![在这里插入图片描述](E:\MarkDown\picture\d30895521d5e43b7ba14c7d4b89e9f91.png)  
![在这里插入图片描述](E:\MarkDown\picture\d3e428f17ccc43e49f17e250e24803a1.png)

把子进程kill掉后  
![在这里插入图片描述](E:\MarkDown\picture\eb7db1dde65249d7b959b706c7d69cf1.png)  
![在这里插入图片描述](E:\MarkDown\picture\ac5c34f575364426a08eceebecc725aa.png)

## 2.11 匿名管道

![在这里插入图片描述](E:\MarkDown\picture\02b3d799197b4dfbabc2a81424c7fb7d.png)

[【Linux】linux下wc -l 命令](https://blog.csdn.net/Moonlight_16/article/details/125527386?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167967072416800211583217%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167967072416800211583217&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-125527386-null-null.142%5Ev76%5Econtrol,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=linux%20-l&spm=1018.2226.3001.4187)

## 2.12

父进程和子进程可以互相给对方发送数据和读取数据，但是顺序一定得是相反的，因为read是阻塞的  
![在这里插入图片描述](E:\MarkDown\picture\664e74983a764d219446f87e9f738ff2.png)

## 2.13

先创建管道再创建子进程才可以实现通信

## 2.14管道的读写特点和管道设置为非阻塞

非阻塞条件下就会一直read，就算没有数据父进程也会一直read，read不会阻塞在那里等待数据传过来

![在这里插入图片描述](E:\MarkDown\picture\c16d1e9fdd184e57abcda9cb54c63c76.png)

## 2.15 有名管道的介绍和使用

1.echo  
[linux命令echo的实现,Linux echo命令的使用及三种实现方式](https://blog.csdn.net/weixin_33508411/article/details/116553595?ops_request_misc=&request_id=&biz_id=102&utm_term=linux%20echo%20%3E%3E&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-116553595.142%5Ev76%5Einsert_down1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187)

2、有名管道只开启写端是不会开始写数据的，因为此时读端还没有开启，只有读端开启了管道才开始通信，才会开始写数据读数据

## 2.20 kill、raise、abort函数

1、kill  
![在这里插入图片描述](E:\MarkDown\picture\eddfcd8982734a63ab7f235a5ee28cff.png)  
父进程杀死子进程的例子：  
![在这里插入图片描述](E:\MarkDown\picture\c0f07e7c13bb4938b2bc2f5877c38500.png)

2、raise  
![在这里插入图片描述](E:\MarkDown\picture\5185394f7e4a4b618f7a73cbd68352d8.png)  
3、abort  
![在这里插入图片描述](E:\MarkDown\picture\29b9162fb43c44f49953254ae1ee2df4.png)

## 2.21 alarm函数

![在这里插入图片描述](E:\MarkDown\picture\fd09e6bc71d146928f2b3feaf8a9797a.png)  
被遮住的地方：  
不进行倒计时，不发送信号

比如第一次调用alarm(10) ,SIGALARM返回0，过了一秒后调用alarm(5)，因为之前有定时器倒计时10秒，所以返回9  
![在这里插入图片描述](E:\MarkDown\picture\493ed5580b9840b9aea9858868b6bcc7.png)

下面这个例子里面alarm（2）相当于重新设置倒计时为2s，所以过了2s后程序会结束  
![在这里插入图片描述](E:\MarkDown\picture\4d47e9a205d6475b92d8fac678910653.png)

![在这里插入图片描述](E:\MarkDown\picture\967a90efa2ca41c39d9019a780dd8865.png)  
![在这里插入图片描述](E:\MarkDown\picture\b92d1b709c2547308c087cba5179e9a7.png)

## 2.22 setitimer函数

![在这里插入图片描述](E:\MarkDown\picture\a57368d1136548e893102e6b905a121e.png)  
![在这里插入图片描述](E:\MarkDown\picture\9bf79093844843b29e72fbe38f5ea2c0.png)  
![在这里插入图片描述](E:\MarkDown\picture\c9d76f2ad95e4ac38168e4d0e363721e.png)  
![在这里插入图片描述](E:\MarkDown\picture\16f4d5e2c8a5474081fcfaf1f5d8e3f9.png)  
eg：定时器开始了一运行就打印出来了（因为是非阻塞的），3s之后就结束了程序  
这里的定时并没有体现，因为还没用到捕捉  
![在这里插入图片描述](E:\MarkDown\picture\bec4c762f8a34ed5a6281aee598437a9.png)

## 2.23 signal信号捕捉函数

![在这里插入图片描述](E:\MarkDown\picture\f974ea5079af4d43a984658a0e3726c2.png)

![在这里插入图片描述](E:\MarkDown\picture\147b8645ce404c5e81dcea8e50b07404.png)  
![在这里插入图片描述](E:\MarkDown\picture\1a8d9ef01a024aa6a73e61e470f9a939.png)

eg：信号捕捉设置设置定时器之前，还是上一节的例子，这里设置的是忽略信号，所以这个进程一直都不会结束  
![在这里插入图片描述](E:\MarkDown\picture\656a2f28f529412284371ddabf23e787.png)  
eg：设置回调函数  
![在这里插入图片描述](E:\MarkDown\picture\e7b353b377854b74a5b964064a2ba8ee.png)  
输出：  
打印”定时器开始了…”之后再过三秒第一次打印捕捉到的信号，后面每过2s打印一次  
![在这里插入图片描述](E:\MarkDown\picture\b1d78b9df45f44b790a08a188bbb216e.png)

![在这里插入图片描述](E:\MarkDown\picture\79ec4ef0d7694fdf8717f4166ac043f8.png)  
因为SIGKILL是杀死进程，如果被捕捉了进程在一直孕行的过程中都不能杀死进程，如果写了一个这样的病毒危害性是很大的

## 2.24 信号集及相关函数

![在这里插入图片描述](E:\MarkDown\picture\4c6206e1001346da80e67ebceee69426.png)

### 1、sigemptyset

![在这里插入图片描述](E:\MarkDown\picture\faf586d2902e45efbf76001338065c38.png)

### 2、sigfillset

![在这里插入图片描述](E:\MarkDown\picture\a88b51ad71dd47208256785e0be006ad.png)

### 3、sigaddset、sigdelset

![在这里插入图片描述](E:\MarkDown\picture\60df282082c8478fb4dbfbbe2e669826.png)

### 4、sigismember

![在这里插入图片描述](E:\MarkDown\picture\e8e0f7053f364756988de13598a8c81f.png)

## 2.25 sigprocmask

![在这里插入图片描述](E:\MarkDown\picture\45c6ddfb930a428296e5ef3f03f71c5b.png)  
![在这里插入图片描述](E:\MarkDown\picture\6ae1c7033edf41d39a6fd05ba1400e31.png)

![在这里插入图片描述](E:\MarkDown\picture\6955dee096e34fa082f004f45e854002.png)

在控制台输出的时候可以设置前台控制还是后台控制？可以通过&符号来进行控制？

为什么这里设置非阻塞之后就可以结束进程了？  
![在这里插入图片描述](E:\MarkDown\picture\90d3bb6fc11c47ff9175a42c6dfad75a.png)  
![在这里插入图片描述](E:\MarkDown\picture\f68c3e52cc374989b7e21b874145a0fe.png)  
因为只要有信号是阻塞的，循环里面就会一直打印阻塞信号，但是设置了UNBLOCK之后应该是将所有信号都设置为非阻塞的，所以会结束  
![在这里插入图片描述](E:\MarkDown\picture\cb2e33f0e35a427693f45cd3f94c7187.png)

## 2.26 sigaction

![在这里插入图片描述](E:\MarkDown\picture\ce651abbd57a41a1bd6642cc41b482d8.png)

![在这里插入图片描述](E:\MarkDown\picture\b0a852066cbf4c9890502ead0aa64de7.png)  
![在这里插入图片描述](E:\MarkDown\picture\c310e626145d429da2053bbcca4798c7.png)

说明：要避免使用signal，因为不同的机器可能版本不一样

未决信号集和阻塞信号集不能排队，它的标志位只能是0或者1，不能说来了多少个信号就记录多少个数字，所以不能排队

## 2.27 SIGCHLD信号

该信号可用于解决僵尸进程，可以捕捉SIGCHLD信号，捕捉到后父进程再去调用wait或者waitpid函数  
![在这里插入图片描述](E:\MarkDown\picture\c9d1f2e6204f4ba1bd1c7a7553bb11e7.png)

比如要有20个子进程，要回收3个子进程，都是17号，在第一个子进程结束发送SIGCHLD的时候，17号被记为1，其他两个也结束了，但是此时未决信号集只能记录一个，它还是1，所以这些信号被忽略了  
![在这里插入图片描述](E:\MarkDown\picture\c0bd447007374f8b999658d039d1ea78.png)  
处理方法：可以在回调函数里面用一个循环不停去回收，但是这样会死循环，父进程就不能做其他事了  
![在这里插入图片描述](E:\MarkDown\picture\9a44b1c1c3084fe4807035293b318b69.png)  
继续改进：  
waitpid的-1代表回收所有子进程，  
当调用waitpid函数时，它会去搜索是否存在已经终止的子进程，找到了那就处理。这里while循环，如果存在终止子进程，waitpid就一定会去处理。因为ret等于0代表此时并没有终止的子进程，而ret等于-1代表没有子进程。总结，只要存在终止子进程，while就会循环多一次，有多少个就循环多少次。  
![在这里插入图片描述](E:\MarkDown\picture\20b31741d700440b9346435ef9cc1394.png)  
但是也会存在一个问题，多运行几次发生段存储错误  
因为在用sigaction还没注册好时子进程就已经结束了，导致捕捉不到SIGCHLD信号  
![在这里插入图片描述](E:\MarkDown\picture\3ca0cea0627d4a45a49730a6e2c68021.png)  
解决方法：提前设置好阻塞信号集  
![在这里插入图片描述](E:\MarkDown\picture\0428bac658bc4f5da039c96002a867de.png)

![在这里插入图片描述](E:\MarkDown\picture\42018d655a864abf8bbc30fc9f41a4b2.png)

![在这里插入图片描述](E:\MarkDown\picture\5a8580d9e91444f29d2a9cce922cbc81.png)  
所以这样设置阻塞后能够保证信号捕捉注册好以后再进行信号捕捉，即使这时候所有的子进程都已经结束了也能进入回调函数，回收子进程

![在这里插入图片描述](E:\MarkDown\picture\b195131f9dcf469f97b9c3f6e73fcf05.png)  
![在这里插入图片描述](E:\MarkDown\picture\86fe03dd591e4b6b97f5bf429931a26e.png)  
未决信号集对应的位置被设置1，说明发生了该信号但是还没有被处理，如果此时没有捕捉到的话，那么父进程就会忽略此条SIGCHLD信号，但是由于前面将阻塞信号集相应位置设置为了1，所以该信号还不能被处理，只有解除阻塞之后该信号才可以被处理，此时捕捉函数就可以捕捉到SIGCHLD信号

## 2.28 共享内存

### 1、shmgt函数

![在这里插入图片描述](E:\MarkDown\picture\6db2838d863044279f8a6488f757f96d.png)  
![在这里插入图片描述](E:\MarkDown\picture\8247848593324af88404577e97bc52e7.png)

### 2、shmat函数

![在这里插入图片描述](E:\MarkDown\picture\3389bcaaa74a419a882f56364de4294f.png)

### 3、shmdt函数

![在这里插入图片描述](E:\MarkDown\picture\bd780e11e1a74a7eb8f43322e02d2a2a.png)

### 4、shmctl函数

![在这里插入图片描述](E:\MarkDown\picture\df4bda281ce540189ea9036b0d4930d3.png)

![在这里插入图片描述](E:\MarkDown\picture\e17ef5329867410c90cc949b18d2ae57.png)

### 5、ftok函数

![在这里插入图片描述](E:\MarkDown\picture\aa7287dedf1b4c4d87945ba40f9eb2d2.png)

这里的ipcrm第一个用法只是标记删除，实际的连接数还是没变，相当于只是把key给删除？连接数只能程序执行后取消关联才会减少  
![在这里插入图片描述](E:\MarkDown\picture\c039dac6dc7148b9ac632727bd29c763.png)

![在这里插入图片描述](E:\MarkDown\picture\26c055258dac4c7e953d0298bde65a75.png)

——————————————————  
![在这里插入图片描述](E:\MarkDown\picture\6c0c6700230d481cb9d19e97cabe8978.png)  
最后一句话是也不能进行关联

![在这里插入图片描述](E:\MarkDown\picture\0fccf9675a9a402db5ed3b38d4016ad2.png)  
4.数据安全  
![在这里插入图片描述](E:\MarkDown\picture\bf4783d888ee4f4a93e89cb33d0d0a51.png)  
![在这里插入图片描述](E:\MarkDown\picture\dae6154711644daf88ee2f6c0202aea1.png)  
![在这里插入图片描述](E:\MarkDown\picture\39834e7626f44e5bb183049c23086d2c.png)  
![在这里插入图片描述](E:\MarkDown\picture\13978e5a0f8e45d199e9885f2408de1b.png)

## 2.31 守护进程

调用setsid开启新会话是没有控制终端的  
因此内核就不能通过发送一些信号去杀死进程  
![在这里插入图片描述](E:\MarkDown\picture\af99cd81501f445f93dab10c50f09149.png)

对于第一点在子进程中进行操作的原因：  
首先组id和父进程是一样的，如果利用父进程新创建一个会话，那么这个会话的组id也是100，相当于两个会话id一样，有冲突  
![在这里插入图片描述](E:\MarkDown\picture\0f9fa6063d7d4497a3fe0b660d324e9c.png)

关闭文件描述符：为了防止守护进程往终端里面读写数据

第六点重定向后会丢弃设备

守护进程是孤儿进程  
kill是发送信号的shell命令，可以给指定进程发送指定信号。不能被控制终端的Ctrl+C或者Ctrl+\\结束，因为它没有自己的控制终端，是新的会话没有绑定控制终端，但它还是一个进程，可以接收信号。

代码：  
在回调函数里面如果将数据输出到终端里面就不会显示出来，因为这个守护进程的标准输出已经重定向了，但是将数据输出到文件中还是可以输出的

```c
/*
    写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。
*/

#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/time.h>
#include <signal.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>

void work(int num) {
    // 捕捉到信号之后，获取系统时间，写入磁盘文件
    time_t tm = time(NULL);
    struct tm * loc = localtime(&tm);
    // char buf[1024];

    // sprintf(buf, "%d-%d-%d %d:%d:%d\n",loc->tm_year,loc->tm_mon
    // ,loc->tm_mday, loc->tm_hour, loc->tm_min, loc->tm_sec);

    // printf("%s\n", buf);

    char * str = asctime(loc);
    int fd = open("time.txt", O_RDWR | O_CREAT | O_APPEND, 0664);
    write(fd ,str, strlen(str));
    close(fd);
}

int main() {

    // 1.创建子进程，退出父进程
    pid_t pid = fork();

    if(pid > 0) {
        exit(0);
    }

    // 2.将子进程重新创建一个会话
    setsid();

    // 3.设置掩码
    umask(022);

    // 4.更改工作目录
    chdir("/home/nowcoder/");

    // 5. 关闭、重定向文件描述符
    int fd = open("/dev/null", O_RDWR);
    dup2(fd, STDIN_FILENO);
    dup2(fd, STDOUT_FILENO);
    dup2(fd, STDERR_FILENO);

    // 6.业务逻辑

    // 捕捉定时信号
    struct sigaction act;
    act.sa_flags = 0;
    act.sa_handler = work;
    sigemptyset(&act.sa_mask);
    sigaction(SIGALRM, &act, NULL);

    struct itimerval val;
    val.it_value.tv_sec = 2;
    val.it_value.tv_usec = 0;
    val.it_interval.tv_sec = 2;
    val.it_interval.tv_usec = 0;

    // 创建定时器
    setitimer(ITIMER_REAL, &val, NULL);

    // 不让进程结束
    while(1) {
        sleep(10);
    }

    return 0;
}
```

# 第三章 Linux多线程开发

## 3.1 线程概述

如果创建线程的话  
相当于栈空间分成了三份，每一份放一个进程  
text空间也是这样  
其他的区域都是共享的，所以可以节约很多时间，不需要像创建进程那样使用写时复制技术  
![在这里插入图片描述](E:\MarkDown\picture\30ee292d13ce43eeac5c3df8e0d0ecac.png)

## 3.2 创建线程

2进行应该是2进程  
![在这里插入图片描述](E:\MarkDown\picture\ef03241ba226422b85130df29585e812.png)

### pthread\_create函数

![在这里插入图片描述](E:\MarkDown\picture\8e923c0802fb4d4091754b5c0c4ba6b6.png)

![在这里插入图片描述](E:\MarkDown\picture\5f3eccc37aa640d0bfe7435f3a329b04.png)

## 3.3 结束线程

### pthread\_exit函数

![在这里插入图片描述](E:\MarkDown\picture\ca0abd2e8dea4be086f0b81655fe109d.png)

### pthread\_t

![在这里插入图片描述](E:\MarkDown\picture\2b2808d9013247c5a81d49c37fb8f106.png)  
后面的printf不会再执行了  
![在这里插入图片描述](E:\MarkDown\picture\77e00340448d4d5b901d66a08dd581b7.png)

### pthread\_equal

![在这里插入图片描述](E:\MarkDown\picture\3bbd597005ff427591f7eba387538828.png)

## 3.4 连接已结束的线程

### pthread\_join

因为是阻塞的，所以函数会一直等到要回收的线程结束后才会往下执行  
![在这里插入图片描述](E:\MarkDown\picture\ef77e2045a574bd8ab1b8f5ff031d764.png)  
pthread\_exit函数中可以返回一个指针，所以要对这个返回的指针进行操作的话这里的参数列表应该用二级指针

```c
/*
    #include <pthread.h>
    int pthread_join(pthread_t thread, void **retval);
        - 功能：和一个已经终止的线程进行连接
                回收子线程的资源
                这个函数是阻塞函数，调用一次只能回收一个子线程
                一般在主线程中使用
        - 参数：
            - thread：需要回收的子线程的ID
            - retval: 接收子线程退出时的返回值
        - 返回值：
            0 : 成功
            非0 : 失败，返回的错误号
*/

#include <stdio.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>

int value = 10;

void * callback(void * arg) {
    printf("child thread id : %ld\n", pthread_self());
    // sleep(3);
    // return NULL; 
    // int value = 10; // 局部变量
    pthread_exit((void *)&value);   // return (void *)&value;
} 

int main() {

    // 创建一个子线程
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, callback, NULL);

    if(ret != 0) {
        char * errstr = strerror(ret);
        printf("error : %s\n", errstr);
    }

    // 主线程
    for(int i = 0; i < 5; i++) {
        printf("%d\n", i);
    }

    printf("tid : %ld, main thread id : %ld\n", tid ,pthread_self());

    // 主线程调用pthread_join()回收子线程的资源
    int * thread_retval;
    ret = pthread_join(tid, (void **)&thread_retval);

    if(ret != 0) {
        char * errstr = strerror(ret);
        printf("error : %s\n", errstr);
    }

    printf("exit data : %d\n", *thread_retval);

    printf("回收子线程资源成功！\n");

    // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。
    pthread_exit(NULL);

    return 0; 
}

```

## 3.5 线程的分离

### pthread\_detach

![在这里插入图片描述](E:\MarkDown\picture\25e6eb6d7e524f23ab66734c6a596342.png)

## 3.6 线程取消

### pthread\_cancel

![在这里插入图片描述](E:\MarkDown\picture\53e054cfde20432a8b2a096c8cf178f3.png)

![在这里插入图片描述](E:\MarkDown\picture\e41776efadc0419183c5e99073a76440.png)

## 3.7线程属性

### pthread\_attr\_init\\pthread\_attr\_destroy\\pthread\_attr\_getdetachstate\\pthread\_attr\_setdetachstate

```c
/*
    int pthread_attr_init(pthread_attr_t *attr);
        - 初始化线程属性变量

    int pthread_attr_destroy(pthread_attr_t *attr);
        - 释放线程属性的资源

    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
        - 获取线程分离的状态属性

    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
        - 设置线程分离的状态属性
*/     

```

## 3.9 互斥锁

### pthread\_mutex\_init

限制下面的举例表示不可以用另一个指针来操作这个互斥锁  
![在这里插入图片描述](E:\MarkDown\picture\66bd6a5c7a9d4c45a230a7b3c8a7edf3.png)

### pthread\_mutex\_destroy

### pthread\_mutex\_lock

### pthread\_mutex\_trylock

### pthread\_mutex\_unlock

```cpp
/*
    互斥量的类型 pthread_mutex_t
    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
        - 初始化互斥量
        - 参数 ：
            - mutex ： 需要初始化的互斥量变量
            - attr ： 互斥量相关的属性，NULL
        - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。
            pthread_mutex_t *restrict mutex = xxx;
            pthread_mutex_t * mutex1 = mutex;

    int pthread_mutex_destroy(pthread_mutex_t *mutex);
        - 释放互斥量的资源

    int pthread_mutex_lock(pthread_mutex_t *mutex);
        - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待

    int pthread_mutex_trylock(pthread_mutex_t *mutex);
        - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。

    int pthread_mutex_unlock(pthread_mutex_t *mutex);
        - 解锁
*/
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

// 全局变量，所有的线程都共享这一份资源。
int tickets = 1000;

// 创建一个互斥量
pthread_mutex_t mutex;

void * sellticket(void * arg) {

    // 卖票
    while(1) {

        // 加锁
        pthread_mutex_lock(&mutex);

        if(tickets > 0) {
            usleep(6000);
            printf("%ld 正在卖第 %d 张门票\n", pthread_self(), tickets);
            tickets--;
        }else {
            // 解锁
            pthread_mutex_unlock(&mutex);
            break;
        }

        // 解锁
        pthread_mutex_unlock(&mutex);
    }

    

    return NULL;
}

int main() {

    // 初始化互斥量
    pthread_mutex_init(&mutex, NULL);

    // 创建3个子线程
    pthread_t tid1, tid2, tid3;
    pthread_create(&tid1, NULL, sellticket, NULL);
    pthread_create(&tid2, NULL, sellticket, NULL);
    pthread_create(&tid3, NULL, sellticket, NULL);

    // 回收子线程的资源,阻塞
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);

    pthread_exit(NULL); // 退出主线程
    
    // 释放互斥量资源
    pthread_mutex_destroy(&mutex); //放到最后是为了不让它这么快被释放，其实这句代码不会被实现？


    return 0;
}
```

## 3.13 条件变量

当缓冲区为空，不用条件变量时，消费者处于无意义的循环，此时只执行加锁和解锁，直到时间片完才发生线程切换，浪费cpu资源。而加入条件变量，一旦发现缓存区是空的，会立刻从运行态进入阻塞态，此时一定会发生线程切换，把cpu资源让出。互斥锁和条件变量都可以实现线程同步，但使用条件变量效率更高。

```c
/*
    条件变量的 类型 pthread_cond_t
    int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);
    int pthread_cond_destroy(pthread_cond_t *cond);
    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
        - 等待，调用了该函数，线程会阻塞。
    int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);
        - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。
    int pthread_cond_signal(pthread_cond_t *cond);
        - 唤醒一个或者多个等待的线程
    int pthread_cond_broadcast(pthread_cond_t *cond);
        - 唤醒所有的等待的线程
*/
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

// 创建一个互斥量
pthread_mutex_t mutex;
// 创建条件变量
pthread_cond_t cond;

struct Node{
    int num;
    struct Node *next;
};

// 头结点
struct Node * head = NULL;

void * producer(void * arg) {

    // 不断的创建新的节点，添加到链表中
    while(1) {
        pthread_mutex_lock(&mutex); //加互斥锁
        struct Node * newNode = (struct Node *)malloc(sizeof(struct Node));
        newNode->next = head;
        head = newNode;
        newNode->num = rand() % 1000;
        printf("add node, num : %d, tid : %ld\n", newNode->num, pthread_self());
        
        // 只要生产了一个，就通知消费者消费
        pthread_cond_signal(&cond);

        pthread_mutex_unlock(&mutex);
        usleep(100);
    }

    return NULL;
}

void * customer(void * arg) {

    while(1) {
        pthread_mutex_lock(&mutex);
        // 保存头结点的指针
        struct Node * tmp = head;
        // 判断是否有数据
        if(head != NULL) {
            // 有数据
            head = head->next;
            printf("del node, num : %d, tid : %ld\n", tmp->num, pthread_self());
            free(tmp);
            pthread_mutex_unlock(&mutex);
            usleep(100);
        } else {
            // 没有数据，需要等待
            // 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。
            pthread_cond_wait(&cond, &mutex);
            pthread_mutex_unlock(&mutex);
        }
    }
    return  NULL;
}

int main() {

    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);

    // 创建5个生产者线程，和5个消费者线程
    pthread_t ptids[5], ctids[5];

    for(int i = 0; i < 5; i++) {
        pthread_create(&ptids[i], NULL, producer, NULL);
        pthread_create(&ctids[i], NULL, customer, NULL);
    }

    for(int i = 0; i < 5; i++) {
        pthread_detach(ptids[i]);
        pthread_detach(ctids[i]);
    }

    while(1) {
        sleep(10);
    }

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);

    pthread_exit(NULL);

    return 0;
}

```

## 3.14 信号量

```c
/*
    信号量的类型 sem_t
    int sem_init(sem_t *sem, int pshared, unsigned int value);
        - 初始化信号量
        - 参数：
            - sem : 信号量变量的地址
            - pshared : 0 用在线程间 ，非0 用在进程间
            - value : 信号量中的值

    int sem_destroy(sem_t *sem);
        - 释放资源

    int sem_wait(sem_t *sem);
        - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞

    int sem_trywait(sem_t *sem);

    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
    int sem_post(sem_t *sem);
        - 对信号量解锁，调用一次对信号量的值+1

    int sem_getvalue(sem_t *sem, int *sval);

    sem_t psem; //生产者消费变量
    sem_t csem; //消费者信号变量
    init(psem, 0, 8);
    init(csem, 0, 0);

    producer() {
        sem_wait(&psem);
        sem_post(&csem)
    }

    customer() {
        sem_wait(&csem);
        sem_post(&psem)
    }

*/

#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <semaphore.h>

// 创建一个互斥量
pthread_mutex_t mutex;
// 创建两个信号量
sem_t psem;
sem_t csem;

struct Node{
    int num;
    struct Node *next;
};

// 头结点
struct Node * head = NULL;

void * producer(void * arg) {

    // 不断的创建新的节点，添加到链表中
    while(1) {
        sem_wait(&psem);
        pthread_mutex_lock(&mutex);
        struct Node * newNode = (struct Node *)malloc(sizeof(struct Node));
        newNode->next = head;
        head = newNode;
        newNode->num = rand() % 1000;
        printf("add node, num : %d, tid : %ld\n", newNode->num, pthread_self());
        pthread_mutex_unlock(&mutex);
        sem_post(&csem);//告诉消费者有一个空位可以进行消费了
    }

    return NULL;
}

void * customer(void * arg) {

    while(1) {
        sem_wait(&csem);
        pthread_mutex_lock(&mutex);
        // 保存头结点的指针
        struct Node * tmp = head;
        head = head->next;
        printf("del node, num : %d, tid : %ld\n", tmp->num, pthread_self());
        free(tmp);
        pthread_mutex_unlock(&mutex);
        sem_post(&psem); //告诉生产者有一个空位可以进行生产了
       
    }
    return  NULL;
}

int main() {

    pthread_mutex_init(&mutex, NULL);
    sem_init(&psem, 0, 8);
    sem_init(&csem, 0, 0);

    // 创建5个生产者线程，和5个消费者线程
    pthread_t ptids[5], ctids[5];

    for(int i = 0; i < 5; i++) {
        pthread_create(&ptids[i], NULL, producer, NULL);
        pthread_create(&ctids[i], NULL, customer, NULL);
    }

    for(int i = 0; i < 5; i++) {
        pthread_detach(ptids[i]);
        pthread_detach(ctids[i]);
    }

    while(1) {
        sleep(10);
    }

    pthread_mutex_destroy(&mutex);

    pthread_exit(NULL);

    return 0;
}

```

# 第四章 linux网络编程

## 4.12 IP地址转换

把int类型中的四个字节分别传给char类型指针  
将点分十进制的IP地址转换成网络字节序的整数  
![在这里插入图片描述](E:\MarkDown\picture\09f165ff86fb48b8aa966f5fe71a5acb.png)

输出如下：  
因为转换成网络字节序是大端序，高地址存放低字节数，p是地址，p+3是高地址  
![在这里插入图片描述](E:\MarkDown\picture\01f0a837cb55402e90fefdde3e3f10ef.png)

![在这里插入图片描述](E:\MarkDown\picture\8a1b4e9910ee4f09883840c815537cc3.png)  
printf (“%s”,str ); / / 从首地址str一直输出，一直到 \\0结束，没有\\0就会越界。

![在这里插入图片描述](E:\MarkDown\picture\023e90b326d14ffe8d0185348781dab3.png)

## 4.17 TCP三次握手

![在这里插入图片描述](E:\MarkDown\picture\89911ae2df234afd970cd2bd5545d2fd.png)

## 4.19 TCP四次挥手

![在这里插入图片描述](E:\MarkDown\picture\a3730e6f6e2b4355b8e3ddb43d25a962.png)

![在这里插入图片描述](E:\MarkDown\picture\07ab9ef90b1248c3b602349ebe7f2fd8.png)

## 4.20 多进程实现并发服务器1

![在这里插入图片描述](E:\MarkDown\picture\07f74087701b468d96572a2a8869f4ed.png)

## 4.21 多进程实现并发服务器2

服务器在发送的时候并没有发送\\n 
所以在发送数据的时候，在strlen后面加1，把\\n发送过去。或者可以初始化char数组的时候放一个0值，但是初始化会产生一个问题，如果两次发送的数据长度不一样，比如第二次发送的数据比第一次发送的短，那么char数组的后面一部分就不会被覆盖，发送过去的数据是会存在问题的 
![在这里插入图片描述](E:\MarkDown\picture\26493dcba836412a9ea9bb69d8cbb859.png)

服务器的accept在捕获到sigchld信号之后产生软中断，会导致这个accept函数产生一个错误，并且不阻塞，所以会执行下面if里面的代码  
![在这里插入图片描述](E:\MarkDown\picture\2f3225333f15421fabaed39228dc096f.png)  
解决办法：  
![在这里插入图片描述](E:\MarkDown\picture\2e91ebcb2e48411e9b6f1ca861829e50.png)

## 4.22 多线程实现并发服务器

在创建结构体保存要传入子线程的参数时，这是一个局部变量，当下一次while循环时，它就消失了，所以可以使用malloc将其创建在堆中，但是在子线程中还需要释放掉。但是这样做资源消耗是非常大的，当来了很多个子线程时，要申请很多个堆区内存  
![在这里插入图片描述](E:\MarkDown\picture\4dbf597ae2904895bf2d330ac97046bc.png)  
解决办法：创建一个结构体数组sockinfos，然后在main函数里面对结构体数组进行初始化，文件描述符需要初始化为-1，代表这是可用的结构体，在创建子线程之前先判断哪一个结构体是可用的，如果128个客户端都被用了，则睡眠、i-1，直到有可用的文件描述符

```c
#include <stdio.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

struct sockInfo {
    int fd; // 通信的文件描述符
    struct sockaddr_in addr;
    pthread_t tid;  // 线程号
};

struct sockInfo sockinfos[128]; //最多允许128个客户端进行连接

void * working(void * arg) {
    // 子线程和客户端通信   cfd 客户端的信息 线程号
    // 获取客户端的信息
    struct sockInfo * pinfo = (struct sockInfo *)arg;

    char cliIp[16];
    inet_ntop(AF_INET, &pinfo->addr.sin_addr.s_addr, cliIp, sizeof(cliIp));
    unsigned short cliPort = ntohs(pinfo->addr.sin_port);
    printf("client ip is : %s, prot is %d\n", cliIp, cliPort);

    // 接收客户端发来的数据
    char recvBuf[1024];
    while(1) {
        int len = read(pinfo->fd, &recvBuf, sizeof(recvBuf));

        if(len == -1) {
            perror("read");
            exit(-1);
        }else if(len > 0) {
            printf("recv client : %s\n", recvBuf);
        } else if(len == 0) {
            printf("client closed....\n");
            break;
        }
        write(pinfo->fd, recvBuf, strlen(recvBuf) + 1);
    }
    close(pinfo->fd);
    return NULL;
}

int main() {

    // 创建socket
    int lfd = socket(PF_INET, SOCK_STREAM, 0);
    if(lfd == -1){
        perror("socket");
        exit(-1);
    }

    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(9999);
    saddr.sin_addr.s_addr = INADDR_ANY;

    // 绑定
    int ret = bind(lfd,(struct sockaddr *)&saddr, sizeof(saddr));
    if(ret == -1) {
        perror("bind");
        exit(-1);
    }

    // 监听
    ret = listen(lfd, 128);
    if(ret == -1) {
        perror("listen");
        exit(-1);
    }

    // 初始化数据
    int max = sizeof(sockinfos) / sizeof(sockinfos[0]);
    for(int i = 0; i < max; i++) {
        bzero(&sockinfos[i], sizeof(sockinfos[i]));
        sockinfos[i].fd = -1;
        sockinfos[i].tid = -1;
    }

    // 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信
    while(1) {

        struct sockaddr_in cliaddr;
        int len = sizeof(cliaddr);
        // 接受连接
        int cfd = accept(lfd, (struct sockaddr*)&cliaddr, &len);

        struct sockInfo * pinfo;
        for(int i = 0; i < max; i++) {
            // 从这个数组中找到一个可以用的sockInfo元素
            if(sockinfos[i].fd == -1) {
                pinfo = &sockinfos[i];
                break;
            }
            if(i == max - 1) {
                sleep(1);
                i--;
            }
        }

        pinfo->fd = cfd;
        memcpy(&pinfo->addr, &cliaddr, len);

        // 创建子线程
        pthread_create(&pinfo->tid, NULL, working, pinfo);

        pthread_detach(pinfo->tid); //注意这里不能用join，因为join是阻塞的
    }

    close(lfd);
    return 0;
}

```

## 4.25 IO多路复用

IO指的是文件和内存之间进行写入和读出  
![在这里插入图片描述](E:\MarkDown\picture\7048ea138b644be2a520aa7e3fd44614.png)  
这里的IO是指对缓冲区的操作  
![在这里插入图片描述](E:\MarkDown\picture\80472c9d6a1f4065bbe47b487b62a13e.png)

## 4.27 select

select每次调用的时候都需要重新设置  
在while循环里面调用的其实是副本，因为内核处理过后可能会把本来是1的位置设置为0，但其实这些位还是需要检查的  
![在这里插入图片描述](E:\MarkDown\picture\3cd4aff85fbd45029d087a6b21e581c6.png)

## 4.28 poll

poll里面使用了结构体，内核每次修改的其实是结构体的revents，不会修改fd，这样就会比select好  
不过poll还是需要从内核态转到用户态，用户态转到内核态，并且进行循环遍历  
![](E:\MarkDown\picture\e06821561063441f99c2eccdef94d867.png)  
这里就是既检测读又检测写  
![在这里插入图片描述](E:\MarkDown\picture\e1c06be4079b48eb89bebb7436302967.png)

poll相当于把select的第三点和第四个缺点给去掉了  
![在这里插入图片描述](E:\MarkDown\picture\9c6f8fa5b1fa4881b03b8d22ad2e1935.png)

————————————————————————  
注意结构体0号是存放了监听文件描述符，所以后面的循环都是从1号开始循环的

```c
#include <stdio.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <poll.h>


int main() {

    // 创建socket
    int lfd = socket(PF_INET, SOCK_STREAM, 0);
    struct sockaddr_in saddr;
    saddr.sin_port = htons(9999);
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;

    // 绑定
    bind(lfd, (struct sockaddr *)&saddr, sizeof(saddr));

    // 监听
    listen(lfd, 8);

    // 初始化检测的文件描述符数组
    struct pollfd fds[1024];
    for(int i = 0; i < 1024; i++) {
        fds[i].fd = -1;
        fds[i].events = POLLIN;
    }
    fds[0].fd = lfd;//监听文件描述符
    int nfds = 0;

    while(1) {

        // 调用poll系统函数，让内核帮检测哪些文件描述符有数据
        int ret = poll(fds, nfds + 1, -1);
        if(ret == -1) {
            perror("poll");
            exit(-1);
        } else if(ret == 0) {
            continue;
        } else if(ret > 0) {
            // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变
            if(fds[0].revents & POLLIN) {//这里是fds[0]
                // 表示有新的客户端连接进来了
                struct sockaddr_in cliaddr;
                int len = sizeof(cliaddr);
                int cfd = accept(lfd, (struct sockaddr *)&cliaddr, &len);

                // 将新的文件描述符加入到集合中
                for(int i = 1; i < 1024; i++) {
                    if(fds[i].fd == -1) {
                        fds[i].fd = cfd;
                        fds[i].events = POLLIN;
                        break;
                    }
                }

                // 更新最大的文件描述符的索引
                nfds = nfds > cfd ? nfds : cfd;
            }

            for(int i = 1; i <= nfds; i++) {
                if(fds[i].revents & POLLIN) {
                    // 说明这个文件描述符对应的客户端发来了数据
                    char buf[1024] = {0};
                    int len = read(fds[i].fd, buf, sizeof(buf));
                    if(len == -1) {
                        perror("read");
                        exit(-1);
                    } else if(len == 0) {
                        printf("client closed...\n");
                        close(fds[i].fd);
                        fds[i].fd = -1;
                    } else if(len > 0) {
                        printf("read buf = %s\n", buf);
                        write(fds[i].fd, buf, strlen(buf) + 1);
                    }
                }
            }

        }

    }
    close(lfd);
    return 0;
}


```

## 4.30 epoll代码编写

```c
#include <stdio.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>

int main() {

    // 创建socket
    int lfd = socket(PF_INET, SOCK_STREAM, 0);
    struct sockaddr_in saddr;
    saddr.sin_port = htons(9999);
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;

    // 绑定
    bind(lfd, (struct sockaddr *)&saddr, sizeof(saddr));

    // 监听
    listen(lfd, 8);

    // 调用epoll_create()创建一个epoll实例
    int epfd = epoll_create(100);

    // 将监听的文件描述符相关的检测信息添加到epoll实例中
    struct epoll_event epev;
    epev.events = EPOLLIN;
    epev.data.fd = lfd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &epev);

    struct epoll_event epevs[1024];

    while(1) {

        int ret = epoll_wait(epfd, epevs, 1024, -1);
        if(ret == -1) {
            perror("epoll_wait");
            exit(-1);
        }

        printf("ret = %d\n", ret);

        for(int i = 0; i < ret; i++) {

            int curfd = epevs[i].data.fd;

            if(curfd == lfd) {
                // 监听的文件描述符有数据达到，有客户端连接
                struct sockaddr_in cliaddr;
                int len = sizeof(cliaddr);
                int cfd = accept(lfd, (struct sockaddr *)&cliaddr, &len);

                epev.events = EPOLLIN;
                epev.data.fd = cfd;
                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &epev);
            } else {
                if(epevs[i].events & EPOLLOUT) {//如果在前面添加了很多事件时一定要在后面记得判断一下
                    continue;
                }   
                // 有数据到达，需要通信
                char buf[1024] = {0};
                int len = read(curfd, buf, sizeof(buf));
                if(len == -1) {
                    perror("read");
                    exit(-1);
                } else if(len == 0) {
                    printf("client closed...\n");
                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL);
                    close(curfd);
                } else if(len > 0) {
                    printf("read buf = %s\n", buf);
                    write(curfd, buf, strlen(buf) + 1);
                }

            }

        }
    }

    close(lfd);
    close(epfd);
    return 0;
}
```

## 4.31 epoll的两种工作模式

注意：EAGAIN只有设置为非阻塞的情况下才会产生  
Linux下EAGAIN宏的含义：  
从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。例如，以O\_NONBLOCK的标志打开file/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。

又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。

ET模式下的代码  
epoll\_et.c

```c
#include <stdio.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <fcntl.h>
#include <errno.h>

int main() {

    // 创建socket
    int lfd = socket(PF_INET, SOCK_STREAM, 0);
    struct sockaddr_in saddr;
    saddr.sin_port = htons(9999);
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;

    // 绑定
    bind(lfd, (struct sockaddr *)&saddr, sizeof(saddr));

    // 监听
    listen(lfd, 8);

    // 调用epoll_create()创建一个epoll实例
    int epfd = epoll_create(100);

    // 将监听的文件描述符相关的检测信息添加到epoll实例中
    struct epoll_event epev;
    epev.events = EPOLLIN;
    epev.data.fd = lfd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &epev);

    struct epoll_event epevs[1024];

    while(1) {

        int ret = epoll_wait(epfd, epevs, 1024, -1);
        if(ret == -1) {
            perror("epoll_wait");
            exit(-1);
        }

        printf("ret = %d\n", ret);

        for(int i = 0; i < ret; i++) {

            int curfd = epevs[i].data.fd;

            if(curfd == lfd) {
                // 监听的文件描述符有数据达到，有客户端连接
                struct sockaddr_in cliaddr;
                int len = sizeof(cliaddr);
                int cfd = accept(lfd, (struct sockaddr *)&cliaddr, &len);

                // 设置cfd属性非阻塞
                int flag = fcntl(cfd, F_GETFL);//获取cfd的属性
                flag |= O_NONBLOCK; //将flag设为非阻塞
                fcntl(cfd, F_SETFL, flag); //将cfd设为非阻塞

                epev.events = EPOLLIN | EPOLLET;    // 设置边沿触发
                epev.data.fd = cfd;
                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &epev);
            } else {
                if(epevs[i].events & EPOLLOUT) {
                    continue;
                }  

                // 循环读取出所有数据
                char buf[5];
                int len = 0;
                while( (len = read(curfd, buf, sizeof(buf))) > 0) {
                    // 打印数据
                    // printf("recv data : %s\n", buf);//printf是行缓冲，要加换行，或者缓冲区满了才刷新缓冲区
                    write(STDOUT_FILENO, buf, len);
                    write(curfd, buf, len);
                }
                if(len == 0) {
                    printf("client closed....");
                }else if(len == -1) {
                    if(errno == EAGAIN) {
                        //表示数据已经读完了，此时不退出
                        printf("data over.....");
                    }else {
                        perror("read");
                        exit(-1);
                    }
                    
                }

            }

        }
    }

    close(lfd);
    close(epfd);
    return 0;
}
```





# 代码

httpconn.cpp

```cpp
#include "httpconn.h"

// 定义HTTP响应的一些状态信息
const char* ok_200_title = "OK";
const char* error_400_title = "Bad Request";
const char* error_400_form = "Your request has bad syntax or is inherently impossible to satisfy.\n";
const char* error_403_title = "Forbidden";
const char* error_403_form = "You do not have permission to get file from this server.\n";
const char* error_404_title = "Not Found";
const char* error_404_form = "The requested file was not found on this server.\n";
const char* error_500_title = "Internal Error";
const char* error_500_form = "There was an unusual problem serving the requested file.\n";

// 网站的根目录
const char* doc_root = "/root/linux/webserver/resources";
extern int setnonblocking( int fd );

// 向epoll中添加需要监听的文件描述符
void addfd(int epollfd, int fd, bool one_shot) {
    epoll_event event;
    event.data.fd = fd;
    event.events = EPOLLIN | EPOLLRDHUP; // 默认是水平触发，也可以设置EPOLLET是边沿触发。EPOLLRDHUP是在异常断开时可以进行处理，不用移交给上层
    // epoll中的EPOLLONESHOT时间可以使得一个socket连接在任一时刻都只被一个线程处理
    if(one_shot) 
    {
        // 防止同一个通信被不同的线程处理
        event.events |= EPOLLONESHOT;
    }
    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event); // 添加fd文件描述符
    // 设置文件描述符非阻塞，因为是ET模式需要非阻塞
    setnonblocking(fd);
}

// 从epoll中移除监听的文件描述符
void removefd(int epollfd, int fd) {
    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0);
    close(fd);
}

// 修改文件描述符，重置socket上的EPOLLONESHOT事件，以确保下一次可读时，EPOLLIN事件能被触发
void modfd(int epollfd, int fd, int ev) {
    epoll_event event;
    event.data.fd = fd;
    event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP; // 修改时别忘了加上之前设置的那几个
    epoll_ctl( epollfd, EPOLL_CTL_MOD, fd, &event );
}


// 所有的客户数
int http_conn::m_user_count = 0;
// 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的
int http_conn::m_epollfd = -1;

// 关闭连接
void http_conn::close_conn() {
    if(m_sockfd != -1) {
        removefd(m_epollfd, m_sockfd);
        m_sockfd = -1;
        m_user_count--; // 关闭一个连接，将客户总数量-1
    }
}

// 初始化连接,外部调用初始化套接字地址
void http_conn::init(int sockfd, const sockaddr_in& addr){
    m_sockfd = sockfd;
    m_address = addr;
    // 端口复用
    int reuse = 1;
    setsockopt( m_sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof( reuse ) );
    // 添加到epoll对象中
    addfd(m_epollfd, sockfd, true);
    m_user_count++;//总用户数加一
    
    init();
}


void http_conn::init()
{
    m_check_state = CHECK_STATE_REQUESTLINE;    // 初始状态为检查请求行
    m_linger = false;       // 默认不保持链接  Connection : keep-alive保持连接

    m_method = GET;         // 默认请求方式为GET
    m_url = 0;              
    m_version = 0;
    m_content_length = 0;
    m_host = 0;
    m_start_line = 0;  // 当前正在解析的行的起始位置
    m_checked_idx = 0;  // 当前正在分析的字符在读缓冲区中的位置
    m_read_idx = 0;
    m_write_idx = 0;
    bzero(m_read_buf, READ_BUFFER_SIZE);  // 将读写缓冲区置为空
    bzero(m_write_buf, READ_BUFFER_SIZE);
    bzero(m_real_file, FILENAME_LEN);
}

// 循环读取客户数据，直到无数据可读或者对方关闭连接
bool http_conn::read() {
    if( m_read_idx >= READ_BUFFER_SIZE ) {//超过数组最大值
        return false;
    }
    int bytes_read = 0;//已经读取到的字节
    while(true) {
        // 从m_read_buf + m_read_idx索引出开始保存数据，大小是READ_BUFFER_SIZE - m_read_idx
        bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, 0 );
        if (bytes_read == -1) {
            if( errno == EAGAIN || errno == EWOULDBLOCK ) {
                // 没有数据
                break;
            }
            return false;   
        } else if (bytes_read == 0) {   // 对方关闭连接
            return false;
        }
        m_read_idx += bytes_read;
    }
    return true;
}

// 解析一行，判断依据\r\n
http_conn::LINE_STATUS http_conn::parse_line() {
    char temp;
    for ( ; m_checked_idx < m_read_idx; ++m_checked_idx ) {  // 遍历一行数据
        temp = m_read_buf[ m_checked_idx ];  // 从第0个开始解析
        if ( temp == '\r' ) {
            if ( ( m_checked_idx + 1 ) == m_read_idx ) { // 读到的这一个+1刚好是下一次的索引？
                // 不完整认为有问题
                return LINE_OPEN;
            } else if ( m_read_buf[ m_checked_idx + 1 ] == '\n' ) {  // 完整解析到了一行
                // 把\r\n都变成\0  
                // 表示字符串结束
                m_read_buf[ m_checked_idx++ ] = '\0';
                m_read_buf[ m_checked_idx++ ] = '\0';
                return LINE_OK;
            }
            return LINE_BAD;
        } else if( temp == '\n' )  {
            //读到\n检查前面是不是\r，应该是为了保证\r\n连着吧，
            //不符合这个格式直接就返回解析错误，
            //比如第一次收到是 abcd，第二次收到\n，不满足，返回解析错误
            if( ( m_checked_idx > 1) && ( m_read_buf[ m_checked_idx - 1 ] == '\r' ) ) {  // 就比如两次读到的是分开的，上次读是aaa\r，这次读到的是\n
                //如果1索引为\n，就算0索引为\r，组合成一个换行，
                //那这个换行前面也没有任何数据。所以m_checked_idx 至少从2索引开始
                m_read_buf[ m_checked_idx-1 ] = '\0';
                m_read_buf[ m_checked_idx++ ] = '\0';
                return LINE_OK;
            }
            return LINE_BAD;
        }
    }
    return LINE_OPEN;
}

// 解析HTTP请求行，获得请求方法，目标URL,以及HTTP版本号
http_conn::HTTP_CODE http_conn::parse_request_line(char* text) {
    // GET /index.html HTTP/1.1
    // \t的空格数量并不是随机的，而是每8个字符串自动补齐
    // m_url为指向\t的指针
    // strpbrk检索字符串 str1 中第一个匹配字符串 str2 中字符的字符
    m_url = strpbrk(text, " \t"); // 判断第二个参数中的" "和"\t"两个字符哪个在text中最先出现
    if (!m_url) { 
        return BAD_REQUEST;
    }
    // GET\0/index.html HTTP/1.1
    *m_url++ = '\0';    // 置位空字符，字符串结束符
    char* method = text;//实际上得到的是GET  char只有八位
    if ( strcasecmp(method, "GET") == 0 ) { // 忽略大小写比较
        m_method = GET;
    } else {
        return BAD_REQUEST;
    }
    // m_url是这段内容：/index.html HTTP/1.1
    // 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。
    //strpbrk输出的是一个char* 指针
    m_version = strpbrk( m_url, " \t" );//
    if (!m_version) {
        return BAD_REQUEST;
    }
    *m_version++ = '\0';//++后m_version实际上是指向"HTTP/1.1"的指针
    if (strcasecmp( m_version, "HTTP/1.1") != 0 ) {
        return BAD_REQUEST;
    }
    /**
     * 因为有的请求是http://192.168.110.129:10000/index.html这种形式
    */
    if (strncasecmp(m_url, "http://", 7) == 0 ) {  // 判断前七个字符与"http://"中是否相同
        m_url += 7;  // 192.168.110.129:10000/index.html
        // 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。
        m_url = strchr( m_url, '/' );  // 找第一次出现'/'的地方   /index.html
    }
    if ( !m_url || m_url[0] != '/' ) {
        return BAD_REQUEST;
    }
    m_check_state = CHECK_STATE_HEADER; // 主状态机检查状态变成检查请求头
    return NO_REQUEST;
}

// 解析HTTP请求的一个头部信息
http_conn::HTTP_CODE http_conn::parse_headers(char* text) {   
    // 遇到空行，表示头部字段解析完毕
    if( text[0] == '\0' ) {
        // 如果HTTP请求有消息体，则还需要读取m_content_length字节的消息体，如果这个值不为0，则说明有消息体
        // 状态机转移到CHECK_STATE_CONTENT状态
        if ( m_content_length != 0 ) {
            m_check_state = CHECK_STATE_CONTENT;
            return NO_REQUEST;
        }
        // 否则说明我们已经得到了一个完整的HTTP请求
        return GET_REQUEST;
    } else if ( strncasecmp( text, "Connection:", 11 ) == 0 ) {
        // 处理Connection 头部字段  Connection: keep-alive
        text += 11;
        text += strspn( text, " \t" );
        if ( strcasecmp( text, "keep-alive" ) == 0 ) {
            m_linger = true;
        }
    } else if ( strncasecmp( text, "Content-Length:", 15 ) == 0 ) {
        // 处理Content-Length头部字段
        text += 15;
        text += strspn( text, " \t" );
        m_content_length = atol(text);
    } else if ( strncasecmp( text, "Host:", 5 ) == 0 ) {
        // 处理Host头部字段
        text += 5;
        text += strspn( text, " \t" );
        m_host = text;
    } else {
        printf( "oop! unknow header %s\n", text );
    }
    return NO_REQUEST;
}

// 我们没有真正解析HTTP请求的消息体，只是判断它是否被完整的读入了
http_conn::HTTP_CODE http_conn::parse_content( char* text ) {
    if ( m_read_idx >= ( m_content_length + m_checked_idx ) )
    {
        text[ m_content_length ] = '\0';
        return GET_REQUEST;
    }
    return NO_REQUEST;
}

// 主状态机，解析请求，根据是当前正在分析请求行、当前正在分析头部字段、当前正在解析请求体分别进行处理
http_conn::HTTP_CODE http_conn::process_read() {
    LINE_STATUS line_status = LINE_OK;
    // 服务器处理HTTP请求的可能结果
    HTTP_CODE ret = NO_REQUEST;
    char* text = 0;
    while (((m_check_state == CHECK_STATE_CONTENT) && (line_status == LINE_OK))  // 主状态机是解析请求体，且是完整的数据
                || ((line_status = parse_line()) == LINE_OK)) {  // 解析到了一行完整的数据

        text = get_line();  // 获取一行完整的数据
        m_start_line = m_checked_idx;  // 等于检测到的数据
        printf( "got 1 http line: %s\n", text );

        switch ( m_check_state ) {
            case CHECK_STATE_REQUESTLINE: {  // 当前正在分析请求行
                ret = parse_request_line( text );  // 解析HTTP请求行，获得请求方法，目标URL,以及HTTP版本号
                if ( ret == BAD_REQUEST ) {
                    return BAD_REQUEST;
                }
                break;//如果能正常解析就break
            }
            case CHECK_STATE_HEADER: {  // 解析请求头
                ret = parse_headers( text );  
                if ( ret == BAD_REQUEST ) {
                    return BAD_REQUEST;
                } else if ( ret == GET_REQUEST ) {
                    return do_request();  // 解析具体的内容
                }
                break;
            }
            case CHECK_STATE_CONTENT: {//解析请求体
                ret = parse_content( text );
                if ( ret == GET_REQUEST ) {  // 如果获得了一个完整的客户请求
                    return do_request();//把请求的资源解析出来
                }
                // 如果失败了，改变状态为行数据尚且不完整
                line_status = LINE_OPEN;
                break;
            }
            default: {
                return INTERNAL_ERROR;  // 内部错误
            }
        }
    }
    return NO_REQUEST;  // 主状态
}
// http://139.224.239.211:43421/index.html
// 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，
// 如果目标文件存在、对所有用户可读，且不是目录，则使用mmap将其
// 映射到内存地址m_file_address处，并告诉调用者获取文件成功
http_conn::HTTP_CODE http_conn::do_request() {
    // doc_root是我们资源的路径："/root/linux/webserver/resources"
    strcpy( m_real_file, doc_root );
    int len = strlen( doc_root );
    strncpy( m_real_file + len, m_url, FILENAME_LEN - len - 1 ); //将资源路径和之前得到的index.html文件名拼接到一起
    // 获取m_real_file文件的相关的状态信息，-1失败，0成功
    if ( stat( m_real_file, &m_file_stat ) < 0 ) {
        return NO_RESOURCE;
    }

    // 判断访问权限
    if ( ! ( m_file_stat.st_mode & S_IROTH ) ) {
        return FORBIDDEN_REQUEST;
    }

    // 判断是否是目录
    if ( S_ISDIR( m_file_stat.st_mode ) ) {
        return BAD_REQUEST;
    }

    // 以只读方式打开文件
    int fd = open( m_real_file, O_RDONLY );
    // 创建内存映射
    //把网页的数据映射到这个地址上
    m_file_address = ( char* )mmap( 0, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0 );
    close( fd );
    return FILE_REQUEST;
}

// 对内存映射区执行munmap操作，释放资源
void http_conn::unmap() {
    if(m_file_address) {
        munmap( m_file_address, m_file_stat.st_size ); //释放资源
        m_file_address = 0;
    }
}

// 写HTTP响应
bool http_conn::write()
{
    int temp = 0;
    int bytes_have_send = 0;    // 已经发送的字节
    int bytes_to_send = m_write_idx;// 将要发送的字节 （m_write_idx）写缓冲区中待发送的字节数
    
    if ( bytes_to_send == 0 ) {
        // 将要发送的字节为0，这一次响应结束。
        modfd( m_epollfd, m_sockfd, EPOLLIN ); 
        init();
        return true;
    }

    while(1) {
        // 分散写  有多块不是连续的内存，把多块内存的数据都写出去
        temp = writev(m_sockfd, m_iv, m_iv_count);
        if ( temp <= -1 ) {
            // 如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件，虽然在此期间，
            // 服务器无法立即接收到同一客户的下一个请求，但可以保证连接的完整性。
            if( errno == EAGAIN ) {
                modfd( m_epollfd, m_sockfd, EPOLLOUT );
                return true;
            }
            unmap();//释放
            return false;
        }
        bytes_to_send -= temp;
        bytes_have_send += temp;
        if ( bytes_to_send <= bytes_have_send ) {
            // 发送HTTP响应成功，根据HTTP请求中的Connection字段决定是否立即关闭连接
            unmap();
            if(m_linger) {
                init();
                modfd( m_epollfd, m_sockfd, EPOLLIN );
                return true;
            } else {
                modfd( m_epollfd, m_sockfd, EPOLLIN );
                return false;
            } 
        }
    }
}

// 往写缓冲中写入待发送的数据
// 为了把数据写到m_write_buf中
bool http_conn::add_response( const char* format, ... ) {
    if( m_write_idx >= WRITE_BUFFER_SIZE ) {  // 写满了
        return false;
    }
    va_list arg_list;  // 解析参数的
    va_start( arg_list, format );
    int len = vsnprintf( m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - 1 - m_write_idx, format, arg_list );
    if( len >= ( WRITE_BUFFER_SIZE - 1 - m_write_idx ) ) {  // 写不下了
        return false;
    }
    m_write_idx += len;
    va_end( arg_list );
    return true;
}

bool http_conn::add_status_line( int status, const char* title ) {
    return add_response( "%s %d %s\r\n", "HTTP/1.1", status, title );
}

bool http_conn::add_headers(int content_len) {  // 写的比较简化
    add_content_length(content_len);
    add_content_type();
    add_linger();
    add_blank_line();
    return 1;
}

bool http_conn::add_content_length(int content_len) {
    return add_response( "Content-Length: %d\r\n", content_len );
}

bool http_conn::add_linger()
{
    //false就是close，true就是keep-alive
    return add_response( "Connection: %s\r\n", ( m_linger == true ) ? "keep-alive" : "close" );
}

bool http_conn::add_blank_line()
{//添加换行
    return add_response( "%s", "\r\n" );
}

bool http_conn::add_content( const char* content )
{
    return add_response( "%s", content );
}

bool http_conn::add_content_type() {
    return add_response("Content-Type:%s\r\n", "text/html");
}

// 根据服务器处理HTTP请求的结果，决定返回给客户端的内容
bool http_conn::process_write(HTTP_CODE ret) {
    switch (ret) // 解析请求的返回值
    {
        case INTERNAL_ERROR:
            add_status_line( 500, error_500_title );
            add_headers( strlen( error_500_form ) );
            if ( ! add_content( error_500_form ) ) {
                return false;
            }
            break;
        case BAD_REQUEST:
            add_status_line( 400, error_400_title );
            add_headers( strlen( error_400_form ) );
            if ( ! add_content( error_400_form ) ) {
                return false;
            }
            break;
        case NO_RESOURCE:
            add_status_line( 404, error_404_title );
            add_headers( strlen( error_404_form ) );
            if ( ! add_content( error_404_form ) ) {
                return false;
            }
            break;
        case FORBIDDEN_REQUEST:
            add_status_line( 403, error_403_title );
            add_headers(strlen( error_403_form));
            if ( ! add_content( error_403_form ) ) {
                return false;
            }
            break;
        case FILE_REQUEST:
            add_status_line(200, ok_200_title );
            add_headers(m_file_stat.st_size);
            m_iv[ 0 ].iov_base = m_write_buf;
            m_iv[ 0 ].iov_len = m_write_idx;
            m_iv[ 1 ].iov_base = m_file_address;
            m_iv[ 1 ].iov_len = m_file_stat.st_size;
            m_iv_count = 2;
            return true;
        default:
            return false;
    }

    m_iv[ 0 ].iov_base = m_write_buf;
    m_iv[ 0 ].iov_len = m_write_idx;
    m_iv_count = 1;
    return true;
}

// 由线程池中的工作线程调用，这是处理HTTP请求的入口函数
void http_conn::run() {
    util_timer* timer_ = timer;
    // 解析HTTP请求，HTTP_CODE为服务器处理HTTP请求的可能结果
    HTTP_CODE read_ret = process_read();
    // 请求不完整
    if ( read_ret == NO_REQUEST ) {
        modfd(m_epollfd, m_sockfd, EPOLLIN );  // 修改重新检测
    }
    
    // 生成响应
    bool write_ret = process_write(read_ret);  // 跟结果去响应
    if ( !write_ret ) {
        close_conn();
    }

    //因为用了oneshot，所以每一次都需要重新去添加这个事件
    modfd(m_epollfd, m_sockfd, EPOLLOUT);//重新监听是否可以写数据
}
```



lst_timer.h

```cpp
#ifndef LST_TIMER
#define LST_TIMER

#include <stdio.h>
#include <time.h>
#include <arpa/inet.h>
#include "httpconn.h"
#include "threadpool.h"
// 采用一个升序的双链表来保存定时器

#define BUFFER_SIZE 64 //读缓冲大小 

class http_conn;
// 定时器类
class util_timer {
public:
    util_timer() : prev(NULL), next(NULL){}

public:
   time_t expire;   // 任务超时时间，这里使用绝对时间
   void (*cb_func)( http_conn* );  // 任务回调函数，回调函数处理的客户数据，由定时器的执行者传递给回调函数
   http_conn* user_data; 
   util_timer* prev;    // 指向前一个定时器
   util_timer* next;    // 指向后一个定时器
};

// 定时器链表，它是一个升序、双向链表，且带有头节点和尾节点。
class sort_timer_lst {
public:
    sort_timer_lst() : head( NULL ), tail( NULL ) {}
    // 链表被销毁时，删除其中所有的定时器
    ~sort_timer_lst() {
        util_timer* tmp = head;
        while( tmp ) {
            head = tmp->next;
            delete tmp;
            tmp = head;
        }
    }
    
    // 将目标定时器timer添加到链表中
    void add_timer( util_timer* timer ) {
        if( !timer ) {
            return;
        }
        if( !head ) {
            head = tail = timer;
            return; 
        }
        /* 如果目标定时器的超时时间小于当前链表中所有定时器的超时时间，则把该定时器插入链表头部,作为链表新的头节点，
           否则就需要调用重载函数 add_timer(),把它插入链表中合适的位置，以保证链表的升序特性 */
        if( timer->expire < head->expire ) {
            timer->next = head;
            head->prev = timer;
            head = timer;
            return;
        }
        add_timer(timer, head);
    }
    
    /* 当某个定时任务发生变化时，调整对应的定时器在链表中的位置。这个函数只考虑被调整的定时器的
    超时时间延长的情况，即该定时器需要往链表的尾部移动。*/
    void adjust_timer(util_timer* timer)
    {
        if( !timer )  {
            return;
        }
        util_timer* tmp = timer->next;
        // 如果被调整的目标定时器处在链表的尾部，或者该定时器新的超时时间值仍然小于其下一个定时器的超时时间则不用调整
        if( !tmp || ( timer->expire < tmp->expire ) ) {
            return;
        }
        // 如果目标定时器是链表的头节点，则将该定时器从链表中取出并重新插入链表
        if( timer == head ) {
            head = head->next;
            head->prev = NULL;
            timer->next = NULL;
            add_timer( timer, head );
        } else {
            // 如果目标定时器不是链表的头节点，则将该定时器从链表中取出，然后插入其原来所在位置后的部分链表中
            timer->prev->next = timer->next;
            timer->next->prev = timer->prev;
            add_timer( timer, timer->next );
        }
    }
    // 将目标定时器 timer 从链表中删除
    void del_timer( util_timer* timer )
    {
        if( !timer ) {
            return;
        }
        // 下面这个条件成立表示链表中只有一个定时器，即目标定时器
        if( ( timer == head ) && ( timer == tail ) ) {
            delete timer;
            head = NULL;
            tail = NULL;
            return;
        }
        /* 如果链表中至少有两个定时器，且目标定时器是链表的头节点，
         则将链表的头节点重置为原头节点的下一个节点，然后删除目标定时器。 */
        if( timer == head ) {
            head = head->next;
            head->prev = NULL;
            delete timer;
            return;
        }
        /* 如果链表中至少有两个定时器，且目标定时器是链表的尾节点，
        则将链表的尾节点重置为原尾节点的前一个节点，然后删除目标定时器。*/
        if( timer == tail ) {
            tail = tail->prev;
            tail->next = NULL;
            delete timer;
            return;
        }
        // 如果目标定时器位于链表的中间，则把它前后的定时器串联起来，然后删除目标定时器
        timer->prev->next = timer->next;
        timer->next->prev = timer->prev;
        delete timer;
    }

    /* SIGALARM 信号每次被触发就在其信号处理函数中执行一次 tick() 函数，以处理链表上到期任务。*/
    void tick() {
        if( !head ) {
            return;
        }
        printf( "timer tick\n" );
        time_t cur = time( NULL );  // 获取当前系统时间
        util_timer* tmp = head;
        // 从头节点开始依次处理每个定时器，直到遇到一个尚未到期的定时器
        while( tmp ) {
            /* 因为每个定时器都使用绝对时间作为超时值，所以可以把定时器的超时值和系统当前时间，
            比较以判断定时器是否到期*/
            if( cur < tmp->expire ) {  // 从第一个开始遍历，没超时则终止
                break;
            }

            // 调用定时器的回调函数，以执行定时任务
            tmp->cb_func( tmp->user_data );
            // 执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头节点
            head = tmp->next;
            if( head ) {
                head->prev = NULL;
            }
            delete tmp;
            tmp = head;
        }
    }

private:
    /* 一个重载的辅助函数，它被公有的 add_timer 函数和 adjust_timer 函数调用
    该函数表示将目标定时器 timer 添加到节点 lst_head 之后的部分链表中 */
    void add_timer(util_timer* timer, util_timer* lst_head)  {
        util_timer* prev = lst_head;
        util_timer* tmp = prev->next;
        /* 遍历 list_head 节点之后的部分链表，直到找到一个超时时间大于目标定时器的超时时间节点
        并将目标定时器插入该节点之前 */
        while(tmp) {
            if( timer->expire < tmp->expire ) {
                prev->next = timer;
                timer->next = tmp;
                tmp->prev = timer;
                timer->prev = prev;
                break;
            }
            prev = tmp;
            tmp = tmp->next;
        }
        /* 如果遍历完 lst_head 节点之后的部分链表，仍未找到超时时间大于目标定时器的超时时间的节点，
           则将目标定时器插入链表尾部，并把它设置为链表新的尾节点。*/
        if( !tmp ) {
            prev->next = timer;
            timer->prev = prev;
            timer->next = NULL;
            tail = timer;
        }
    }

private:
    util_timer* head;   // 头结点
    util_timer* tail;   // 尾结点
};

#endif

```

nonactive_conn.cpp

```cpp
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <pthread.h>
#include "lst_timer.h"
#include "httpconn.h"

#define FD_LIMIT 65535
#define MAX_EVENT_NUMBER 7000//1024
#define TIMESLOT 5  // 超时时间

int Thread::generateId_ = 0;

static int pipefd[2];
static sort_timer_lst timer_lst; //定时器链表，升序排列
static int epollfd = 0;

int setnonblocking( int fd )
{
    int old_option = fcntl( fd, F_GETFL );
    int new_option = old_option | O_NONBLOCK;
    fcntl( fd, F_SETFL, new_option );
    return old_option;
}

void addfd( int epollfd, int fd )  // 将监听的文件描述符和管道设置为ET
{
    epoll_event event;
    event.data.fd = fd;
    event.events = EPOLLIN | EPOLLET;
    epoll_ctl( epollfd, EPOLL_CTL_ADD, fd, &event );
    setnonblocking( fd );
}

// 信号处理函数，将信号发送到了一个管道当中
void sig_handler( int sig )
{
    int save_errno = errno;
    int msg = sig;
    send( pipefd[1], ( char* )&msg, 1, 0 );  // 将
    errno = save_errno;
}

// 添加信号捕捉
void addsig(int sig, void(handler)(int)){
    struct sigaction sa;
    memset(&sa, '\0', sizeof(sa) );  // 将sa的数据清空
    sa.sa_handler = handler;
    sigfillset(&sa.sa_mask);  // 设置临时阻塞信号集
    assert(sigaction(sig, &sa, NULL) != -1);
}

void timer_handler()
{
    // 定时处理任务，实际上就是调用tick()函数
    timer_lst.tick();
    // 因为一次 alarm 调用只会引起一次SIGALARM 信号，所以我们要重新定时，以不断触发 SIGALARM信号。
    alarm(TIMESLOT);
}

// 定时器回调函数，它删除非活动连接socket上的注册事件，并关闭之。
void cb_func( http_conn* user_data )
{
    epoll_ctl( epollfd, EPOLL_CTL_DEL, user_data->m_sockfd, 0 );
    assert( user_data );
    close( user_data->m_sockfd );
    http_conn::m_user_count--;
    printf( "close fd %d\n", user_data->m_sockfd );
}



// 第一个参数argc是参数个数
int main(int argc, char* argv[]) {
    
    if( argc <= 1 ) {  // 参数个数如果小于等于1，则说明有问题，因为我们至少要传入端口号和命令俩参数
        printf( "usage: %s port_number\n", basename(argv[0]));
        // exit(-1);
        return 1;
    }
    // 获取端口号，将其转换为数字
    int port = atoi( argv[1] );


    // 对SIGPIE信号进行处理
    // 客户端程序向服务器端程序发送了消息，然后关闭客户端，
    // 服务器端返回消息的时候就会收到内核给的SIGPIPE信号，导致进程退出
    // 我们通过addsig函数，使得收到SIGPIPE信号时不让进程退出，
    // 而是调用SIG_IGN回调函数
    addsig(SIGPIPE, SIG_IGN);
    //对SIGALRM、SIGTERM设置信号处理函数
    addsig(SIGALRM,sig_handler);
    addsig(SIGTERM,sig_handler);

    // 创建线程池
    ThreadPool pool;
    pool.setMode(PoolMode::MODE_CACHED);
    pool.start(800);

    // 创建一个数组用于保存所有的客户端信息
    http_conn* users = new http_conn[FD_LIMIT];

    int listenfd = socket( PF_INET, SOCK_STREAM, 0 );
    assert( listenfd >= 0 );

    // 端口复用要在绑定之前设置
    int reuse = 1;
    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));

    int ret = 0;
    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons( port );
    ret = bind( listenfd, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( listenfd, 5 );
    assert( ret != -1 );

    // 创建epoll对象，和事件数组，添加
    epoll_event events[MAX_EVENT_NUMBER];
    int epollfd = epoll_create(5);
    // 添加到epoll对象，对于监听的文件描述符不需要oneshot
    addfd(epollfd, listenfd);
    http_conn::m_epollfd = epollfd;
    assert( epollfd != -1 );

    // 创建管道，一端读一端写，0读1写
    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd);
    assert( ret != -1 );
    setnonblocking( pipefd[1] );  // 将写端设置为非堵塞
    addfd( epollfd, pipefd[0] );


    bool stop_server = false;

    bool timeout = false;
    alarm(TIMESLOT);  // 定时,5秒后产生SIGALARM信号

    while( !stop_server )
    {
        int number = epoll_wait( epollfd, events, MAX_EVENT_NUMBER, -1 );
        if ( ( number < 0 ) && ( errno != EINTR ) ) {  // 调用epoll失败。epoll_wait会被SIGALRM信号中断返回-1
            printf( "epoll failure\n" );
            break;
        }
    
        for ( int i = 0; i < number; i++ ) {
            int sockfd = events[i].data.fd;
            if( sockfd == listenfd )
            {
                struct sockaddr_in client_address;
                socklen_t client_addrlength = sizeof( client_address );
                int connfd = accept( listenfd, ( struct sockaddr* )&client_address, &client_addrlength );
                if (connfd < 0) {
                    printf("errno is: %d\n", errno);
                    continue;
                } 
                if(http_conn::m_user_count >= FD_LIMIT) {
                    // 目前连接数满了
                    // 给客户端写一个信息：服务器内部正忙
                    close(connfd);
                    continue;
                }
                users[connfd].init(connfd, client_address);
                
                // 创建定时器，设置其回调函数与超时时间，然后绑定定时器与用户数据，最后将定时器添加到链表timer_lst中
                util_timer* timer = new util_timer;
                timer->user_data = &users[connfd];
                timer->cb_func = cb_func;
                time_t cur = time( NULL );
                // 超时时间为当前时间+三倍的TIMESLOT
                timer->expire = cur + 3 * TIMESLOT;
                users[connfd].timer = timer;
                timer_lst.add_timer( timer );  // 将当前定时器添加到链表中
            } else if( ( sockfd == pipefd[0] ) && ( events[i].events & EPOLLIN )  ) {  // 有读事件发生
                // 处理信号
                int sig;
                char signals[1024];
                ret = recv( pipefd[0], signals, sizeof( signals ), 0 );
                if( ret == -1 ) {
                    continue;
                } else if( ret == 0 ) {
                    continue;
                } else  {
                    for( int i = 0; i < ret; ++i ) {
                        switch( signals[i] )  {
                            case SIGALRM:  // 定时时间到了
                            {
                                // 用timeout变量标记有定时任务需要处理，但不立即处理定时任务
                                // 这是因为定时任务的优先级不是很高，我们优先处理其他更重要的任务。
                                timeout = true;
                                break;
                            }
                            case SIGTERM:
                            {
                                stop_server = true;
                            }
                        }
                    }
                }
            } else if(  events[i].events & EPOLLIN )  // 有数据到达
            {
                util_timer* timer = users[sockfd].timer;
                time_t cur = time( NULL );
                timer->expire = cur + 3 * TIMESLOT;
                timer_lst.adjust_timer(timer);

                if(users[sockfd].read()) {  // 一次性把所有数据都读完
                    pool.submitTask(std::bind(&http_conn::run,users + sockfd));
                } else {
                    timer_lst.del_timer(timer);
                    users[sockfd].close_conn();
                }
            }  else if( events[i].events & EPOLLOUT ) {  // 检测写事件
                if(!users[sockfd].write()) {  // 一次性写完所有数据
                    users[sockfd].close_conn();
                }
            } else if(events[i].events&(EPOLLHUP|EPOLLRDHUP|EPOLLERR)) {
                users[sockfd].close_conn();
            }
           
        }

        // 最后处理定时事件，因为I/O事件有更高的优先级。当然，这样做将导致定时任务不能精准的按照预定的时间执行。
        if( timeout ) {
            timer_handler();
            timeout = false;
        }
    }

    close( listenfd );
    close(epollfd);
    close( pipefd[1] );
    close( pipefd[0] );
    delete [] users;
    return 0;
}

```

httpconn.h

```cpp
#ifndef HTTPCONN_H //防止被重复定义
#define HTTPCONN_H

#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/epoll.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <sys/stat.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <stdarg.h>
#include <errno.h>
#include <sys/uio.h>
#include"threadpool.h"
#include "lst_timer.h"
class util_timer;   // 定时器类的前向声明
class http_conn
{
    friend class util_timer;
public:
    static const int FILENAME_LEN = 200;        // 文件名的最大长度
    static const int READ_BUFFER_SIZE = 2048;   // 读缓冲区的大小
    static const int WRITE_BUFFER_SIZE = 1024;  // 写缓冲区的大小
    
    // 状态机，定义了一些状态
    // 1、HTTP请求方法，这里只支持GET
    enum METHOD {GET = 0, POST, HEAD, PUT, DELETE, TRACE, OPTIONS, CONNECT};
    
    /*
        2、解析客户端请求时，主状态机的状态
        CHECK_STATE_REQUESTLINE:当前正在分析请求行
        CHECK_STATE_HEADER:当前正在分析头部字段
        CHECK_STATE_CONTENT:当前正在解析请求体
    */
    enum CHECK_STATE { CHECK_STATE_REQUESTLINE = 0, CHECK_STATE_HEADER, CHECK_STATE_CONTENT };
    

    // 3、从状态机的三种可能状态，即行的读取状态，分别表示
    // 1.读取到一个完整的行 2.行出错 3.行数据尚且不完整
    enum LINE_STATUS { LINE_OK = 0, LINE_BAD, LINE_OPEN };

    /*
        服务器处理HTTP请求的可能结果，报文解析的结果
        NO_REQUEST          :   请求不完整，需要继续读取客户数据
        GET_REQUEST         :   表示获得了一个完成的客户请求
        BAD_REQUEST         :   表示客户请求语法错误
        NO_RESOURCE         :   表示服务器没有资源
        FORBIDDEN_REQUEST   :   表示客户对资源没有足够的访问权限
        FILE_REQUEST        :   文件请求,获取文件成功
        INTERNAL_ERROR      :   表示服务器内部错误
        CLOSED_CONNECTION   :   表示客户端已经关闭连接了
    */
    enum HTTP_CODE { NO_REQUEST, GET_REQUEST, BAD_REQUEST, NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION };
    
    
public:
    http_conn(){}
    ~http_conn(){}
public:
    void init(int sockfd, const sockaddr_in& addr); // 初始化新接受的连接
    void close_conn();  // 关闭连接

    void run(); // 处理客户端请求

    bool read(); // 非阻塞读
    bool write(); // 非阻塞写
    void init();    // 初始化连接
private:
    
    HTTP_CODE process_read();    // 解析HTTP请求
    bool process_write( HTTP_CODE ret );    // 填充HTTP应答

    // 下面这一组函数被process_read调用以分析HTTP请求
    HTTP_CODE parse_request_line( char* text ); // 解析请求首行
    HTTP_CODE parse_headers( char* text ); // 解析请求头
    HTTP_CODE parse_content( char* text ); // 解析请求体
    HTTP_CODE do_request();
    char* get_line() { return m_read_buf + m_start_line; }  // 获取一行数据
    // 解析具体的一行，属于从状态机
    LINE_STATUS parse_line();

    // 这一组函数被process_write调用以填充HTTP应答。
    void unmap();
    bool add_response( const char* format, ... );
    bool add_content( const char* content );
    bool add_content_type();
    bool add_status_line( int status, const char* title );
    bool add_headers( int content_length );
    bool add_content_length( int content_length );
    bool add_linger();
    bool add_blank_line();

public:
    static int m_epollfd;  // 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的
    static int m_user_count;  // 统计用户的数量
    util_timer* timer;          // 定时器
    int m_sockfd;  // 该HTTP连接的socket和对方的socket地址
    sockaddr_in m_address;  // 通信的socket地址

public:
    
    
    
    
    char m_read_buf[ READ_BUFFER_SIZE ];    // 读缓冲区
    int m_read_idx;                         // 标识读缓冲区中已经读入的客户端数据的最后一个字节的下一个位置
    int m_checked_idx;                      // 当前正在分析的字符在读缓冲区中的位置
    int m_start_line;                       // 当前正在解析的行的起始位置

    CHECK_STATE m_check_state;              // 主状态机当前所处的状态
    METHOD m_method;                        // 请求方法

    char m_real_file[ FILENAME_LEN ];       // 客户请求的目标文件的完整路径，其内容等于 doc_root + m_url, doc_root是网站根目录
    char* m_url;                            // 客户请求的目标文件的文件名
    char* m_version;                        // HTTP协议版本号，我们仅支持HTTP1.1
    char* m_host;                           // 主机名
    int m_content_length;                   // HTTP请求的消息总长度
    bool m_linger;                          // HTTP请求是否要求保持连接

    char m_write_buf[ WRITE_BUFFER_SIZE ];  // 写缓冲区
    int m_write_idx;                        // 写缓冲区中待发送的字节数
    char* m_file_address;                   // 客户请求的目标文件被mmap到内存中的起始位置
    struct stat m_file_stat;                // 目标文件的状态。通过它我们可以判断文件是否存在、是否为目录、是否可读，并获取文件大小等信息
    struct iovec m_iv[2];                   // 我们将采用writev来执行写操作，所以定义下面两个成员，其中m_iv_count表示被写内存块的数量。
                                            // m_iv对应两块分散的内存，分别是m_write_buf和m_file_address
    int m_iv_count;
};

#endif

```

